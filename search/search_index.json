{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Persistencia de datos en dispositivos m\u00f3viles \u00b6 Apuntes de la asignatura","title":"Persistencia de datos en dispositivos m\u00f3viles"},{"location":"#persistencia-de-datos-en-dispositivos-moviles","text":"Apuntes de la asignatura","title":"Persistencia de datos en dispositivos m\u00f3viles"},{"location":"SUMMARY/","text":"Summary \u00b6 Persistencia b\u00e1sica El sistema de archivos Serializaci\u00f3n de clases Property Lists Preferencias de usuario Ejercicios SQLite Introducci\u00f3n a SQLite en iOS El API b\u00e1sico de SQLite Frameworks de terceros Ejercicios \u00a1Hola Core Data!. Una aplicaci\u00f3n de ejemplo Introducci\u00f3n a Core Data El stack de Core Data Las entidades Recuperar los datos Modelos de datos en Core Data Crear modelos Entidades con clases propias CRUD Ejercicios M\u00e1s sobre modelos de datos Tipos de datos transformables Validaciones El ciclo de vida de los objetos gestionados Deshacer y rehacer operaciones Ejercicios B\u00fasquedas en Core Data Predicados Ordenaci\u00f3n Ejercicios Tablas en Core Data El fetched results controller Inicializar el \"fetched results controller\" Mostrar los datos en la tabla Refrescar la tabla Secciones de tabla autom\u00e1ticas Ejercicios Migraciones de datos Qu\u00e9 son las migraciones de datos Versiones del modelo de datos Migraciones ligeras Migraciones pesadas Ejercicios Ap\u00e9ndice: migraciones en iOS<=9 Contextos m\u00faltiples M\u00faltiples contextos para trabajos en background Comunicaci\u00f3n entre contextos Contextos anidados Ejercicios Persistencia como servicio Backend as a Service Gesti\u00f3n de usuarios en Firebase Persistencia en Firebase Ejercicios Arquitecturas de aplicaciones en iOS Model/View/Controller Model/View/Presenter Model/View/ViewModel VIPER Ejercicios parte I Ejercicios parte II Ejercicios parte III","title":"Summary"},{"location":"SUMMARY/#summary","text":"Persistencia b\u00e1sica El sistema de archivos Serializaci\u00f3n de clases Property Lists Preferencias de usuario Ejercicios SQLite Introducci\u00f3n a SQLite en iOS El API b\u00e1sico de SQLite Frameworks de terceros Ejercicios \u00a1Hola Core Data!. Una aplicaci\u00f3n de ejemplo Introducci\u00f3n a Core Data El stack de Core Data Las entidades Recuperar los datos Modelos de datos en Core Data Crear modelos Entidades con clases propias CRUD Ejercicios M\u00e1s sobre modelos de datos Tipos de datos transformables Validaciones El ciclo de vida de los objetos gestionados Deshacer y rehacer operaciones Ejercicios B\u00fasquedas en Core Data Predicados Ordenaci\u00f3n Ejercicios Tablas en Core Data El fetched results controller Inicializar el \"fetched results controller\" Mostrar los datos en la tabla Refrescar la tabla Secciones de tabla autom\u00e1ticas Ejercicios Migraciones de datos Qu\u00e9 son las migraciones de datos Versiones del modelo de datos Migraciones ligeras Migraciones pesadas Ejercicios Ap\u00e9ndice: migraciones en iOS<=9 Contextos m\u00faltiples M\u00faltiples contextos para trabajos en background Comunicaci\u00f3n entre contextos Contextos anidados Ejercicios Persistencia como servicio Backend as a Service Gesti\u00f3n de usuarios en Firebase Persistencia en Firebase Ejercicios Arquitecturas de aplicaciones en iOS Model/View/Controller Model/View/Presenter Model/View/ViewModel VIPER Ejercicios parte I Ejercicios parte II Ejercicios parte III","title":"Summary"},{"location":"cap1/1.1_sistema_de_archivos/","text":"Archivos y directorios en iOS \u00b6 En iOS el sistema de archivos del dispositivo no es visible al completo para una aplicaci\u00f3n cualquiera por motivos de seguridad. Cada aplicaci\u00f3n est\u00e1 contenida en lo que se denomina un sandbox . Una aplicaci\u00f3n solo puede acceder a los archivos y directorios dentro de su sandbox , y a la inversa otras aplicaciones no pueden acceder a ellos. El sandbox tiene una estructura de directorios estandarizada, donde cada directorio tiene un papel espec\u00edfico reservado en la aplicaci\u00f3n. Nuestra aplicaci\u00f3n puede crear y modificar libremente archivos y directorios, aunque siempre deber\u00eda respetar el papel que el sistema le asigna a cada directorio. Primero veremos cu\u00e1l es la estructura \u201cest\u00e1ndar\u201d del sandbox y luego el API para abrir, crear y modificar archivos y directorios. El sistema de archivos de cada aplicaci\u00f3n \u00b6 Cuando se instala una aplicaci\u00f3n en un dispositivo iOS el sistema crea una estructura de directorios como la que aparece en la siguiente figura. Los directorios m\u00e1s importantes son los siguientes: nombre_de_la_aplicacion .app/ : aunque por la extensi\u00f3n podr\u00eda parecer que es un archivo se trata de un directorio, que contiene lo que se denomina el bundle de la aplicaci\u00f3n: el ejecutable, los iconos, im\u00e1genes, sonidos, etc. Documents/ : es el directorio reservado para el contenido creado por el usuario. Si por ejemplo nuestra aplicaci\u00f3n es un editor de textos, aqu\u00ed es donde deber\u00edamos almacenarlos. Library/ : no suele contener directamente archivos sino solamente dos subdirectorios: Caches/ : donde almacenamos los datos que se pueden volver a recrear sin problemas si es necesario. Por ejemplo \u00edndices de datos de nuestra aplicaci\u00f3n que sirvan para hacer las b\u00fasquedas m\u00e1s r\u00e1pidas. Por ello iOS no hace copia de seguridad de este directorio cuando hacemos un backup del dispositivo. Preferences/ : las preferencias de configuraci\u00f3n de la aplicaci\u00f3n, que posteriormente veremos con m\u00e1s detalle. Application Support/ : contenido generado por la aplicaci\u00f3n pero que no ha sido creado directamente por el usuario. tmp/ : como puede deducirse est\u00e1 indicado para archivos y directorios temporales, de los que iOS tampoco har\u00e1 copia de seguridad. Localizar los directorios del sandbox \u00b6 Antes de poder realizar cualquier operaci\u00f3n sobre un archivo o directorio, tenemos primero que localizarlo en el sistema de archivos, es decir, encontrar su path absoluto - desde la ra\u00edz del sistema de archivos. Aunque en iOS no podemos \u201csalirnos fuera\u201d del sandbox este paso sigue siendo necesario. En iOS podemos dar cualquier trayectoria de un archivo de dos formas distintas: como path local (un String ) o como URLs, que uniformizan el tratamiento de las rutas y nos permite tambi\u00e9n especificar la localizaci\u00f3n de recursos remotos. Los nombres de los m\u00e9todos en ambos casos suelen ser iguales, salvo que los que trabajan con paths generalmente acaban en Path y los que trabajan con URLs en URL . Apple recomienda usar URLs en lugar de paths , ya que uniformizan el tratamiento de los recursos, sean locales o no. La clase b\u00e1sica que se usa para interactuar con el sistema de archivos es el FileManager . No es necesario crear una instancia, podemos obtener la instancia por defecto con FileManager.default El bundle de la aplicaci\u00f3n Acceder al directorio con el bundle de la aplicaci\u00f3n (el .app ) es sencillo: 1 let bundleURL = Bundle . main . bundleURL Ya hemos visto antes este tipo de c\u00f3digo cuando acced\u00edamos a im\u00e1genes y otros archivos distribuidos junto a la aplicaci\u00f3n. Con bundlePath en lugar de bundleURL podemos obtener tambi\u00e9n el path en forma local (sin el file:// delante). Los directorios \u201ct\u00edpicos\u201d Para obtener la URL de un directorio del sandbox se usa el m\u00e9todo urls(for:in:) , de la clase FileManager . Al m\u00e9todo le pasamos un par de constantes: La clase de directorio que estamos buscando, como un valor enumerado del tipo FileManager.SearchPathDirectory (por ejemplo para Library/ el valor es libraryDirectory , para Documents es documentDirectory y para Cache , cachesDirectory ). Se puede consultar la lista completa , aunque la mayor\u00eda de valores solo tienen sentido en OSX. El \"dominio\" o \u00e1mbito de la b\u00fasqueda, un valor enumerado del tipo FileManager.SearchPathDomainMask . En iOS siempre usaremos el valor userDomainMask , que en OSX indica el directorio del usuario, pero en iOS en realidad se refiere al \u00e1mbito de la aplicaci\u00f3n actual. Por ejemplo, as\u00ed obtendr\u00edamos la URL del directorio Documents de la aplicaci\u00f3n actual: 1 2 3 4 5 6 7 8 9 10 let urls = FileManager . default . urls ( for :. documentDirectory , in :. userDomainMask ) //N\u00f3tese que el m\u00e9todo devuelve un array de URLs //Casi siempre nos interesa solo la primera if ( urls . count > 0 ) { let docDir = urls [ 0 ] print ( \"El directorio 'Documents' es \\( docDir ) \" ) } else { print ( \"error al buscar el directorio 'Documents'\" ) } Si ejecutamos el c\u00f3digo anterior en un dispositivo real nos aparecer\u00e1 una URL del estilo file:///var/mobile/Containers/Data/Application/id_de_la_aplicacion/Documents . En el simulador la URL ser\u00e1 similar pero la primera parte de la trayectoria cambia ya que se refiere a donde se est\u00e1 ejecutando la app dentro del simulador, algo como file:///Users/[nombre_usuario]/Library/Developer/CoreSimulator/Devices/[id_del_dispositivo]/data/Containers/Data/Application/[id_de_la_aplicacion]/Documents/ . Para complicar un poco m\u00e1s el asunto, el identificador de la app cambiar\u00e1 cada vez que pongamos en marcha el simulador. Durante el desarrollo en el simulador puede ser necesario localizar f\u00edsicamente los directorios de la aplicaci\u00f3n en el disco para poder verificar las operaciones sobre archivos y directorios. Para ayudarnos en esta tarea podemos usar alguna utilidad de terceros como la aplicaci\u00f3n Simpholders . Esta aplicaci\u00f3n es comercial, pero tambi\u00e9n existen aplicaciones libres como https://github.com/dsmelov/simsim . Otra opci\u00f3n, m\u00e1s tediosa, es usar la herramienta simctl . En una terminal escribir: 1 xcrun simctl get_app_container booted <id_de_la_aplicacion> Donde el id de la aplicaci\u00f3n incluye no solo el nombre de la aplicaci\u00f3n sino tambi\u00e9n el identificador del desarrollador (el id de la aplicaci\u00f3n es lo que aparece en la configuraci\u00f3n del proyecto, apartado General , con el nombre Bundle Identifier ) El directorio temporal Podemos obtener el path del directorio para archivos temporales con la propiedad temporaryDirectory del file manager 1 2 let tmpDir = FileManager . default . temporaryDirectory print ( \"Dir. archivos temporales: \\( tmpDir ) \" ) Listar el contenido de los directorios \u00b6 Sabiendo la URL de un determinado directorio podemos listar sus contenidos con el m\u00e9todo contentsOfDirectory(at:includingPropertiesForKeys:options:) El siguiente ejemplo toma el directorio donde est\u00e1 el bundle de la aplicaci\u00f3n y lista sus contenidos, mostrando para cada elemento la fecha de creaci\u00f3n y si es o no un directorio. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 let urlBundle = Bundle . main . bundleURL let contenidos = try ! FileManager . default . contentsOfDirectory ( at : urlBundle , includingPropertiesForKeys : [. creationDateKey , . isDirectoryKey ], options : . skipsHiddenFiles ) print ( \"Hay \\( contenidos . count ) elementos\" ) for url in contenidos { print ( url . lastPathComponent , terminator : \"\" ) let rv = try ! url . resourceValues ( forKeys : [. creationDateKey , . isDirectoryKey ]) print ( \" \\( rv . creationDate ! ) \" , terminator : \"\" ) if rv . isDirectory ! { print ( \" (DIR)\" ) } else { print ( \"\" ) } } El par\u00e1metro includingPropertiesForKeys es un array de constantes de la clase URLResourceKey donde especificamos la \"meta-informaci\u00f3n\" a obtener para cada item (por ejemplo tama\u00f1o, fecha de creaci\u00f3n, si es o no un directorio, etc). options puede ser 0 o bien .skipsHiddenFiles para indicar que no queremos obtener los archivos o directorios ocultos. Una vez obtenemos los items con contentsOfDirectory , mostramos sus datos, incluyendo la informaci\u00f3n obtenida. La \"meta-informaci\u00f3n\" sobre el archivo/directorio se obtiene con el m\u00e9todo de la clase URL llamado resourceValues . Este nos devuelve un objeto URLResourceValues con propiedades que se corresponden con los datos de la \"meta-informaci\u00f3n\" Una versi\u00f3n simplificada del listado de directorios nos la da el m\u00e9todo contentsOfDirectory(atPath:) que trabaja a partir de un path en forma de String y no permite obtener propiedades de los items, solo nos devuelve array de String con los nombres. 1 2 3 4 5 let pathBundle = Bundle . main . bundlePath let contenidos = try ! FileManager . default . contentsOfDirectory ( atPath : pathBundle ) for nombre in contenidos { print ( nombre ) }","title":"Sistema de archivos"},{"location":"cap1/1.1_sistema_de_archivos/#archivos-y-directorios-en-ios","text":"En iOS el sistema de archivos del dispositivo no es visible al completo para una aplicaci\u00f3n cualquiera por motivos de seguridad. Cada aplicaci\u00f3n est\u00e1 contenida en lo que se denomina un sandbox . Una aplicaci\u00f3n solo puede acceder a los archivos y directorios dentro de su sandbox , y a la inversa otras aplicaciones no pueden acceder a ellos. El sandbox tiene una estructura de directorios estandarizada, donde cada directorio tiene un papel espec\u00edfico reservado en la aplicaci\u00f3n. Nuestra aplicaci\u00f3n puede crear y modificar libremente archivos y directorios, aunque siempre deber\u00eda respetar el papel que el sistema le asigna a cada directorio. Primero veremos cu\u00e1l es la estructura \u201cest\u00e1ndar\u201d del sandbox y luego el API para abrir, crear y modificar archivos y directorios.","title":"Archivos y directorios en iOS"},{"location":"cap1/1.1_sistema_de_archivos/#el-sistema-de-archivos-de-cada-aplicacion","text":"Cuando se instala una aplicaci\u00f3n en un dispositivo iOS el sistema crea una estructura de directorios como la que aparece en la siguiente figura. Los directorios m\u00e1s importantes son los siguientes: nombre_de_la_aplicacion .app/ : aunque por la extensi\u00f3n podr\u00eda parecer que es un archivo se trata de un directorio, que contiene lo que se denomina el bundle de la aplicaci\u00f3n: el ejecutable, los iconos, im\u00e1genes, sonidos, etc. Documents/ : es el directorio reservado para el contenido creado por el usuario. Si por ejemplo nuestra aplicaci\u00f3n es un editor de textos, aqu\u00ed es donde deber\u00edamos almacenarlos. Library/ : no suele contener directamente archivos sino solamente dos subdirectorios: Caches/ : donde almacenamos los datos que se pueden volver a recrear sin problemas si es necesario. Por ejemplo \u00edndices de datos de nuestra aplicaci\u00f3n que sirvan para hacer las b\u00fasquedas m\u00e1s r\u00e1pidas. Por ello iOS no hace copia de seguridad de este directorio cuando hacemos un backup del dispositivo. Preferences/ : las preferencias de configuraci\u00f3n de la aplicaci\u00f3n, que posteriormente veremos con m\u00e1s detalle. Application Support/ : contenido generado por la aplicaci\u00f3n pero que no ha sido creado directamente por el usuario. tmp/ : como puede deducirse est\u00e1 indicado para archivos y directorios temporales, de los que iOS tampoco har\u00e1 copia de seguridad.","title":"El sistema de archivos de cada aplicaci\u00f3n"},{"location":"cap1/1.1_sistema_de_archivos/#localizar-los-directorios-del-sandbox","text":"Antes de poder realizar cualquier operaci\u00f3n sobre un archivo o directorio, tenemos primero que localizarlo en el sistema de archivos, es decir, encontrar su path absoluto - desde la ra\u00edz del sistema de archivos. Aunque en iOS no podemos \u201csalirnos fuera\u201d del sandbox este paso sigue siendo necesario. En iOS podemos dar cualquier trayectoria de un archivo de dos formas distintas: como path local (un String ) o como URLs, que uniformizan el tratamiento de las rutas y nos permite tambi\u00e9n especificar la localizaci\u00f3n de recursos remotos. Los nombres de los m\u00e9todos en ambos casos suelen ser iguales, salvo que los que trabajan con paths generalmente acaban en Path y los que trabajan con URLs en URL . Apple recomienda usar URLs en lugar de paths , ya que uniformizan el tratamiento de los recursos, sean locales o no. La clase b\u00e1sica que se usa para interactuar con el sistema de archivos es el FileManager . No es necesario crear una instancia, podemos obtener la instancia por defecto con FileManager.default","title":"Localizar los directorios del sandbox"},{"location":"cap1/1.1_sistema_de_archivos/#listar-el-contenido-de-los-directorios","text":"Sabiendo la URL de un determinado directorio podemos listar sus contenidos con el m\u00e9todo contentsOfDirectory(at:includingPropertiesForKeys:options:) El siguiente ejemplo toma el directorio donde est\u00e1 el bundle de la aplicaci\u00f3n y lista sus contenidos, mostrando para cada elemento la fecha de creaci\u00f3n y si es o no un directorio. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 let urlBundle = Bundle . main . bundleURL let contenidos = try ! FileManager . default . contentsOfDirectory ( at : urlBundle , includingPropertiesForKeys : [. creationDateKey , . isDirectoryKey ], options : . skipsHiddenFiles ) print ( \"Hay \\( contenidos . count ) elementos\" ) for url in contenidos { print ( url . lastPathComponent , terminator : \"\" ) let rv = try ! url . resourceValues ( forKeys : [. creationDateKey , . isDirectoryKey ]) print ( \" \\( rv . creationDate ! ) \" , terminator : \"\" ) if rv . isDirectory ! { print ( \" (DIR)\" ) } else { print ( \"\" ) } } El par\u00e1metro includingPropertiesForKeys es un array de constantes de la clase URLResourceKey donde especificamos la \"meta-informaci\u00f3n\" a obtener para cada item (por ejemplo tama\u00f1o, fecha de creaci\u00f3n, si es o no un directorio, etc). options puede ser 0 o bien .skipsHiddenFiles para indicar que no queremos obtener los archivos o directorios ocultos. Una vez obtenemos los items con contentsOfDirectory , mostramos sus datos, incluyendo la informaci\u00f3n obtenida. La \"meta-informaci\u00f3n\" sobre el archivo/directorio se obtiene con el m\u00e9todo de la clase URL llamado resourceValues . Este nos devuelve un objeto URLResourceValues con propiedades que se corresponden con los datos de la \"meta-informaci\u00f3n\" Una versi\u00f3n simplificada del listado de directorios nos la da el m\u00e9todo contentsOfDirectory(atPath:) que trabaja a partir de un path en forma de String y no permite obtener propiedades de los items, solo nos devuelve array de String con los nombres. 1 2 3 4 5 let pathBundle = Bundle . main . bundlePath let contenidos = try ! FileManager . default . contentsOfDirectory ( atPath : pathBundle ) for nombre in contenidos { print ( nombre ) }","title":"Listar el contenido de los directorios"},{"location":"cap1/1.2_serializacion/","text":"Serializaci\u00f3n/Codificaci\u00f3n de datos \u00b6 Desde la versi\u00f3n 4 de Swift la serializaci\u00f3n de datos en iOS se ha uniformizado en lo que se denomina encoding/decoding . El encoding es el proceso que nos permite pasar de una estructura de datos en memoria a otro formato m\u00e1s adecuado para archivar o transmitir la informaci\u00f3n, por ejemplo JSON, XML,... El decoding es el proceso inverso. El protocolo Codable \u00b6 Para que un objeto sea \"codificable/decodificable\" debe implementar este protocolo. En la mayor\u00eda de casos no ser\u00e1 necesario escribir nada de c\u00f3digo, siempre que nuestra clase/struct est\u00e9 compuesta por campos que sean conformes cn Codable . Muchos tipos b\u00e1sicos de Swift lo son, como los String , Int , Float , Date , Array ... En realidad Codable no es m\u00e1s que una combinaci\u00f3n de los protocolos, Encodable (para codificar) y Decodable (para decodificar): Como ejemplo, supongamos que tenemos una estructura Alumno que representa un alumno de un determinado curso o asignatura. Su definici\u00f3n podr\u00eda ser algo como: 1 2 3 4 5 struct Alumno { var nombre : String var nota : Float var fechaNacimiento : Date } Como los campos de la clase son conformes a Codable para que la propia clase lo sea nos basta con declararla como tal: 1 2 3 struct Alumno : Codable { //..el resto es exactamente igual } Ahora solo necesitamos un \"encoder\", una clase capaz de transformar algo Codable en un formato determinado. En los APIs de iOS tenemos encoders para transformar a/desde formatos como JSON o XML. En la siguiente secci\u00f3n veremos un ejemplo. Almacenar Codable en archivos \u00b6 Una posibilidad es transformar nuestros datos Codable en JSON, XML o un formato para el que tengamos un encoder y luego almacenar el formato resultante en un archivo. Veamos un ejemplo con JSON: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //Esto se usa solo para poder generar fechas a partir de cadenas, //no est\u00e1 relacionado directamente con la serializaci\u00f3n let df = DateFormatter () df . dateFormat = \"dd-MM-yyyy\" //Definir un alumo cuyos datos guardaremos let alumno = Alumno ( nombre : \"Pepe\" , nota : 10.0 , fechaNacimiento : df . date ( from : \"10/10/2000\" ) ! ) //Convertir el alumno a JSON let encoder = JSONEncoder () let datos = try ! encoder . encode ( alumno ) //Almacenarlo en un archivo llamado \"result.json\" en la carpeta Documents var urlDocs = FileManager . default . urls ( for :. documentDirectory , in :. userDomainMask )[ 0 ] let urlFichero = urlDocs . appendingPathComponent ( \"result.json\" ) try ! datos . write ( to : urlFichero ) En JSON hay algunos tipos de datos, como las fechas, que no est\u00e1n estandarizados. El JSONEncoder soporta varios formatos, que podemos seleccionar a trav\u00e9s de la propiedad dateEncodingStrategy . Por ejemplo para guardar las fechas en formato ISO8601: 1 encoder . dateEncodingStrategy = . iso8601 Para leer los datos del archivo usar\u00edamos un JSONEncoder 1 2 3 let datosLeidos = try Data ( contentsOf : urlFichero ) let decoder = JSONDecoder () let alumnoLeido = try decoder . decode ( Jugador . self , from : datosLeidos ) Si al almacenar los datos hubi\u00e9ramos cambiado el formato de fecha, tendr\u00edamos que cambiarlo en la propiedad dateDecodingStrategy del decoder . Otra opci\u00f3n en lugar de usar JSON o XML es usar las clases NSKeyedArchiver y NSKeyedUnarchiver que sirven para \"archivar\" y \"desarchivar\" Codable s, respectivamente. Para codificar los datos usamos el m\u00e9todo encodeEncodable de NSKeyedArchiver 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //Alumno que luego guardaremos let df = DateFormatter () df . dateFormat = \"dd-MM-yyyy\" let alumno1 = Alumno ( nombre : \"Pepe\" , nota : 10.0 , fechaNacimiento : df . date ( from : \"10/10/2000\" ) ! ) //El archivo se llamar\u00e1 \"datos.dat\" dentro del directorio de documentos de la app let urlDocs = FileManager . default . urls ( for :. documentDirectory , in :. userDomainMask )[ 0 ] let urlArchivo = urlDocs . appendingPathComponent ( \"datos.dat\" ) let archiver = NSKeyedArchiver () do { //codificamos try archiver . encodeEncodable ( alumno1 , forKey : NSKeyedArchiveRootObjectKey ) //los datos codificados est\u00e1n en \"encodedData\". Los guardamos en el archivo try archiver . encodedData . write ( to : urlArchivo ) } catch { print ( error ) } Para el paso contrario ( decoding ) usamos el m\u00e9todo decodeTopLevelDecodable de NSKeyedUnarchiver : 1 2 3 4 5 6 7 //aqu\u00ed \"urlArchivo\" tiene el mismo valor que en el ejemplo anterior let datos = try Data ( contentsOf : urlArchivo ) let unarchiver = NSKeyedUnarchiver ( forReadingWith : datos ) if let alumnoLeido = try unarchiver . decodeTopLevelDecodable ( Alumno . self , forKey : NSKeyedArchiveRootObjectKey ) { print ( alumnoLeido . nombre ) //Pepe } En realidad estas clases existen desde antes de la introducci\u00f3n de Codable . Se usaban para guardar datos mediante el mecanismo que exist\u00eda anteriormente en iOS, denominado NSCoding , y se extendieron para poder trabajar tambi\u00e9n con Codable . Configurar Codable \u00b6 En algunas ocasiones nos puede interesar serializar/deserializar los datos usando nombres de campos distintos a los que usamos en nuestras estructuras de datos. Por ejemplo en muchas ocasiones nos tendremos que comunicar con servicios REST cuyo JSON use nombres que nos pueden resultar extra\u00f1os en nuestro c\u00f3digo, o que no se adaptan a las convenciones de Swift. La asociaci\u00f3n entre los nombres de los campos en el formato serializado y en nuestro c\u00f3digo se puede definir en una enumeraci\u00f3n de String s llamada CodingKeys que debe ser conforme al protocolo CodingKey . Supongamos que en el ejemplo del struct Alumno queremos que en nuestra estructura de datos la fecha se siga llamando fechaNacimiento pero en el formato serializado sea fecha_nacimiento . Lo har\u00edamos del siguiente modo: 1 2 3 4 5 6 7 8 9 10 struct Alumno { var nombre : String var nota : Float var fechaNacimiento : Date private enum CodingKeys : String , CodingKey { case nombre case nota case fechaNacimiento = \"fecha_nacimiento\" } }","title":"Serializaci\u00f3n"},{"location":"cap1/1.2_serializacion/#serializacioncodificacion-de-datos","text":"Desde la versi\u00f3n 4 de Swift la serializaci\u00f3n de datos en iOS se ha uniformizado en lo que se denomina encoding/decoding . El encoding es el proceso que nos permite pasar de una estructura de datos en memoria a otro formato m\u00e1s adecuado para archivar o transmitir la informaci\u00f3n, por ejemplo JSON, XML,... El decoding es el proceso inverso.","title":"Serializaci\u00f3n/Codificaci\u00f3n de datos"},{"location":"cap1/1.2_serializacion/#el-protocolo-codable","text":"Para que un objeto sea \"codificable/decodificable\" debe implementar este protocolo. En la mayor\u00eda de casos no ser\u00e1 necesario escribir nada de c\u00f3digo, siempre que nuestra clase/struct est\u00e9 compuesta por campos que sean conformes cn Codable . Muchos tipos b\u00e1sicos de Swift lo son, como los String , Int , Float , Date , Array ... En realidad Codable no es m\u00e1s que una combinaci\u00f3n de los protocolos, Encodable (para codificar) y Decodable (para decodificar): Como ejemplo, supongamos que tenemos una estructura Alumno que representa un alumno de un determinado curso o asignatura. Su definici\u00f3n podr\u00eda ser algo como: 1 2 3 4 5 struct Alumno { var nombre : String var nota : Float var fechaNacimiento : Date } Como los campos de la clase son conformes a Codable para que la propia clase lo sea nos basta con declararla como tal: 1 2 3 struct Alumno : Codable { //..el resto es exactamente igual } Ahora solo necesitamos un \"encoder\", una clase capaz de transformar algo Codable en un formato determinado. En los APIs de iOS tenemos encoders para transformar a/desde formatos como JSON o XML. En la siguiente secci\u00f3n veremos un ejemplo.","title":"El protocolo Codable"},{"location":"cap1/1.2_serializacion/#almacenar-codable-en-archivos","text":"Una posibilidad es transformar nuestros datos Codable en JSON, XML o un formato para el que tengamos un encoder y luego almacenar el formato resultante en un archivo. Veamos un ejemplo con JSON: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //Esto se usa solo para poder generar fechas a partir de cadenas, //no est\u00e1 relacionado directamente con la serializaci\u00f3n let df = DateFormatter () df . dateFormat = \"dd-MM-yyyy\" //Definir un alumo cuyos datos guardaremos let alumno = Alumno ( nombre : \"Pepe\" , nota : 10.0 , fechaNacimiento : df . date ( from : \"10/10/2000\" ) ! ) //Convertir el alumno a JSON let encoder = JSONEncoder () let datos = try ! encoder . encode ( alumno ) //Almacenarlo en un archivo llamado \"result.json\" en la carpeta Documents var urlDocs = FileManager . default . urls ( for :. documentDirectory , in :. userDomainMask )[ 0 ] let urlFichero = urlDocs . appendingPathComponent ( \"result.json\" ) try ! datos . write ( to : urlFichero ) En JSON hay algunos tipos de datos, como las fechas, que no est\u00e1n estandarizados. El JSONEncoder soporta varios formatos, que podemos seleccionar a trav\u00e9s de la propiedad dateEncodingStrategy . Por ejemplo para guardar las fechas en formato ISO8601: 1 encoder . dateEncodingStrategy = . iso8601 Para leer los datos del archivo usar\u00edamos un JSONEncoder 1 2 3 let datosLeidos = try Data ( contentsOf : urlFichero ) let decoder = JSONDecoder () let alumnoLeido = try decoder . decode ( Jugador . self , from : datosLeidos ) Si al almacenar los datos hubi\u00e9ramos cambiado el formato de fecha, tendr\u00edamos que cambiarlo en la propiedad dateDecodingStrategy del decoder . Otra opci\u00f3n en lugar de usar JSON o XML es usar las clases NSKeyedArchiver y NSKeyedUnarchiver que sirven para \"archivar\" y \"desarchivar\" Codable s, respectivamente. Para codificar los datos usamos el m\u00e9todo encodeEncodable de NSKeyedArchiver 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //Alumno que luego guardaremos let df = DateFormatter () df . dateFormat = \"dd-MM-yyyy\" let alumno1 = Alumno ( nombre : \"Pepe\" , nota : 10.0 , fechaNacimiento : df . date ( from : \"10/10/2000\" ) ! ) //El archivo se llamar\u00e1 \"datos.dat\" dentro del directorio de documentos de la app let urlDocs = FileManager . default . urls ( for :. documentDirectory , in :. userDomainMask )[ 0 ] let urlArchivo = urlDocs . appendingPathComponent ( \"datos.dat\" ) let archiver = NSKeyedArchiver () do { //codificamos try archiver . encodeEncodable ( alumno1 , forKey : NSKeyedArchiveRootObjectKey ) //los datos codificados est\u00e1n en \"encodedData\". Los guardamos en el archivo try archiver . encodedData . write ( to : urlArchivo ) } catch { print ( error ) } Para el paso contrario ( decoding ) usamos el m\u00e9todo decodeTopLevelDecodable de NSKeyedUnarchiver : 1 2 3 4 5 6 7 //aqu\u00ed \"urlArchivo\" tiene el mismo valor que en el ejemplo anterior let datos = try Data ( contentsOf : urlArchivo ) let unarchiver = NSKeyedUnarchiver ( forReadingWith : datos ) if let alumnoLeido = try unarchiver . decodeTopLevelDecodable ( Alumno . self , forKey : NSKeyedArchiveRootObjectKey ) { print ( alumnoLeido . nombre ) //Pepe } En realidad estas clases existen desde antes de la introducci\u00f3n de Codable . Se usaban para guardar datos mediante el mecanismo que exist\u00eda anteriormente en iOS, denominado NSCoding , y se extendieron para poder trabajar tambi\u00e9n con Codable .","title":"Almacenar Codable en archivos"},{"location":"cap1/1.2_serializacion/#configurar-codable","text":"En algunas ocasiones nos puede interesar serializar/deserializar los datos usando nombres de campos distintos a los que usamos en nuestras estructuras de datos. Por ejemplo en muchas ocasiones nos tendremos que comunicar con servicios REST cuyo JSON use nombres que nos pueden resultar extra\u00f1os en nuestro c\u00f3digo, o que no se adaptan a las convenciones de Swift. La asociaci\u00f3n entre los nombres de los campos en el formato serializado y en nuestro c\u00f3digo se puede definir en una enumeraci\u00f3n de String s llamada CodingKeys que debe ser conforme al protocolo CodingKey . Supongamos que en el ejemplo del struct Alumno queremos que en nuestra estructura de datos la fecha se siga llamando fechaNacimiento pero en el formato serializado sea fecha_nacimiento . Lo har\u00edamos del siguiente modo: 1 2 3 4 5 6 7 8 9 10 struct Alumno { var nombre : String var nota : Float var fechaNacimiento : Date private enum CodingKeys : String , CodingKey { case nombre case nota case fechaNacimiento = \"fecha_nacimiento\" } }","title":"Configurar Codable"},{"location":"cap1/1.3_property_lists/","text":"Property lists \u00b6 Las property list son estructuras de datos tipo pares de clave-valor ampliamente utilizadas en iOS para almacenar datos de configuraci\u00f3n. Las property list tienen dos limitaciones pr\u00e1cticas fundamentales: No se puede almacenar cualquier tipo de datos, solo algunos: String , valores num\u00e9ricos, Data , Date o Boolean . Y como colecciones de datos Array y Dictionary . No son modificables, es decir, no tenemos un API para cambiar un \u00fanico dato en el archivo. Hay que serializar de nuevo toda la estructura y generar el archivo partiendo de cero. Por ello no son adecuadas para almacenar grandes cantidades de datos. El formato de las property lists \u00b6 Las property lists se pueden almacenar en archivos en modo texto o binario. En los ejemplos usaremos sobre todo el modo texto. En este modo se usa el formato XML, aqu\u00ed tenemos un ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"> <plist version= \"1.0\" > <dict> <key> colorFondo </key> <array> <integer> 255 </integer> <integer> 255 </integer> <integer> 0 </integer> </array> <key> fuente </key> <string> System </string> </dict> </plist> La ra\u00edz de la estructura de datos puede ser un diccionario, como en nuestro caso, o un array. Xcode incluye un editor de property lists con el que podemos editar los datos de forma \"asistida\" sin tener que tocar directamente el XML. Creamos una nueva lista con File > New y entre las plantillas elegimos evidentemente Property list . La extensi\u00f3n t\u00edpica para estos archivos es .plist . Lo primero que hacemos es elegir qu\u00e9 va a ser la ra\u00edz (array o diccionario) y luego vamos creando \"nodos\". Para cada uno tecleamos un nombre, elegimos el tipo y tecleamos el valor. En el caso de los arrays a\u00f1adimos valores \"desplegando\" el nodo (con la flechita que aparece a la izquierda, y pulsando sobre el bot\u00f3n del + ) Podemos tambi\u00e9n editar el XML en modo texto pulsando con bot\u00f3n derecho sobre el archivo y eligiendo en el men\u00fa contextual \"Open as > Source Code\" Leer una property list \u00b6 Leer una property list de un archivo es muy sencillo usando el encoding/decoding de Swift. En el framework Foundation se define un PropertyListDecoder que sirve para deserializar estos archivos. Por ejemplo supongamos una plist cuya ra\u00edz es un diccionario y con dos propiedades, nombre de tipo String y puntuacion de tipo entero. Una vez deserializados, podemos almacenar los datos en un struct de Swift como este 1 2 3 4 struct Props : Codable { var nombre : String var puntuacion : Int } Cuando se crea una plist con Xcode se a\u00f1ade al bundle de la aplicaci\u00f3n. Suponiendo que est\u00e1 en dicho bundle podr\u00edamos leerla con el siguiente c\u00f3digo, que como se ve es muy sencillo gracias a Codable : 1 2 3 4 5 6 7 if let plistURL = Bundle . main . url ( forResource : \"mi_plist\" , withExtension : \"plist\" ) { let data = try Data ( contentsOf : plistURL ) let decoder = PropertyListDecoder () let misProps = try decoder . decode ( Props . self , from : data ) print ( misProps ) } En versiones anteriores de Swift la forma de leer/guardar property list era distinta, algo m\u00e1s engorrosa (aunque tampoco excesivamente complicada). Pod\u00e9is consultar un ejemplo comparando el m\u00e9todo antiguo y el nuevo en este blog . Guardar una property list \u00b6 Veamos c\u00f3mo har\u00edamos el paso inverso: almacenar en un archivo una estructura de datos compatible con una property list . Recordemos que el bundle de la aplicaci\u00f3n es solo de lectura, por lo que un .plist almacenado en esta localizaci\u00f3n no ser\u00e1 modificable. La estrategia habitual es hacer que cuando arranque la aplicaci\u00f3n se realice una copia en otro directorio con permisos de escritura, t\u00edpicamente Documents y que a partir de entonces se trabaje con esa copia. Suponiendo que tenemos definido el mismo struct Props del ejemplo anterior, har\u00edamos uso de un PropertyListEncoder como sigue: 1 2 3 4 5 6 7 8 var urlDocs = FileManager . default . urls ( for :. documentDirectory , in :. userDomainMask )[ 0 ] let urlPlist = urlDocs . appendingPathComponent ( \"result.plist\" ) let encoder = PropertyListEncoder () encoder . outputFormat = . xml let misProps = Props ( nombre : \"John\" , puntuacion : 100 ) let data = try encoder . encode ( misProps ) try data . write ( to : urlPlist )","title":"Property lists"},{"location":"cap1/1.3_property_lists/#property-lists","text":"Las property list son estructuras de datos tipo pares de clave-valor ampliamente utilizadas en iOS para almacenar datos de configuraci\u00f3n. Las property list tienen dos limitaciones pr\u00e1cticas fundamentales: No se puede almacenar cualquier tipo de datos, solo algunos: String , valores num\u00e9ricos, Data , Date o Boolean . Y como colecciones de datos Array y Dictionary . No son modificables, es decir, no tenemos un API para cambiar un \u00fanico dato en el archivo. Hay que serializar de nuevo toda la estructura y generar el archivo partiendo de cero. Por ello no son adecuadas para almacenar grandes cantidades de datos.","title":"Property lists"},{"location":"cap1/1.3_property_lists/#el-formato-de-las-property-lists","text":"Las property lists se pueden almacenar en archivos en modo texto o binario. En los ejemplos usaremos sobre todo el modo texto. En este modo se usa el formato XML, aqu\u00ed tenemos un ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"> <plist version= \"1.0\" > <dict> <key> colorFondo </key> <array> <integer> 255 </integer> <integer> 255 </integer> <integer> 0 </integer> </array> <key> fuente </key> <string> System </string> </dict> </plist> La ra\u00edz de la estructura de datos puede ser un diccionario, como en nuestro caso, o un array. Xcode incluye un editor de property lists con el que podemos editar los datos de forma \"asistida\" sin tener que tocar directamente el XML. Creamos una nueva lista con File > New y entre las plantillas elegimos evidentemente Property list . La extensi\u00f3n t\u00edpica para estos archivos es .plist . Lo primero que hacemos es elegir qu\u00e9 va a ser la ra\u00edz (array o diccionario) y luego vamos creando \"nodos\". Para cada uno tecleamos un nombre, elegimos el tipo y tecleamos el valor. En el caso de los arrays a\u00f1adimos valores \"desplegando\" el nodo (con la flechita que aparece a la izquierda, y pulsando sobre el bot\u00f3n del + ) Podemos tambi\u00e9n editar el XML en modo texto pulsando con bot\u00f3n derecho sobre el archivo y eligiendo en el men\u00fa contextual \"Open as > Source Code\"","title":"El formato de las property lists"},{"location":"cap1/1.3_property_lists/#leer-una-property-list","text":"Leer una property list de un archivo es muy sencillo usando el encoding/decoding de Swift. En el framework Foundation se define un PropertyListDecoder que sirve para deserializar estos archivos. Por ejemplo supongamos una plist cuya ra\u00edz es un diccionario y con dos propiedades, nombre de tipo String y puntuacion de tipo entero. Una vez deserializados, podemos almacenar los datos en un struct de Swift como este 1 2 3 4 struct Props : Codable { var nombre : String var puntuacion : Int } Cuando se crea una plist con Xcode se a\u00f1ade al bundle de la aplicaci\u00f3n. Suponiendo que est\u00e1 en dicho bundle podr\u00edamos leerla con el siguiente c\u00f3digo, que como se ve es muy sencillo gracias a Codable : 1 2 3 4 5 6 7 if let plistURL = Bundle . main . url ( forResource : \"mi_plist\" , withExtension : \"plist\" ) { let data = try Data ( contentsOf : plistURL ) let decoder = PropertyListDecoder () let misProps = try decoder . decode ( Props . self , from : data ) print ( misProps ) } En versiones anteriores de Swift la forma de leer/guardar property list era distinta, algo m\u00e1s engorrosa (aunque tampoco excesivamente complicada). Pod\u00e9is consultar un ejemplo comparando el m\u00e9todo antiguo y el nuevo en este blog .","title":"Leer una property list"},{"location":"cap1/1.3_property_lists/#guardar-una-property-list","text":"Veamos c\u00f3mo har\u00edamos el paso inverso: almacenar en un archivo una estructura de datos compatible con una property list . Recordemos que el bundle de la aplicaci\u00f3n es solo de lectura, por lo que un .plist almacenado en esta localizaci\u00f3n no ser\u00e1 modificable. La estrategia habitual es hacer que cuando arranque la aplicaci\u00f3n se realice una copia en otro directorio con permisos de escritura, t\u00edpicamente Documents y que a partir de entonces se trabaje con esa copia. Suponiendo que tenemos definido el mismo struct Props del ejemplo anterior, har\u00edamos uso de un PropertyListEncoder como sigue: 1 2 3 4 5 6 7 8 var urlDocs = FileManager . default . urls ( for :. documentDirectory , in :. userDomainMask )[ 0 ] let urlPlist = urlDocs . appendingPathComponent ( \"result.plist\" ) let encoder = PropertyListEncoder () encoder . outputFormat = . xml let misProps = Props ( nombre : \"John\" , puntuacion : 100 ) let data = try encoder . encode ( misProps ) try data . write ( to : urlPlist )","title":"Guardar una property list"},{"location":"cap1/1.4_preferencias/","text":"Preferencias de usuario \u00b6 En la mayor\u00eda de las aplicaciones podemos configurar una serie de par\u00e1metros que las adaptan a las preferencias o necesidades del usuario. Son elementos tales como colores, tipos de fuentes, unidades de medida, nombres de usuarios y contrase\u00f1as de servicios de terceros, etc. iOS nos ofrece un mecanismo est\u00e1ndar para almacenar estas preferencias de modo permanente. El API es bastante sencillo y nos permite establecer unos valores por defecto, modificarlos seg\u00fan lo que indique el usuario y leer los valores previamente fijados. Hay que destacar que iOS solo nos da el API para leer/almacenar las preferencias, pero no el interfaz de usuario para mostrarlas/modificarlas, que es nuestra responsabilidad. Hay una excepci\u00f3n: si queremos que nuestras preferencias aparezcan dentro de las del sistema, el propio iOS se encargar\u00e1 de la interfaz. Qu\u00e9 se puede guardar en las preferencias \u00b6 Desde el punto de vista del tipo de datos, las preferencias de usuario no son m\u00e1s que una property list en la que el objeto \u201cra\u00edz\u201d es un NSDictionary . El sistema se encarga de serializar/deserializar los valores a/desde un archivo .plist de modo autom\u00e1tico. Si usamos este API nos ahorraremos tener que gestionar manualmente el .plist como hac\u00edamos en la secci\u00f3n anterior. No tenemos que crearlo nosotros, comprobar si existe, guardarlo cuando toque o recuperar los datos cuando hagan falta, iOS lo har\u00e1 por nosotros. El fichero .plist con las preferencias se almacena autom\u00e1ticamente en el directorio Library/Preferences de la aplicaci\u00f3n. Su nombre ser\u00e1 el del proyecto de Xcode, precedido del \"organization identifier\" del proyecto. Por defecto el .plist se genera en formato binario. Aunque no est\u00e9 en modo texto podemos igualmente abrirlo y editarlo con el editor de .plist de Xcode. Tambi\u00e9n podemos convertirlo a XML con una herramienta en l\u00ednea de comandos llamada plutil , instalada por defecto junto con Xcode: 1 plutil -convert xml1 -o resultado_xml.plist fichero_original.plist Acceder a las preferencias \u00b6 Las preferencias del usuario actual son accesibles a trav\u00e9s del singleton de la clase UserDefaults . Para acceder a la \u00fanica instancia, usar el inicializador del mismo nombre 1 let preferencias = UserDefaults () Como las aplicaciones iOS est\u00e1n en un sandbox cada una solo tiene acceso a sus propias preferencias. El propio sistema no puede cambiar las preferencas de nuestra aplicaci\u00f3n, salvo las que coloquemos dentro de las \u201cgenerales\u201d, como veremos en el punto siguiente Dentro del almac\u00e9n de preferencias cada una de ellas tiene una clave, que ser\u00e1 una cadena, y un valor. As\u00ed, podemos acceder a una preferencia con una familia de m\u00e9todos xxx(forKey:) , donde la \"xxx\" var\u00eda seg\u00fan el tipo de datos: integer , bool , float , double , array , object ,\u2026 Por ejemplo, supongamos un juego en el que tuvi\u00e9ramos almacenado el nick del usuario y el nivel alcanzado. Podr\u00edamos obtener los valores con: 1 2 let nick = preferencias . string ( forKey : \"nick\" ); let nivel = preferencias . integer ( forKey : \"nivel\" ) Al leer los valores de las preferencias se plantea un problema: c\u00f3mo saber si ya tenemos un valor almacenado en las preferencias o no. En ciertos tipos de datos esto es sencillo: en un String como la preferencia nick , de no haber ya algo almacenado con esa clave se obtendr\u00e1 nil . Pero con otros tipos no es tan f\u00e1cil, ya que en el caso del nivel si la preferencia no exist\u00eda se obtendr\u00e1 0. Entonces \u00bfc\u00f3mo diferenciar si la preferencia se ha fijado a 0 o bien es que no se ha fijado?. La soluci\u00f3n es registrar valores por defecto para todas las preferencias, de modo que no pueda haber una preferencia con un valor no fijado, bien sea porque se ha hecho por defecto o bien sea porque lo ha hecho una acci\u00f3n del usuario. Registrar valores por defecto \u00b6 Podemos registrar un conjunto de preferencias por defecto pas\u00e1ndole un diccionario al m\u00e9todo registerDefaults de UserDefaults : 1 2 3 4 5 let prefs = UserDefaults () prefs . register ( defaults :[ \"nick\" : \"anonimo\" , \"nivel\" : 1 ]) Hay que destacar que los valores registrados por defecto no son permanentes . Es decir, que hay que registrarlos cada vez que arranque la aplicaci\u00f3n. Si registramos un valor por defecto y este ya ha sido fijado por c\u00f3digo (en la siguiente secci\u00f3n veremos c\u00f3mo) el valor por defecto no \u201cmachacar\u00e1\u201d al ya fijado. Cuando iOS busca el valor para una preferencia sigue un esquema de \u201cdominios\u201d, en el que si no encuentra la clave en un dominio la busca en el siguiente. De este modo, primero busca en el dominio de los valores fijados por el usuario y si lo encuentra aqu\u00ed lo devuelve. Es solo si no lo encuentra aqu\u00ed cuando pasa a consultar los valores por defecto. En un poco tedioso tener que volcar en el c\u00f3digo un diccionario con todos los valores por defecto. Un m\u00e9todo muy habitual de registrar los valores por defecto de modo m\u00e1s \u201climpio\u201d es almacenarlos en un archivo .plist y deserializarlos con initWithContentsOfFile , como vimos en el apartado de c\u00f3mo leer property lists . Modificar los valores de las preferencias \u00b6 Simplemente tenemos que fijar la clave al valor que queramos usando la familia de m\u00e9todos set(valor,forKey:) 1 2 3 let prefs = UserDefaults () prefs . set ( 5 , forKey : \"nivel\" ) prefs . set ( \"Pepito\" , forKey : \"nick\" ) Por cuestiones de eficiencia, iOS no hace persistente el cambio inmediatamente sino a intervalos regulares o en momentos especiales (por ejemplo justo antes de salir de la aplicaci\u00f3n). Una property list no se puede modificar de manera parcial y hay que crearla entera de nuevo, de manera que no ser\u00eda eficiente persistir siempre los datos tras ejecutar el set . Por c\u00f3digo podemos forzar el cambio en el .plist llamando al m\u00e9todo synchronize de las preferencias 1 UserDefaults (). synchronize () Otra forma de \"forzar\" la persistencia probando la aplicaci\u00f3n es salir de la misma pulsando en el bot\u00f3n \"home\" ( Shift+Cmd+H en el simulador) para que pase a background , momento en el que, como ya hemos dicho, iOS almacena de modo permanente los valores actuales. Como iOS tiene que modificar los datos si hay preferencias modificadas desde la \u00faltima vez que se guardaron, no es aconsejable cambiar el valor de una preferencia \u201ca las primeras de cambio\u201d. Solo es adecuado si no es previsible que vaya a cambiar dentro de poco tiempo. Una estrategia t\u00edpica es fijar los valores justo antes de salir de la aplicaci\u00f3n. Material complementario: ubicar las preferencias en el \u201cpanel de control\u201d general \u00b6 Nota Este apartado no te servir\u00e1 para los ejercicios pero puedes echarle un vistazo para saber algo m\u00e1s del tema El sistema nos da la posibilidad de controlar ciertas preferencias de nuestra aplicaci\u00f3n dentro de las preferencias generales del sistema, en un apartado reservado a ella. Esto es lo que se conoce en iOS como un settings bundle . Podemos colocar aqu\u00ed todas las preferencias o solo algunas. Apple recomienda colocar en el sistema solo las preferencias que se cambien en raras ocasiones. Por ejemplo en una aplicaci\u00f3n que gestione un servicio de terceros podemos colocar aqu\u00ed las credenciales de uso del servicio (login y password) A diferencia de las preferencias dentro de la aplicaci\u00f3n, donde iOS nos da un API para editarlas/verlas pero no una interfaz esto es al contrario. En un fichero .plist con un formato especial podemos crear de modo sencillo una interfaz para las preferencias. Para crear un settings bundle en Xcode ir a File > New > File ... y en el cuadro de di\u00e1logo que aparecer\u00e1, dentro del tipo Resource elegir Settings Bundle . Se crear\u00e1 un archivo de tipo property list llamado Root.plist y algunos archivos auxiliares para la internacionalizaci\u00f3n (necesarios ya que vamos a tratar con elementos de interfaz). Si editamos el Root.plist con el editor de Xcode podemos ver que tiene un formato un tanto especial: la lista de preferencias se representa con un array de items. Las propiedades de estos items son las que determinan el tipo de widget a usar para editar/ver la preferencia, sus par\u00e1metros y la clave con la que se va a almacenar la preferencia asociada. En el ejemplo que se muestra a continuaci\u00f3n, que se corresponde con el Root.plist que crea por defecto Xcode, puede verse que el item 1 es de tipo \"campo de texto\", que su title (la etiqueta que se ve en las preferencias) es Name , que el widget tiene una serie de propiedades (cuando se edita aparece un teclado alfab\u00e9tico, no es seguro - o sea, se muestra el contenido, \u2026) y est\u00e1 asociada a la preferencia cuya clave es name_preference (propiedad Identifier ). No tenemos espacio en estos apuntes para explicar m\u00e1s detalladamente el proceso de configuraci\u00f3n del bundle . El lector interesado puede consultar el apartado \u201c implementing an iOS settings bundle \u201d de la \u201c Preferences and Settings Programming Guide \u201d de Apple.","title":"Preferencias"},{"location":"cap1/1.4_preferencias/#preferencias-de-usuario","text":"En la mayor\u00eda de las aplicaciones podemos configurar una serie de par\u00e1metros que las adaptan a las preferencias o necesidades del usuario. Son elementos tales como colores, tipos de fuentes, unidades de medida, nombres de usuarios y contrase\u00f1as de servicios de terceros, etc. iOS nos ofrece un mecanismo est\u00e1ndar para almacenar estas preferencias de modo permanente. El API es bastante sencillo y nos permite establecer unos valores por defecto, modificarlos seg\u00fan lo que indique el usuario y leer los valores previamente fijados. Hay que destacar que iOS solo nos da el API para leer/almacenar las preferencias, pero no el interfaz de usuario para mostrarlas/modificarlas, que es nuestra responsabilidad. Hay una excepci\u00f3n: si queremos que nuestras preferencias aparezcan dentro de las del sistema, el propio iOS se encargar\u00e1 de la interfaz.","title":"Preferencias de usuario"},{"location":"cap1/1.4_preferencias/#que-se-puede-guardar-en-las-preferencias","text":"Desde el punto de vista del tipo de datos, las preferencias de usuario no son m\u00e1s que una property list en la que el objeto \u201cra\u00edz\u201d es un NSDictionary . El sistema se encarga de serializar/deserializar los valores a/desde un archivo .plist de modo autom\u00e1tico. Si usamos este API nos ahorraremos tener que gestionar manualmente el .plist como hac\u00edamos en la secci\u00f3n anterior. No tenemos que crearlo nosotros, comprobar si existe, guardarlo cuando toque o recuperar los datos cuando hagan falta, iOS lo har\u00e1 por nosotros. El fichero .plist con las preferencias se almacena autom\u00e1ticamente en el directorio Library/Preferences de la aplicaci\u00f3n. Su nombre ser\u00e1 el del proyecto de Xcode, precedido del \"organization identifier\" del proyecto. Por defecto el .plist se genera en formato binario. Aunque no est\u00e9 en modo texto podemos igualmente abrirlo y editarlo con el editor de .plist de Xcode. Tambi\u00e9n podemos convertirlo a XML con una herramienta en l\u00ednea de comandos llamada plutil , instalada por defecto junto con Xcode: 1 plutil -convert xml1 -o resultado_xml.plist fichero_original.plist","title":"Qu\u00e9 se puede guardar en las preferencias"},{"location":"cap1/1.4_preferencias/#acceder-a-las-preferencias","text":"Las preferencias del usuario actual son accesibles a trav\u00e9s del singleton de la clase UserDefaults . Para acceder a la \u00fanica instancia, usar el inicializador del mismo nombre 1 let preferencias = UserDefaults () Como las aplicaciones iOS est\u00e1n en un sandbox cada una solo tiene acceso a sus propias preferencias. El propio sistema no puede cambiar las preferencas de nuestra aplicaci\u00f3n, salvo las que coloquemos dentro de las \u201cgenerales\u201d, como veremos en el punto siguiente Dentro del almac\u00e9n de preferencias cada una de ellas tiene una clave, que ser\u00e1 una cadena, y un valor. As\u00ed, podemos acceder a una preferencia con una familia de m\u00e9todos xxx(forKey:) , donde la \"xxx\" var\u00eda seg\u00fan el tipo de datos: integer , bool , float , double , array , object ,\u2026 Por ejemplo, supongamos un juego en el que tuvi\u00e9ramos almacenado el nick del usuario y el nivel alcanzado. Podr\u00edamos obtener los valores con: 1 2 let nick = preferencias . string ( forKey : \"nick\" ); let nivel = preferencias . integer ( forKey : \"nivel\" ) Al leer los valores de las preferencias se plantea un problema: c\u00f3mo saber si ya tenemos un valor almacenado en las preferencias o no. En ciertos tipos de datos esto es sencillo: en un String como la preferencia nick , de no haber ya algo almacenado con esa clave se obtendr\u00e1 nil . Pero con otros tipos no es tan f\u00e1cil, ya que en el caso del nivel si la preferencia no exist\u00eda se obtendr\u00e1 0. Entonces \u00bfc\u00f3mo diferenciar si la preferencia se ha fijado a 0 o bien es que no se ha fijado?. La soluci\u00f3n es registrar valores por defecto para todas las preferencias, de modo que no pueda haber una preferencia con un valor no fijado, bien sea porque se ha hecho por defecto o bien sea porque lo ha hecho una acci\u00f3n del usuario.","title":"Acceder a las preferencias"},{"location":"cap1/1.4_preferencias/#registrar-valores-por-defecto","text":"Podemos registrar un conjunto de preferencias por defecto pas\u00e1ndole un diccionario al m\u00e9todo registerDefaults de UserDefaults : 1 2 3 4 5 let prefs = UserDefaults () prefs . register ( defaults :[ \"nick\" : \"anonimo\" , \"nivel\" : 1 ]) Hay que destacar que los valores registrados por defecto no son permanentes . Es decir, que hay que registrarlos cada vez que arranque la aplicaci\u00f3n. Si registramos un valor por defecto y este ya ha sido fijado por c\u00f3digo (en la siguiente secci\u00f3n veremos c\u00f3mo) el valor por defecto no \u201cmachacar\u00e1\u201d al ya fijado. Cuando iOS busca el valor para una preferencia sigue un esquema de \u201cdominios\u201d, en el que si no encuentra la clave en un dominio la busca en el siguiente. De este modo, primero busca en el dominio de los valores fijados por el usuario y si lo encuentra aqu\u00ed lo devuelve. Es solo si no lo encuentra aqu\u00ed cuando pasa a consultar los valores por defecto. En un poco tedioso tener que volcar en el c\u00f3digo un diccionario con todos los valores por defecto. Un m\u00e9todo muy habitual de registrar los valores por defecto de modo m\u00e1s \u201climpio\u201d es almacenarlos en un archivo .plist y deserializarlos con initWithContentsOfFile , como vimos en el apartado de c\u00f3mo leer property lists .","title":"Registrar valores por defecto"},{"location":"cap1/1.4_preferencias/#modificar-los-valores-de-las-preferencias","text":"Simplemente tenemos que fijar la clave al valor que queramos usando la familia de m\u00e9todos set(valor,forKey:) 1 2 3 let prefs = UserDefaults () prefs . set ( 5 , forKey : \"nivel\" ) prefs . set ( \"Pepito\" , forKey : \"nick\" ) Por cuestiones de eficiencia, iOS no hace persistente el cambio inmediatamente sino a intervalos regulares o en momentos especiales (por ejemplo justo antes de salir de la aplicaci\u00f3n). Una property list no se puede modificar de manera parcial y hay que crearla entera de nuevo, de manera que no ser\u00eda eficiente persistir siempre los datos tras ejecutar el set . Por c\u00f3digo podemos forzar el cambio en el .plist llamando al m\u00e9todo synchronize de las preferencias 1 UserDefaults (). synchronize () Otra forma de \"forzar\" la persistencia probando la aplicaci\u00f3n es salir de la misma pulsando en el bot\u00f3n \"home\" ( Shift+Cmd+H en el simulador) para que pase a background , momento en el que, como ya hemos dicho, iOS almacena de modo permanente los valores actuales. Como iOS tiene que modificar los datos si hay preferencias modificadas desde la \u00faltima vez que se guardaron, no es aconsejable cambiar el valor de una preferencia \u201ca las primeras de cambio\u201d. Solo es adecuado si no es previsible que vaya a cambiar dentro de poco tiempo. Una estrategia t\u00edpica es fijar los valores justo antes de salir de la aplicaci\u00f3n.","title":"Modificar los valores de las preferencias "},{"location":"cap1/1.4_preferencias/#material-complementario-ubicar-las-preferencias-en-el-panel-de-control-general","text":"Nota Este apartado no te servir\u00e1 para los ejercicios pero puedes echarle un vistazo para saber algo m\u00e1s del tema El sistema nos da la posibilidad de controlar ciertas preferencias de nuestra aplicaci\u00f3n dentro de las preferencias generales del sistema, en un apartado reservado a ella. Esto es lo que se conoce en iOS como un settings bundle . Podemos colocar aqu\u00ed todas las preferencias o solo algunas. Apple recomienda colocar en el sistema solo las preferencias que se cambien en raras ocasiones. Por ejemplo en una aplicaci\u00f3n que gestione un servicio de terceros podemos colocar aqu\u00ed las credenciales de uso del servicio (login y password) A diferencia de las preferencias dentro de la aplicaci\u00f3n, donde iOS nos da un API para editarlas/verlas pero no una interfaz esto es al contrario. En un fichero .plist con un formato especial podemos crear de modo sencillo una interfaz para las preferencias. Para crear un settings bundle en Xcode ir a File > New > File ... y en el cuadro de di\u00e1logo que aparecer\u00e1, dentro del tipo Resource elegir Settings Bundle . Se crear\u00e1 un archivo de tipo property list llamado Root.plist y algunos archivos auxiliares para la internacionalizaci\u00f3n (necesarios ya que vamos a tratar con elementos de interfaz). Si editamos el Root.plist con el editor de Xcode podemos ver que tiene un formato un tanto especial: la lista de preferencias se representa con un array de items. Las propiedades de estos items son las que determinan el tipo de widget a usar para editar/ver la preferencia, sus par\u00e1metros y la clave con la que se va a almacenar la preferencia asociada. En el ejemplo que se muestra a continuaci\u00f3n, que se corresponde con el Root.plist que crea por defecto Xcode, puede verse que el item 1 es de tipo \"campo de texto\", que su title (la etiqueta que se ve en las preferencias) es Name , que el widget tiene una serie de propiedades (cuando se edita aparece un teclado alfab\u00e9tico, no es seguro - o sea, se muestra el contenido, \u2026) y est\u00e1 asociada a la preferencia cuya clave es name_preference (propiedad Identifier ). No tenemos espacio en estos apuntes para explicar m\u00e1s detalladamente el proceso de configuraci\u00f3n del bundle . El lector interesado puede consultar el apartado \u201c implementing an iOS settings bundle \u201d de la \u201c Preferences and Settings Programming Guide \u201d de Apple.","title":"Material complementario: ubicar las preferencias en el \u201cpanel de control\u201d general"},{"location":"cap1/1.5_ejercicios/","text":"Leer primero Para hacer este ejercicio necesitar\u00e1s leerte primero al menos el apartado 1.4 de los apuntes, que habla de \"Preferencias de usuario\" Vamos a realizar una peque\u00f1a aplicaci\u00f3n en la que los datos se guarden usando algunos de los mecanismos vistos en la sesi\u00f3n. Desde el punto de vista del usuario consistir\u00e1 en una \u00fanica \"pantalla\" con un Text View para editar un mensaje y un Label que mostrar\u00e1 la fecha y hora de edici\u00f3n. Los datos deben conservarse aunque salgamos de la aplicaci\u00f3n. Llama al proyecto PersistenciaBasica . Interfaz gr\u00e1fico (0,25 puntos) \u00b6 Crea la interfaz: Inserta un Text View , un Label y un Button que ponga \"guardar\" en el storyboard En el ViewController Crea dos outlet para acceder al contenido de text view y label. Recuerda que tienes que hacer Ctrl+arrastrar . Cra un action que responda a pulsaciones sobre el bot\u00f3n \"guardar\" Crea una propiedad opcional llamada fechaEdicion de tipo Date , que representar\u00e1 la fecha y hora en que se haya editado el texto. Almacenamiento y recuperaci\u00f3n de datos (0,75 puntos) \u00b6 Fecha de edici\u00f3n \u00b6 Queremos que cuando se pulse el bot\u00f3n \"guardar\" (por tanto tendr\u00e1s que hacer esto en el action del bot\u00f3n): La fechaEdicion se ponga a la fecha y hora actuales 1 self . fechaEdicion = Date () La fecha se muestre en modo texto en el label . Como el formato por defecto es un poco engorroso, mejor la formatearemos nosotros 1 2 3 4 5 //SUPONEMOS que el outlet del label se llama \"fechaLabel\" //CAMBIALO por lo que sea necesario self . fechaLabel . text = DateFormatter . localizedString ( from : self . fechaEdicion !, dateStyle : . short , timeStyle : . medium ) Comprobar que lo anterior funciona correctamente , que al pulsar sobre el bot\u00f3n,se muestra la fecha y hora de edici\u00f3n en el label . Guardar los datos \u00b6 En el action del bot\u00f3n a\u00f1ade el c\u00f3digo Swift que necesites para almacenar el texto y la fecha como dos preferencias de usuario llamadas \"texto\" y \"fecha\" respectivamente (en la fecha guarda la propiedad de tipo Date , no la fecha convertida a texto, esa es solo para visualizaci\u00f3n). Tendr\u00e1s que mirar los apuntes para ver c\u00f3mo hacerlo (apartado \" Modificar los valores de las preferencias \") Recuperar los datos al cargar la aplicaci\u00f3n \u00b6 En el viewDidLoad del controller recupera las dos preferencias que guardaste y muestra su contenido en pantalla, a trav\u00e9s de los correspondientes outlets . Consulta el apartado \"Acceder a las preferencias\" . Para recuperar la fecha: Como no hay un m\u00e9todo espec\u00edfico para recuperar fechas, tendr\u00e1s que usar el de objetos: object(forKey:) de UserDefaults Para convertirlo de objeto en fecha tendr\u00e1s que hacer un cast a Date ( as! Date ). Para comprobar si las preferencias se guardan: En el simulador el sistema de carpetas y archivos de cada app se guarda en un directorio un poco \"perdido\" en el disco, un poco dif\u00edcil de localizar manualmente. Hay aplicaciones que nos permiten encontrarlo m\u00e1s f\u00e1cilmente para as\u00ed poder comprobar si nuestro c\u00f3digo est\u00e1 creando los archivos correctamente. Una de estas aplicaciones, de libre distribuci\u00f3n es SimSim . B\u00e1jatela, descompr\u00edmela y arrastra el .app a la carpeta de aplicaciones . Al arrancar crear\u00e1 un icono en la barra superior de men\u00fa del Mac donde podemos ver las apps que tenemos en el simulador y abrir la carpeta correspondiente con los datos en el Finder o en una terminal. Sal de la app como lo har\u00eda un usuario en el m\u00f3vil real (men\u00fa Device > Home del simulador). Ve a la aplicaci\u00f3n SimSim en el men\u00fa superior, selecciona la app PersistenciaBasica y luego selecciona Finder : se abrir\u00e1 una carpeta con el sistema de archivos de la app . Las preferencias se guardan en Library/Preferences . Deber\u00eda haber un fichero .plist . Si lo abres d\u00e1ndole doble clic deber\u00eda abrirse en Xcode y podr\u00e1s ver el contenido","title":"Ejercicios"},{"location":"cap1/1.5_ejercicios/#interfaz-grafico-025-puntos","text":"Crea la interfaz: Inserta un Text View , un Label y un Button que ponga \"guardar\" en el storyboard En el ViewController Crea dos outlet para acceder al contenido de text view y label. Recuerda que tienes que hacer Ctrl+arrastrar . Cra un action que responda a pulsaciones sobre el bot\u00f3n \"guardar\" Crea una propiedad opcional llamada fechaEdicion de tipo Date , que representar\u00e1 la fecha y hora en que se haya editado el texto.","title":"Interfaz gr\u00e1fico (0,25 puntos)"},{"location":"cap1/1.5_ejercicios/#almacenamiento-y-recuperacion-de-datos-075-puntos","text":"","title":"Almacenamiento y recuperaci\u00f3n de datos (0,75 puntos)"},{"location":"cap1/1.5_ejercicios/#fecha-de-edicion","text":"Queremos que cuando se pulse el bot\u00f3n \"guardar\" (por tanto tendr\u00e1s que hacer esto en el action del bot\u00f3n): La fechaEdicion se ponga a la fecha y hora actuales 1 self . fechaEdicion = Date () La fecha se muestre en modo texto en el label . Como el formato por defecto es un poco engorroso, mejor la formatearemos nosotros 1 2 3 4 5 //SUPONEMOS que el outlet del label se llama \"fechaLabel\" //CAMBIALO por lo que sea necesario self . fechaLabel . text = DateFormatter . localizedString ( from : self . fechaEdicion !, dateStyle : . short , timeStyle : . medium ) Comprobar que lo anterior funciona correctamente , que al pulsar sobre el bot\u00f3n,se muestra la fecha y hora de edici\u00f3n en el label .","title":"Fecha de edici\u00f3n"},{"location":"cap1/1.5_ejercicios/#guardar-los-datos","text":"En el action del bot\u00f3n a\u00f1ade el c\u00f3digo Swift que necesites para almacenar el texto y la fecha como dos preferencias de usuario llamadas \"texto\" y \"fecha\" respectivamente (en la fecha guarda la propiedad de tipo Date , no la fecha convertida a texto, esa es solo para visualizaci\u00f3n). Tendr\u00e1s que mirar los apuntes para ver c\u00f3mo hacerlo (apartado \" Modificar los valores de las preferencias \")","title":"Guardar los datos"},{"location":"cap1/1.5_ejercicios/#recuperar-los-datos-al-cargar-la-aplicacion","text":"En el viewDidLoad del controller recupera las dos preferencias que guardaste y muestra su contenido en pantalla, a trav\u00e9s de los correspondientes outlets . Consulta el apartado \"Acceder a las preferencias\" . Para recuperar la fecha: Como no hay un m\u00e9todo espec\u00edfico para recuperar fechas, tendr\u00e1s que usar el de objetos: object(forKey:) de UserDefaults Para convertirlo de objeto en fecha tendr\u00e1s que hacer un cast a Date ( as! Date ). Para comprobar si las preferencias se guardan: En el simulador el sistema de carpetas y archivos de cada app se guarda en un directorio un poco \"perdido\" en el disco, un poco dif\u00edcil de localizar manualmente. Hay aplicaciones que nos permiten encontrarlo m\u00e1s f\u00e1cilmente para as\u00ed poder comprobar si nuestro c\u00f3digo est\u00e1 creando los archivos correctamente. Una de estas aplicaciones, de libre distribuci\u00f3n es SimSim . B\u00e1jatela, descompr\u00edmela y arrastra el .app a la carpeta de aplicaciones . Al arrancar crear\u00e1 un icono en la barra superior de men\u00fa del Mac donde podemos ver las apps que tenemos en el simulador y abrir la carpeta correspondiente con los datos en el Finder o en una terminal. Sal de la app como lo har\u00eda un usuario en el m\u00f3vil real (men\u00fa Device > Home del simulador). Ve a la aplicaci\u00f3n SimSim en el men\u00fa superior, selecciona la app PersistenciaBasica y luego selecciona Finder : se abrir\u00e1 una carpeta con el sistema de archivos de la app . Las preferencias se guardan en Library/Preferences . Deber\u00eda haber un fichero .plist . Si lo abres d\u00e1ndole doble clic deber\u00eda abrirse en Xcode y podr\u00e1s ver el contenido","title":"Recuperar los datos al cargar la aplicaci\u00f3n"},{"location":"cap1/intro/","text":"Persistencia b\u00e1sica en iOS \u00b6 En este tema veremos APIs b\u00e1sicos para poder almacenar estructuras de datos relativamente sencillas. Si la cantidad de informaci\u00f3n que necesitamos almacenar no es demasiado amplia ni tampoco tenemos que hacer consultas o b\u00fasquedas podemos usar APIs de iOS bastante simples (al menos comparados con los que se usan para acceder a bases de datos). El caso m\u00e1s t\u00edpico es cuando necesitamos almacenar un conjunto de pares \"clave/valor\", para los que podemos usar property lists o bien el sistema de preferencias de iOS. Este es el mecanismo habitual para guardar las preferencias de una aplicaci\u00f3n (colores, tipos de letra, datos b\u00e1sicos del usuario,...). Si necesitamos almacenar objetos de clases propias cualesquiera podemos archivarlas , que ser\u00eda lo que en otros lenguajes se denomina serializar . Acabaremos el cap\u00edtulo viendo c\u00f3mo se pueden archivar objetos en iOS.","title":"Persistencia b\u00e1sica en iOS"},{"location":"cap1/intro/#persistencia-basica-en-ios","text":"En este tema veremos APIs b\u00e1sicos para poder almacenar estructuras de datos relativamente sencillas. Si la cantidad de informaci\u00f3n que necesitamos almacenar no es demasiado amplia ni tampoco tenemos que hacer consultas o b\u00fasquedas podemos usar APIs de iOS bastante simples (al menos comparados con los que se usan para acceder a bases de datos). El caso m\u00e1s t\u00edpico es cuando necesitamos almacenar un conjunto de pares \"clave/valor\", para los que podemos usar property lists o bien el sistema de preferencias de iOS. Este es el mecanismo habitual para guardar las preferencias de una aplicaci\u00f3n (colores, tipos de letra, datos b\u00e1sicos del usuario,...). Si necesitamos almacenar objetos de clases propias cualesquiera podemos archivarlas , que ser\u00eda lo que en otros lenguajes se denomina serializar . Acabaremos el cap\u00edtulo viendo c\u00f3mo se pueden archivar objetos en iOS.","title":"Persistencia b\u00e1sica en iOS"},{"location":"cap10/1_intro_arquitecturas/","text":"","title":"1 intro arquitecturas"},{"location":"cap10/2_MVC/","text":"Modelo/Vista/Controlador \u00b6 Los problemas de MVC \u00b6 En teor\u00eda la estructura de una aplicaci\u00f3n iOS con MVC deber\u00eda ser sencilla y \"limpia\", ya que cada uno de los tres componentes tiene una responsabilidad separada. En la pr\u00e1ctica, la principal fuente de problemas de esta arquitectura es el controlador . Por un lado, el UIViewController est\u00e1 tan unido a la vista que acaba siendo parte de ella en lugar de un componente separado. En la realidad la arquitectura de muchas aplicaciones iOS acaba pareci\u00e9ndose m\u00e1s a la siguiente figura que a la anterior: Al estar tan acoplado el controlador a la vista se hace casi imposible hacer testing del controlador en s\u00ed, sin probar la interfaz de usuario, ya que tendr\u00edamos que hacer un mock de todos los componentes de la vista que interact\u00faan con el controlador. Por otro lado es f\u00e1cil \"dejarse llevar\" y acabar asign\u00e1ndole demasiadas responsabilidades al controlador: colocar en \u00e9l l\u00f3gica de negocio, hacer que sea el datasource o el delegate de las tablas que contiene,... Esto da lugar a lo que de modo ir\u00f3nico se conoce como massive view controller . Casi todos los tutoriales y ejemplos sobre frameworks o APIs de iOS que encontrar\u00e9is en la web o en los libros tienen este problema, incluyendo muchas veces el material que os damos en este curso. Como el objetivo del tutorial o del ejemplo es aprender sobre el framework /API que no conoces, se tiende a poner todo el c\u00f3digo en el view controller , evitando crear clases adicionales que a\u00f1adir\u00edan complejidad al ejemplo y distraer\u00edan del objetivo principal. Pero por desgracia el resultado final es un Massive View Controller . Para solucionar todos estos problemas podemos usar una arquitectura distinta a MVC, como veremos en apartados posteriores. Pero no todo son problemas en MVC tal como lo propone Apple: tiene la ventaja de estar especialmente adaptado a la filosof\u00eda de la plataforma, los frameworks y los APIs de iOS, y adem\u00e1s es una arquitectura sencilla. Una alternativa ser\u00eda continuar us\u00e1ndolo pero intentar \"aligerar\" el controlador en la medida de lo posible para hacer el c\u00f3digo m\u00e1s mantenible. Vamos a ver c\u00f3mo podr\u00edamos hacerlo. Controladores \"ligeros\" \u00b6 B\u00e1sicamente la idea es dejar en el controlador el m\u00ednimo de c\u00f3digo imprescindible para coordinarse con el modelo y con la vista, que es la que deber\u00eda ser su \u00fanica labor. Esto no es m\u00e1s que una aplicaci\u00f3n del \"Principio de responsabilidad \u00fanica\" (Single Responsibility Principe), un principio b\u00e1sico en el dise\u00f1o y desarrollo de software que sostiene que cada componente deber\u00eda tener una \u00fanica responsabilidad o funcionalidad en el sistema . Esto no solo mejora la estructura del c\u00f3digo, sino que tambi\u00e9n facilita el testing y mejora la mantenibilidad de la aplicaci\u00f3n. Si \"nos dejamos llevar\" y colocamos todo el c\u00f3digo de la aplicaci\u00f3n en el view controller , al final puede acabar teniendo las siguientes responsabilidades: Almacenar temporalmente y modificar los datos de la aplicaci\u00f3n Implementar al menos parte de la l\u00f3gica de negocio, que deber\u00eda estar \u00fanicamente en las clases del modelo Implementar la persistencia de datos. Si adem\u00e1s usamos Core Data y necesitamos listar datos con un fetched results controller , el view controller acaba teniendo que convertirse en su delegate . En caso de tener una tabla: T\u00edpicamente es datasource y delegate de la misma Al ser el datasource , se tiene que encargar de rellenar todos los datos de cada celda, por lo que tiene que conocer su estructura El view controller acaba convirti\u00e9ndose la mayor\u00eda de veces en el delegate de los componentes de interfaz que requieren uno, por ejemplo los sliders o los datepickers . Muchas veces cuando de un view controller se salta a otro este le pasa los datos fijando propiedades en el view controller destino. Eso implica un conocimiento de la estructura interna de este controller . B\u00e1sicamente la soluci\u00f3n es relativamente de \"sentido com\u00fan\" y consiste en extraer todas estas funcionalidades a clases/ structs adicionales. Vamos a ver algunas ideas gen\u00e9ricas de c\u00f3mo se podr\u00edan hacer estas refactorizaciones. Separaci\u00f3n de los datasources / delegates Vamos a ver c\u00f3mo se podr\u00eda extraer el datasource de una tabla. Un delegate ser\u00eda similar. Intentaremos hacer una clase gen\u00e9rica que nos pueda servir en varios proyectos. Dicha clase: Por supuesto implementa los m\u00e9todos del protocolo UITableViewDataSource Contiene un array con los objetos a mostrar, ya que es la forma m\u00e1s sencilla de representar los datos. Acepta en el constructor una clausura que se encarga de rellenar los campos de una celda a partir de un objeto 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import Foundation import UIKit class ListaItemsDataSource < Item > : NSObject , UITableViewDataSource { private var items : [ Item ] private var idCelda : String private var configurarCelda : ( UITableViewCell , Item ) -> Void init ( listaItems : [ Item ], idCelda : String , configurarCelda : @ escaping ( UITableViewCell , Item ) -> Void ) { self . items = listaItems self . idCelda = idCelda self . configurarCelda = configurarCelda } func tableView ( _ tableView : UITableView , numberOfRowsInSection section : Int ) -> Int { return items . count } func tableView ( _ tableView : UITableView , cellForRowAt indexPath : IndexPath ) -> UITableViewCell { let cell = tableView . dequeueReusableCell ( withIdentifier : self . idCelda , for : indexPath ) self . configurarCelda ( cell , self . items [ indexPath . row ]) return cell } } Y aqu\u00ed tenemos un view controller de ejemplo que hace uso de esta clase. Por ejemplo supongamos que queremos mostrar una lista de objetos Persona 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class MiController : UIViewController { var miDataSource : ListaItemsDataSource < Usuario > ! override func viewDidLoad () { super . viewDidLoad () //Tendr\u00edamos que obtener los datos de alg\u00fan sitio, p.ej. de Core Data let lista = ... self . miDataSource = ListaItemsDataSource < Usuario >( listaItems : lista , idCelda : \"MiCelda\" ) { celda , persona in celda . textLabel ?. text = persona . nombre let df = DateFormatter () df . dateFormat = \"dd/MM/yyyy\" let fechaString = df . string ( from : persona . fechaNacimiento ) celda . detailTextLabel ?. text = fechaString } self . tableView . dataSource = self . miDataSource } } Extraer el c\u00f3digo de configuraci\u00f3n de la celda En el c\u00f3digo anterior el View Controller sigue teniendo que ocuparse de rellenar los campos de la celda, lo que hace que tenga que conocer su estructura: en el ejemplo, que la celda tiene un textLabel y un detailTextLabel y tambi\u00e9n que tenga que ocuparse de formatear los datos, por ejemplo la fecha. Podemos encapsular la informaci\u00f3n sobre la \"estructura interna\" de la celda en una nueva clase, que en MVC pertenecer\u00eda a la vista. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class CeldaPersona : UITableViewCell { static let idCelda = \"MiCelda\" var nombre : String ? { didSet { self . textLabel ?. text = self . nombre } } var fecha : Date ? { didSet { let df = DateFormatter () df . dateStyle = . short self . detailTextLabel ?. text = df . string ( from : self . fecha !) } } } N\u00f3tese que ahora \"desde fuera\" para configurar la celda lo \u00fanico que hay que hacer es fijar el valor de las propiedades \"texto\" y \"fecha\". Los didSet se encargar\u00e1n autom\u00e1ticamente de rellenar los campos de la celda con el formato adecuado. De este modo el view controller quedar\u00eda a\u00fan m\u00e1s sencillo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class MiController : UIViewController { var miDataSource : ListaItemsDataSource < Usuario > ! override func viewDidLoad () { super . viewDidLoad () //Tendr\u00edamos que obtener los datos de alg\u00fan sitio, p.ej. de Core Data let lista = ... self . miDataSource = ListaItemsDataSource < Usuario >( listaItems : lista , idCelda : \"MiCelda\" ) { celda , persona in if let celdaPersona = celda as ? CeldaPersona { celdaPersona . nombre = persona . nombre celdaPersona . fecha = persona . fechaNacimiento } } self . tableView . dataSource = self . miDataSource } } Para que el cast de celda as CeldaPersona pueda tener \u00e9xito, en Xcode habr\u00e1 que seleccionar la celda prototipo en el storyboard y cambiar en el \"identity inspector\" del panel derecho la clase de la celda por CeldaPersona .","title":"2 MVC"},{"location":"cap10/2_MVC/#modelovistacontrolador","text":"","title":"Modelo/Vista/Controlador"},{"location":"cap10/2_MVC/#los-problemas-de-mvc","text":"En teor\u00eda la estructura de una aplicaci\u00f3n iOS con MVC deber\u00eda ser sencilla y \"limpia\", ya que cada uno de los tres componentes tiene una responsabilidad separada. En la pr\u00e1ctica, la principal fuente de problemas de esta arquitectura es el controlador . Por un lado, el UIViewController est\u00e1 tan unido a la vista que acaba siendo parte de ella en lugar de un componente separado. En la realidad la arquitectura de muchas aplicaciones iOS acaba pareci\u00e9ndose m\u00e1s a la siguiente figura que a la anterior: Al estar tan acoplado el controlador a la vista se hace casi imposible hacer testing del controlador en s\u00ed, sin probar la interfaz de usuario, ya que tendr\u00edamos que hacer un mock de todos los componentes de la vista que interact\u00faan con el controlador. Por otro lado es f\u00e1cil \"dejarse llevar\" y acabar asign\u00e1ndole demasiadas responsabilidades al controlador: colocar en \u00e9l l\u00f3gica de negocio, hacer que sea el datasource o el delegate de las tablas que contiene,... Esto da lugar a lo que de modo ir\u00f3nico se conoce como massive view controller . Casi todos los tutoriales y ejemplos sobre frameworks o APIs de iOS que encontrar\u00e9is en la web o en los libros tienen este problema, incluyendo muchas veces el material que os damos en este curso. Como el objetivo del tutorial o del ejemplo es aprender sobre el framework /API que no conoces, se tiende a poner todo el c\u00f3digo en el view controller , evitando crear clases adicionales que a\u00f1adir\u00edan complejidad al ejemplo y distraer\u00edan del objetivo principal. Pero por desgracia el resultado final es un Massive View Controller . Para solucionar todos estos problemas podemos usar una arquitectura distinta a MVC, como veremos en apartados posteriores. Pero no todo son problemas en MVC tal como lo propone Apple: tiene la ventaja de estar especialmente adaptado a la filosof\u00eda de la plataforma, los frameworks y los APIs de iOS, y adem\u00e1s es una arquitectura sencilla. Una alternativa ser\u00eda continuar us\u00e1ndolo pero intentar \"aligerar\" el controlador en la medida de lo posible para hacer el c\u00f3digo m\u00e1s mantenible. Vamos a ver c\u00f3mo podr\u00edamos hacerlo.","title":"Los problemas de MVC"},{"location":"cap10/2_MVC/#controladores-ligeros","text":"B\u00e1sicamente la idea es dejar en el controlador el m\u00ednimo de c\u00f3digo imprescindible para coordinarse con el modelo y con la vista, que es la que deber\u00eda ser su \u00fanica labor. Esto no es m\u00e1s que una aplicaci\u00f3n del \"Principio de responsabilidad \u00fanica\" (Single Responsibility Principe), un principio b\u00e1sico en el dise\u00f1o y desarrollo de software que sostiene que cada componente deber\u00eda tener una \u00fanica responsabilidad o funcionalidad en el sistema . Esto no solo mejora la estructura del c\u00f3digo, sino que tambi\u00e9n facilita el testing y mejora la mantenibilidad de la aplicaci\u00f3n. Si \"nos dejamos llevar\" y colocamos todo el c\u00f3digo de la aplicaci\u00f3n en el view controller , al final puede acabar teniendo las siguientes responsabilidades: Almacenar temporalmente y modificar los datos de la aplicaci\u00f3n Implementar al menos parte de la l\u00f3gica de negocio, que deber\u00eda estar \u00fanicamente en las clases del modelo Implementar la persistencia de datos. Si adem\u00e1s usamos Core Data y necesitamos listar datos con un fetched results controller , el view controller acaba teniendo que convertirse en su delegate . En caso de tener una tabla: T\u00edpicamente es datasource y delegate de la misma Al ser el datasource , se tiene que encargar de rellenar todos los datos de cada celda, por lo que tiene que conocer su estructura El view controller acaba convirti\u00e9ndose la mayor\u00eda de veces en el delegate de los componentes de interfaz que requieren uno, por ejemplo los sliders o los datepickers . Muchas veces cuando de un view controller se salta a otro este le pasa los datos fijando propiedades en el view controller destino. Eso implica un conocimiento de la estructura interna de este controller . B\u00e1sicamente la soluci\u00f3n es relativamente de \"sentido com\u00fan\" y consiste en extraer todas estas funcionalidades a clases/ structs adicionales. Vamos a ver algunas ideas gen\u00e9ricas de c\u00f3mo se podr\u00edan hacer estas refactorizaciones.","title":"Controladores \"ligeros\""},{"location":"cap10/3_MVP/","text":"Model/View/Presenter \u00b6 Este patr\u00f3n de dise\u00f1o soluciona algunos de los problemas que tiene el MVC \"al estilo Apple\". El nuevo componente, llamado presenter se encarga de la l\u00f3gica de presentaci\u00f3n , y debe ser independiente de la tecnolog\u00eda que se est\u00e9 usando para la vista, que en iOS ser\u00e1 UIKit . La l\u00f3gica de presentaci\u00f3n engloba todas las operaciones necesarias para formatear los datos del modelo de modo que se puedan visualizar adecuadamente. Por ejemplo es posible que el modelo nos devuelva la distancia total de una ruta, y queramos que se pueda visualizar en metros o kil\u00f3metros. La conversi\u00f3n de unidades ser\u00eda responsabilidad del presenter . A primera vista el diagrama de componentes anterior parece muy similar al original de MVC, simplemente sustituyendo el controller por el presenter . No obstante, el que el presenter deba ser independiente de la tecnolog\u00eda de la vista tiene un impacto bastante importante en el c\u00f3digo. En las aplicaciones debemos seguir usando UIViewControllers , ya que son una parte b\u00e1sica de la plataforma. Sin embargo esta clase no es totalmente independiente de la tecnolog\u00eda de la vista, porque est\u00e1 \u00edntimamente unida a ella. De hecho, esto era uno de los problemas que ten\u00edamos en el MVC \"estilo Apple\". Por eso, en MVP consideraremos al view controller como parte de la vista . Es decir, el presenter de ning\u00fan modo es el antiguo controller bajo otro nombre, sino algo totalmente distinto. Vamos a verlo a trav\u00e9s de un ejemplo. Usaremos la aplicaci\u00f3n UAdivino , que fue nuestra primera aplicaci\u00f3n iOS en Swift. Recordemos que se trata de una app a la que se le \"formula una pregunta\" ( \u00bfAprender\u00e9 Swift? ) y nos da una contestaci\u00f3n positiva o negativa ( claro que s\u00ed , o ni de casualidad ). Vamos a hacer que si la contestaci\u00f3n es positiva se muestre en color verde y si es negativa en color rojo. Lo primero que vamos a hacer es formalizar la interfaz de los tres componentes, modelo, vista y presentador, usando protocolos. El diagrama de componentes quedar\u00eda del siguiente modo: Cuando se pulsa el bot\u00f3n de \"obtener respuesta\" la vista llama a solicitarRespuesta() del presentador . Este a su vez le pide al modelo que \"haga el trabajo\", generando una respuesta al azar. La respuesta contiene un texto y un booleano indicando si es positiva o negativa. Con este \u00faltimo el presentador calcula el color (verde o rojo, respectivamente), y le pasa texto y color a la vista para que lo muestre. En este caso la \"l\u00f3gica de presentaci\u00f3n\" consiste simplemente en calcular el color correspondiente a la respuesta. Al ser este un ejemplo muy sencillo el modelo no necesita notificaciones para \"avisar\" al presentador de que hay datos que mostrar. Una aplicaci\u00f3n que hiciera una b\u00fasqueda en un servicio web llamar\u00eda a un callback del presenter cuando se hubieran recibido los datos. Pod\u00e9is ver el c\u00f3digo fuente completo en el repositorio de GitHub. Ensamblado de la arquitectura \u00b6 vista y presentador deben comunicar el uno con el otro, as\u00ed que cada uno debe tener una referencia al otro.","title":"3 MVP"},{"location":"cap10/3_MVP/#modelviewpresenter","text":"Este patr\u00f3n de dise\u00f1o soluciona algunos de los problemas que tiene el MVC \"al estilo Apple\". El nuevo componente, llamado presenter se encarga de la l\u00f3gica de presentaci\u00f3n , y debe ser independiente de la tecnolog\u00eda que se est\u00e9 usando para la vista, que en iOS ser\u00e1 UIKit . La l\u00f3gica de presentaci\u00f3n engloba todas las operaciones necesarias para formatear los datos del modelo de modo que se puedan visualizar adecuadamente. Por ejemplo es posible que el modelo nos devuelva la distancia total de una ruta, y queramos que se pueda visualizar en metros o kil\u00f3metros. La conversi\u00f3n de unidades ser\u00eda responsabilidad del presenter . A primera vista el diagrama de componentes anterior parece muy similar al original de MVC, simplemente sustituyendo el controller por el presenter . No obstante, el que el presenter deba ser independiente de la tecnolog\u00eda de la vista tiene un impacto bastante importante en el c\u00f3digo. En las aplicaciones debemos seguir usando UIViewControllers , ya que son una parte b\u00e1sica de la plataforma. Sin embargo esta clase no es totalmente independiente de la tecnolog\u00eda de la vista, porque est\u00e1 \u00edntimamente unida a ella. De hecho, esto era uno de los problemas que ten\u00edamos en el MVC \"estilo Apple\". Por eso, en MVP consideraremos al view controller como parte de la vista . Es decir, el presenter de ning\u00fan modo es el antiguo controller bajo otro nombre, sino algo totalmente distinto. Vamos a verlo a trav\u00e9s de un ejemplo. Usaremos la aplicaci\u00f3n UAdivino , que fue nuestra primera aplicaci\u00f3n iOS en Swift. Recordemos que se trata de una app a la que se le \"formula una pregunta\" ( \u00bfAprender\u00e9 Swift? ) y nos da una contestaci\u00f3n positiva o negativa ( claro que s\u00ed , o ni de casualidad ). Vamos a hacer que si la contestaci\u00f3n es positiva se muestre en color verde y si es negativa en color rojo. Lo primero que vamos a hacer es formalizar la interfaz de los tres componentes, modelo, vista y presentador, usando protocolos. El diagrama de componentes quedar\u00eda del siguiente modo: Cuando se pulsa el bot\u00f3n de \"obtener respuesta\" la vista llama a solicitarRespuesta() del presentador . Este a su vez le pide al modelo que \"haga el trabajo\", generando una respuesta al azar. La respuesta contiene un texto y un booleano indicando si es positiva o negativa. Con este \u00faltimo el presentador calcula el color (verde o rojo, respectivamente), y le pasa texto y color a la vista para que lo muestre. En este caso la \"l\u00f3gica de presentaci\u00f3n\" consiste simplemente en calcular el color correspondiente a la respuesta. Al ser este un ejemplo muy sencillo el modelo no necesita notificaciones para \"avisar\" al presentador de que hay datos que mostrar. Una aplicaci\u00f3n que hiciera una b\u00fasqueda en un servicio web llamar\u00eda a un callback del presenter cuando se hubieran recibido los datos. Pod\u00e9is ver el c\u00f3digo fuente completo en el repositorio de GitHub.","title":"Model/View/Presenter"},{"location":"cap10/3_MVP/#ensamblado-de-la-arquitectura","text":"vista y presentador deben comunicar el uno con el otro, as\u00ed que cada uno debe tener una referencia al otro.","title":"Ensamblado de la arquitectura"},{"location":"cap10/4_MVVM/","text":"MVVM \u00b6 MVVM vs. MVP \u00b6 El patr\u00f3n de dise\u00f1o Model/View/ViewModel es muy similar al MVP que vimos en el apartado anterior. De hecho, el ViewModel tiene m\u00e1s o menos la misma funcionalidad que el presenter , implementar la l\u00f3gica de presentaci\u00f3n y aislarla de la tecnolog\u00eda concreta usada para la presentaci\u00f3n. \u00bfD\u00f3nde est\u00e1 la diferencia entonces?. En que MVVM soluciona uno de los principales problemas que tiene MVP, el acoplamiento entre vista y presenter . Como estuvimos discutiendo, la vista y el presenter deben \"conocerse\" mutuamente, ya que la vista debe comunicarle a este las acciones del usuario, y el presenter enviarle a la vista los datos a mostrar. Esto hace que ambos componentes est\u00e9n acoplados entre s\u00ed, ya hemos visto en el c\u00f3digo de ejemplo de MVP que en la vista hay una referencia al presenter y viceversa. En MVVM no existe este acoplamiento, y lo vamos a evitar usando bindings , es decir, vinculaci\u00f3n autom\u00e1tica entre los datos de la modelo y el presenter , de manera que cuando cambie alguno de ellos se modifique autom\u00e1ticamente el otro. Esto permite que el c\u00f3digo quede mucho m\u00e1s \"limpio\", ya que no hay que actualizar el otro componente de modo expl\u00edcito. En iOS no hay ninguna tecnolog\u00eda est\u00e1ndar para vincular elementos de la vista con propiedades del modelo (aunque en OSX s\u00ed existe). Podr\u00edamos usar KVO o notificaciones para hacer la vinculaci\u00f3n, pero la implementaci\u00f3n ser\u00eda un poco tediosa. As\u00ed que tendremos que usar alguna librer\u00eda de terceros. Aqu\u00ed veremos una bastante sencilla de usar llamada Bond (el nombre completo es Bond, Swift Bond :)). Para implementar los bindings podr\u00edamos usar tambi\u00e9n alg\u00fan framework de reactive programming . Este paradigma de programaci\u00f3n permite implementar la funcionalidad de manera bastante elegante. No obstante usar un framework de este tipo solo para implementar bindings probablemente sea demasiado, ya que la idea de reactive programming es bastante m\u00e1s amplia. En cualquier caso es posible que encontr\u00e9is tutoriales y otros recursos de MVVM en iOS que usen frameworks reactivos como ReactiveCocoa o RXSwift . De hecho, Bond est\u00e1 construido sobre un framework de este tipo, aunque m\u00e1s sencillo. Y como se ver\u00e1, en el ejemplo usaremos funcionalidades t\u00edpicas de programaci\u00f3n reactiva . MVVM con la librer\u00eda \"Bond\" \u00b6 Vamos a verlo con un ejemplo, ya que as\u00ed se entender\u00e1n mejor los conceptos. Implementaremos ahora una versi\u00f3n MVVM de la aplicaci\u00f3n UAdivino , al estilo de la que hicimos en el apartado anterior, es decir, mostrando cada tipo de respuesta de un color distinto. La diferencia fundamental va a estar en que vincularemos de modo autom\u00e1tico tanto el texto de la respuesta como el color para que no haga falta fijarlos de forma expl\u00edcita en la vista. Esta vinculaci\u00f3n la haremos gracias a la librer\u00eda Bond. La forma m\u00e1s sencilla de configurar un proyecto de Xcode con Bond es usando Cocoapods. En el README de Bond en Github est\u00e1n las instrucciones . Vamos a empezar a trabajar suponiendo que ya se ha hecho esta configuraci\u00f3n. Como en el caso de la versi\u00f3n MVP pod\u00e9is consultar el c\u00f3digo fuente completo en GitHub. Vinculaci\u00f3n de viewmodel a vista Al vincular un origen con un destino lo que hacemos es que cuando el primero cambia, el segundo tambi\u00e9n lo hace autom\u00e1ticamente. Esto simplifica mucho el c\u00f3digo ya que podemos cambiar una propiedad del viewmodel y que se refleje autom\u00e1ticamente en la vista, o viceversa. En nuestro ejemplo del UAdivino queremos vincular dos propiedades del viewmodel con la vista: el texto de la respuesta y el color de la misma. En la librer\u00eda Bond los bindings se basan en la idea de observable . Esta es una idea similar a la de los eventos. Podemos indicar que queremos observar un elemento observable de modo que se nos \"avisar\u00e1\" de cu\u00e1ndo cambia su valor. No obstante a diferencia de los eventos, que ya suelen estar predefinidos en el sistema, podemos crear los observables \"bajo demanda\" y adem\u00e1s como veremos se pueden manipular, transformar y combinar permiti\u00e9ndonos hacer cosas complejas de modo relativamente sencillo. La idea de observable es la idea fundamental tras el paradigma de programaci\u00f3n reactiva , aunque en este paradigma suele recibir otros nombres, siendo el m\u00e1s t\u00edpico el de stream (en librer\u00edas como ReactiveCocoa se denominan signals ). As\u00ed, definiremos el texto de la respuesta como un observable \"de tipo\" String en lugar de simplemente como un String , para poder vincularlo a la vista. En el viewmodel har\u00edamos esto para crear el observable con un valor inicial de \"\" (cadena vac\u00eda): 1 2 3 import Bond let textoResp = Observable < String >( \"\" ) N\u00f3tese que textoResp no es un String sino un observable . El valor que hay \"dentro\" del observable es accesible a trav\u00e9s de su propiedad value 1 2 print ( textoResp . value ) //imprimir\u00e1 la cadena vac\u00eda textoResp . value = \"hola\" Para vincular una propiedad de un elemento de UIKit con un observable usamos el m\u00e9todo bind(to:) . La librer\u00eda Bond extiende los elementos de interfaz a\u00f1adi\u00e9ndoles una propiedad reactive . Dentro de esta es donde est\u00e1n las propiedades \"vinculables\". Por ejemplo el texto de un campo estar\u00eda en reactive.text , el color en reactive.textColor , etc. Supongamos que en la vista tenemos el viewmodel accesible en la propiedad viewModel (como veremos en el apartado siguiente). Entonces har\u00edamos algo como: 1 self . viewModel . textoResp . bind ( to : self . labelRespuesta . reactive . text ) para vincular el observable textoResp del viewmodel al texto de la etiqueta labelRespuesta . A partir de este momento cada vez que el viewmodel cambie el valor del observable se cambiar\u00e1 tambi\u00e9n el mensaje en la pantalla. Vamos a ver ahora la vinculaci\u00f3n entre el color de la respuesta y el que se muestra en pantalla. El viewmodel usa un tipo propio enumerado, ColorRespuesta para representar el color con que se deber\u00eda mostrar la resupesta. Por tanto en el viewmodel crearemos un observable de este tipo con un valor inicial cualquiera. 1 let colorResp = Observable < ColorRespuesta >(. verde ) En iOS lo m\u00e1s sencillo para representar colores es usar la clase UIColor , pero recordemos que el viewmodel no deber\u00eda contener c\u00f3digo de UIKit , por eso usamos el tipo propio ColorRespuesta . Ahora el problema es que no podemos vincular directamente el color del label con este observable, ya que el color de los elementos de la interfaz es un UIColor y nosotros tenemos un tipo distinto. Sin embargo una idea bastante poderosa de los observables es que se pueden transformar y adem\u00e1s de modo encadenado. Para ello se pueden usar las primitivas t\u00edpicas de programaci\u00f3n funcional ( map , filter ,...) y adem\u00e1s algunas adicionales, dando lugar a lo que se conoce como FRP ( Functional Reactive Programming ). Por tanto lo que haremos ser\u00e1 transformar el observable en un UIColor y vincular con este (ya que la transformaci\u00f3n de un observable es tambi\u00e9n un observable, lo que nos permite encadenar operaciones). En la vista har\u00edamos algo como: 1 2 3 4 5 6 viewModel . colorResp . map { color in return ( color == . verde ? UIColor . green : UIColor . red ) } . bind ( to : self . labelRespuesta . reactive . textColor ) Recordemos que map parte de un valor y devuelve el valor transformado gracias a la clausura que se le pasa como par\u00e1metro. Vinculaci\u00f3n de vista a viewmodel En el ejemplo de UAdivino no hay ning\u00fan caso de uso de vinculaci\u00f3n en la direcci\u00f3n contraria, es decir, de la vista hacia el viewmodel , as\u00ed que pondremos otro ejemplo. Supongamos un campo de texto en que el usuario escribe un texto de b\u00fasqueda. En la vista tendremos definido un outlet que referencie el campo de texto. Vincularemos desde la propiedad reactive.text del campo hacia la propiedad correspondiente del viewmodel . Pero cuidado, el destino no puede ser un tipo \"normal\" de Swift sino que debe ser un Observable En el viewmodel 1 var textoBusqueda = Observable < String >( \"\" ) En la vista, suponiendo que el viewmodel es accesible a trav\u00e9s de la propiedad viewModel : 1 self . campoTexto . reactive . text . bind ( to : viewModel . textoBusqueda ) Podemos establecer tambi\u00e9n una vinculaci\u00f3n bidireccional de modo que cuando cambie cualquiera de los dos lados cambie el otro (de la propiedad a la vista y viceversa). Esto lo har\u00edamos simplemente usando bidirectionalBind en lugar de bind 1 self . campoTexto . reactive . text . bidirectionalBind ( to : viewModel . textoBusqueda ) \"Ensamblaje\" de modelo, viewmodel y vista Al igual que en el caso de MVP, hay que conectar las \"piezas\": modelo, viewmodel y vista. Como seg\u00fan el esquema del patr\u00f3n la vista \"posee\" al viewmodel , definiremos este como una propiedad de la vista: 1 2 3 4 class UAdivinoView : UIViewController { let viewModel = UAdivinoViewModel () ... } Y como el viewmodel \"posee\" al modelo definiremos este como una propiedad del primero: 1 2 3 4 class UAdivinoViewModel { let model = UAdivinoModel ( nombre : \"Rappel\" ) ... } En MVVM, una parte importante del ensamblaje es inicializar los *bindings *. Una forma sencilla de hacer esto es en el viewDidLoad de la vista: 1 2 3 4 5 6 7 8 9 override func viewDidLoad () { self . bindViewModel () } func bindViewModel () { //conectamos viewModel.textoResp -> texto del label viewModel . textoResp . bind ( to : self . labelRespuesta . reactive . text ) ... }","title":"4 MVVM"},{"location":"cap10/4_MVVM/#mvvm","text":"","title":"MVVM"},{"location":"cap10/4_MVVM/#mvvm-vs-mvp","text":"El patr\u00f3n de dise\u00f1o Model/View/ViewModel es muy similar al MVP que vimos en el apartado anterior. De hecho, el ViewModel tiene m\u00e1s o menos la misma funcionalidad que el presenter , implementar la l\u00f3gica de presentaci\u00f3n y aislarla de la tecnolog\u00eda concreta usada para la presentaci\u00f3n. \u00bfD\u00f3nde est\u00e1 la diferencia entonces?. En que MVVM soluciona uno de los principales problemas que tiene MVP, el acoplamiento entre vista y presenter . Como estuvimos discutiendo, la vista y el presenter deben \"conocerse\" mutuamente, ya que la vista debe comunicarle a este las acciones del usuario, y el presenter enviarle a la vista los datos a mostrar. Esto hace que ambos componentes est\u00e9n acoplados entre s\u00ed, ya hemos visto en el c\u00f3digo de ejemplo de MVP que en la vista hay una referencia al presenter y viceversa. En MVVM no existe este acoplamiento, y lo vamos a evitar usando bindings , es decir, vinculaci\u00f3n autom\u00e1tica entre los datos de la modelo y el presenter , de manera que cuando cambie alguno de ellos se modifique autom\u00e1ticamente el otro. Esto permite que el c\u00f3digo quede mucho m\u00e1s \"limpio\", ya que no hay que actualizar el otro componente de modo expl\u00edcito. En iOS no hay ninguna tecnolog\u00eda est\u00e1ndar para vincular elementos de la vista con propiedades del modelo (aunque en OSX s\u00ed existe). Podr\u00edamos usar KVO o notificaciones para hacer la vinculaci\u00f3n, pero la implementaci\u00f3n ser\u00eda un poco tediosa. As\u00ed que tendremos que usar alguna librer\u00eda de terceros. Aqu\u00ed veremos una bastante sencilla de usar llamada Bond (el nombre completo es Bond, Swift Bond :)). Para implementar los bindings podr\u00edamos usar tambi\u00e9n alg\u00fan framework de reactive programming . Este paradigma de programaci\u00f3n permite implementar la funcionalidad de manera bastante elegante. No obstante usar un framework de este tipo solo para implementar bindings probablemente sea demasiado, ya que la idea de reactive programming es bastante m\u00e1s amplia. En cualquier caso es posible que encontr\u00e9is tutoriales y otros recursos de MVVM en iOS que usen frameworks reactivos como ReactiveCocoa o RXSwift . De hecho, Bond est\u00e1 construido sobre un framework de este tipo, aunque m\u00e1s sencillo. Y como se ver\u00e1, en el ejemplo usaremos funcionalidades t\u00edpicas de programaci\u00f3n reactiva .","title":"MVVM vs. MVP"},{"location":"cap10/4_MVVM/#mvvm-con-la-libreria-bond","text":"Vamos a verlo con un ejemplo, ya que as\u00ed se entender\u00e1n mejor los conceptos. Implementaremos ahora una versi\u00f3n MVVM de la aplicaci\u00f3n UAdivino , al estilo de la que hicimos en el apartado anterior, es decir, mostrando cada tipo de respuesta de un color distinto. La diferencia fundamental va a estar en que vincularemos de modo autom\u00e1tico tanto el texto de la respuesta como el color para que no haga falta fijarlos de forma expl\u00edcita en la vista. Esta vinculaci\u00f3n la haremos gracias a la librer\u00eda Bond. La forma m\u00e1s sencilla de configurar un proyecto de Xcode con Bond es usando Cocoapods. En el README de Bond en Github est\u00e1n las instrucciones . Vamos a empezar a trabajar suponiendo que ya se ha hecho esta configuraci\u00f3n. Como en el caso de la versi\u00f3n MVP pod\u00e9is consultar el c\u00f3digo fuente completo en GitHub.","title":"MVVM con la librer\u00eda \"Bond\""},{"location":"cap10/5_VIPER/","text":"VIPER \u00b6 MVP y MVVM son un paso m\u00e1s en la separaci\u00f3n de responsabilidades en los componentes de la aplicaci\u00f3n, pero no dejan claro c\u00f3mo estructurar el modelo. Adem\u00e1s algunas cosas quedan fuera de la arquitectura, como es el caso del cambio de pantallas en la aplicaci\u00f3n: t\u00edpicamente habr\u00e1 un MVVM por cada pantalla, pero \u00bfqui\u00e9n decide a d\u00f3nde ir saltando y c\u00f3mo hacerlo?. VIPER (View/Interactor/Presenter/Entity/Router) es una arquitectura que intenta solucionar o al menos abordar estos problemas. Qu\u00e9 es VIPER \u00b6 VIPER es una adaptaci\u00f3n a iOS de la Clean Architecture propuesta por el \"gur\u00fa\" de la ingenier\u00eda del software Robert C. Martin , conocido familiarmente como \"Uncle Bob\". El t\u00edo Bob ha explicado los detalles de su clean architecture en m\u00faltiples ocasiones, por ejemplo en su blog y en algunas charlas . VIPER aparece descrito por primera vez en este art\u00edculo de 2014. Igual que suced\u00eda con los \"controladores ligeros\" en MVC, una de las ideas b\u00e1sicas de la Clean Architecture y por tanto de VIPER es llevar a la pr\u00e1ctica el \"Principio de \u00danica Responsabilidad\". Componentes de la arquitectura \u00b6 Como hemos enumerado antes, los componentes son los siguientes: View : muestra los datos que le pasa el presenter , y le pasa a este las acciones del usuario. Como vemos es el mismo papel que desempe\u00f1a en MVP o MVVM. Interactor : es la l\u00f3gica de negocio, los casos de uso de nuestra aplicaci\u00f3n. T\u00edpicamente cada m\u00f3dulo VIPER implementar\u00e1 un caso de uso distinto. Presenter : contiene la l\u00f3gica de presentaci\u00f3n, al igual que en MVP. Entity : los modelos del dominio. Se podr\u00eda decir que contienen la l\u00f3gica de negocio \"gen\u00e9rica\" mientras que el interactor contiene la l\u00f3gica propia de nuestra aplicaci\u00f3n. Router : contiene la l\u00f3gica de navegaci\u00f3n, para saber qu\u00e9 pantallas mostrar y c\u00f3mo cambiar entre ellas. En algunos sitios se conoce tambi\u00e9n como wireframe Los componentes se comunican entre s\u00ed seg\u00fan se indica en el siguiente diagrama: Principios b\u00e1sicos de VIPER \u00b6 Adem\u00e1s de los componentes que lo forman y la forma de comunicarse entre ellos, hay unas cuantas ideas adicionales importantes en VIPER. La primera de ellas es que todos los componentes se comunican entre s\u00ed a trav\u00e9s de protocolos (o interfaces, como dir\u00edamos en otros lenguajes). Esto hace posible sustituir una implementaci\u00f3n de un componente por otra sin afectar al resto del componentes. Es decir, seguimos el principio b\u00e1sico del desarrollo software de programar contra interfaces y no contra implementaciones . En la clean architecture original se hablaba de dos tipos de interfaces: input ports y output ports , y en la mayor\u00eda de implementaciones de VIPER se ha conservado esta idea y terminolog\u00eda. Para un componente, su input port lo constituyen las operaciones que \u00e9l implementa, y que ser\u00e1n llamadas desde otros componentes. El output port ser\u00e1n las operaciones que el componente necesita, implementadas por otro componente. Si tenemos dos componentes, A y B, y A necesita de B, el output port de A ser\u00e1 el mismo protocolo o interfaz que el input port de B. La misi\u00f3n de estos output ports es conseguir lo que se llama inversi\u00f3n de dependencias . Veamos qu\u00e9 es esto. Si nos fijamos en el diagrama principal de VIPER veremos que conforme nos movemos de izquierda a derecha vamos yendo de lo m\u00e1s \"concreto\" y poco reutilizable a lo m\u00e1s \"abstracto\", reutilizable e independiente de los APIs de iOS. La vista est\u00e1 totalmente atada a UIKit , mientras que en el otro extremo el Interactor deber\u00eda ser igual para cualquier plataforma, salvo por el hecho de estar escrito en Swift. Si pensamos en los componentes como capas (m\u00e1s internas conforme avanzamos hacia la derecha), es adecuado que un componente de una capa dependa de los de las capas internas, pero no a la inversa, ya que estar\u00edamos haci\u00e9ndolo depender de \"detalles de implementaci\u00f3n\" que est\u00e1n por debajo de su nivel de abstracci\u00f3n: un ejemplo: cuando el interactor termina su trabajo y debe devolver los datos al presenter tiene que llamarlo para pas\u00e1rselos, pero para no introducir dependencias incorrectas debe hacerlo a trav\u00e9s de un protocolo. Y adem\u00e1s este protocolo deber\u00eda implementarse en el \"paquete\" del interactor , para evitar dependencias directas de c\u00f3digo de interactor a presenter . Este protocolo ser\u00eda el InteractorOutput . Y esto se llama inversi\u00f3n de dependencias porque aunque el interactor llama al presenter en c\u00f3digo no depende de \u00e9l. Otra idea importante es qu\u00e9 datos se pasan entre los componentes . Vamos a verlo con un ejemplo. Si estamos haciendo una aplicaci\u00f3n de tareas pendientes probablemente tendremos una entidad llamada Tarea . Por ejemplo, cuando listamos las tareas pendientes las recuperar\u00e1 el interactor (quiz\u00e1 usando Core Data), que se las pasar\u00e1 al presenter (que formatear\u00e1 los datos adecuadamente, por ejemplo las fechas), y este a su vez a la vista para que las muestre en pantalla. Probablemente lo m\u00e1s directo ser\u00eda pasar objetos Tarea de un componente a otro, pero esto tiene el problema de que estamos acopl\u00e1ndolos todos a la entidad, y si cambiamos esta tendremos que cambiar todos los componentes. Por eso en VIPER y en clean architecture se recomienda pasar solamente los datos que se necesiten y adem\u00e1s en un formato ad hoc , t\u00edpicamente structs o tuplas de datos. Ventajas e inconvenientes \u00b6 Las ventajas de VIPER son las de cualquier arquitectura bien dise\u00f1ada: Facilita la colaboraci\u00f3n en el equipo de desarrollo, si cada desarrollador se ocupa de un componente separado o un conjunto de componentes. Facilita el mantenimiento de la aplicaci\u00f3n. Hace posible el testing . Como inconveniente principal est\u00e1 la sobrecarga que supone crear un m\u00ednimo de 5 componentes por cada m\u00f3dulo. Es una arquitectura que para aplicaciones peque\u00f1as o para aplicaciones implementadas por un solo desarrollador quiz\u00e1 presenta una complicaci\u00f3n excesiva.","title":"5 VIPER"},{"location":"cap10/5_VIPER/#viper","text":"MVP y MVVM son un paso m\u00e1s en la separaci\u00f3n de responsabilidades en los componentes de la aplicaci\u00f3n, pero no dejan claro c\u00f3mo estructurar el modelo. Adem\u00e1s algunas cosas quedan fuera de la arquitectura, como es el caso del cambio de pantallas en la aplicaci\u00f3n: t\u00edpicamente habr\u00e1 un MVVM por cada pantalla, pero \u00bfqui\u00e9n decide a d\u00f3nde ir saltando y c\u00f3mo hacerlo?. VIPER (View/Interactor/Presenter/Entity/Router) es una arquitectura que intenta solucionar o al menos abordar estos problemas.","title":"VIPER"},{"location":"cap10/5_VIPER/#que-es-viper","text":"VIPER es una adaptaci\u00f3n a iOS de la Clean Architecture propuesta por el \"gur\u00fa\" de la ingenier\u00eda del software Robert C. Martin , conocido familiarmente como \"Uncle Bob\". El t\u00edo Bob ha explicado los detalles de su clean architecture en m\u00faltiples ocasiones, por ejemplo en su blog y en algunas charlas . VIPER aparece descrito por primera vez en este art\u00edculo de 2014. Igual que suced\u00eda con los \"controladores ligeros\" en MVC, una de las ideas b\u00e1sicas de la Clean Architecture y por tanto de VIPER es llevar a la pr\u00e1ctica el \"Principio de \u00danica Responsabilidad\".","title":"Qu\u00e9 es VIPER"},{"location":"cap10/5_VIPER/#componentes-de-la-arquitectura","text":"Como hemos enumerado antes, los componentes son los siguientes: View : muestra los datos que le pasa el presenter , y le pasa a este las acciones del usuario. Como vemos es el mismo papel que desempe\u00f1a en MVP o MVVM. Interactor : es la l\u00f3gica de negocio, los casos de uso de nuestra aplicaci\u00f3n. T\u00edpicamente cada m\u00f3dulo VIPER implementar\u00e1 un caso de uso distinto. Presenter : contiene la l\u00f3gica de presentaci\u00f3n, al igual que en MVP. Entity : los modelos del dominio. Se podr\u00eda decir que contienen la l\u00f3gica de negocio \"gen\u00e9rica\" mientras que el interactor contiene la l\u00f3gica propia de nuestra aplicaci\u00f3n. Router : contiene la l\u00f3gica de navegaci\u00f3n, para saber qu\u00e9 pantallas mostrar y c\u00f3mo cambiar entre ellas. En algunos sitios se conoce tambi\u00e9n como wireframe Los componentes se comunican entre s\u00ed seg\u00fan se indica en el siguiente diagrama:","title":"Componentes de la arquitectura"},{"location":"cap10/5_VIPER/#principios-basicos-de-viper","text":"Adem\u00e1s de los componentes que lo forman y la forma de comunicarse entre ellos, hay unas cuantas ideas adicionales importantes en VIPER. La primera de ellas es que todos los componentes se comunican entre s\u00ed a trav\u00e9s de protocolos (o interfaces, como dir\u00edamos en otros lenguajes). Esto hace posible sustituir una implementaci\u00f3n de un componente por otra sin afectar al resto del componentes. Es decir, seguimos el principio b\u00e1sico del desarrollo software de programar contra interfaces y no contra implementaciones . En la clean architecture original se hablaba de dos tipos de interfaces: input ports y output ports , y en la mayor\u00eda de implementaciones de VIPER se ha conservado esta idea y terminolog\u00eda. Para un componente, su input port lo constituyen las operaciones que \u00e9l implementa, y que ser\u00e1n llamadas desde otros componentes. El output port ser\u00e1n las operaciones que el componente necesita, implementadas por otro componente. Si tenemos dos componentes, A y B, y A necesita de B, el output port de A ser\u00e1 el mismo protocolo o interfaz que el input port de B. La misi\u00f3n de estos output ports es conseguir lo que se llama inversi\u00f3n de dependencias . Veamos qu\u00e9 es esto. Si nos fijamos en el diagrama principal de VIPER veremos que conforme nos movemos de izquierda a derecha vamos yendo de lo m\u00e1s \"concreto\" y poco reutilizable a lo m\u00e1s \"abstracto\", reutilizable e independiente de los APIs de iOS. La vista est\u00e1 totalmente atada a UIKit , mientras que en el otro extremo el Interactor deber\u00eda ser igual para cualquier plataforma, salvo por el hecho de estar escrito en Swift. Si pensamos en los componentes como capas (m\u00e1s internas conforme avanzamos hacia la derecha), es adecuado que un componente de una capa dependa de los de las capas internas, pero no a la inversa, ya que estar\u00edamos haci\u00e9ndolo depender de \"detalles de implementaci\u00f3n\" que est\u00e1n por debajo de su nivel de abstracci\u00f3n: un ejemplo: cuando el interactor termina su trabajo y debe devolver los datos al presenter tiene que llamarlo para pas\u00e1rselos, pero para no introducir dependencias incorrectas debe hacerlo a trav\u00e9s de un protocolo. Y adem\u00e1s este protocolo deber\u00eda implementarse en el \"paquete\" del interactor , para evitar dependencias directas de c\u00f3digo de interactor a presenter . Este protocolo ser\u00eda el InteractorOutput . Y esto se llama inversi\u00f3n de dependencias porque aunque el interactor llama al presenter en c\u00f3digo no depende de \u00e9l. Otra idea importante es qu\u00e9 datos se pasan entre los componentes . Vamos a verlo con un ejemplo. Si estamos haciendo una aplicaci\u00f3n de tareas pendientes probablemente tendremos una entidad llamada Tarea . Por ejemplo, cuando listamos las tareas pendientes las recuperar\u00e1 el interactor (quiz\u00e1 usando Core Data), que se las pasar\u00e1 al presenter (que formatear\u00e1 los datos adecuadamente, por ejemplo las fechas), y este a su vez a la vista para que las muestre en pantalla. Probablemente lo m\u00e1s directo ser\u00eda pasar objetos Tarea de un componente a otro, pero esto tiene el problema de que estamos acopl\u00e1ndolos todos a la entidad, y si cambiamos esta tendremos que cambiar todos los componentes. Por eso en VIPER y en clean architecture se recomienda pasar solamente los datos que se necesiten y adem\u00e1s en un formato ad hoc , t\u00edpicamente structs o tuplas de datos.","title":"Principios b\u00e1sicos de VIPER"},{"location":"cap10/5_VIPER/#ventajas-e-inconvenientes","text":"Las ventajas de VIPER son las de cualquier arquitectura bien dise\u00f1ada: Facilita la colaboraci\u00f3n en el equipo de desarrollo, si cada desarrollador se ocupa de un componente separado o un conjunto de componentes. Facilita el mantenimiento de la aplicaci\u00f3n. Hace posible el testing . Como inconveniente principal est\u00e1 la sobrecarga que supone crear un m\u00ednimo de 5 componentes por cada m\u00f3dulo. Es una arquitectura que para aplicaciones peque\u00f1as o para aplicaciones implementadas por un solo desarrollador quiz\u00e1 presenta una complicaci\u00f3n excesiva.","title":"Ventajas e inconvenientes"},{"location":"cap10/6_ejercicios/","text":"Tenemos la aplicaci\u00f3n para consultar el tiempo que ya usamos en el m\u00f3dulo de tecnolog\u00edas de desarrollo y queremos cambiarla para que en lugar de usar MVC use MVVM. IMPORTANTE: Abre el .xcworkspace , no el .xcodeproj como habitualmente. Tras abrirlo deber\u00edas ver dos proyectos: el principal Eltiempo y otro \"secundario\" Pods con las librer\u00edas necesarias. Haz un build del proyecto antes de empezar a trabajar con \u00e9l, para que se compile la librer\u00eda Bond y las otras dependencias. Carpetas para los fuentes \u00b6 Lo primero ser\u00e1 crear las \"carpetas\" necesarias para los fuentes (o groups como se llaman en Xcode) Crea un group llamado Vista ( File > New group... ) y mueve a \u00e9l la clase ViewController , ya que en MVVM el ViewController es parte de la vista. Crear otro group llamado ViewModel y en \u00e9l crear un archivo TiempoViewModel con una clase del mismo nombre vac\u00eda por el momento Ensamblaje de vista, modelo y viewmodel (1 punto) \u00b6 En la clase de la vista (el ViewController ) a\u00f1adir una propiedad que represente al viewmodel 1 let viewModel = TiempoViewModel () En el TiempoViewModel a\u00f1adir una propiedad que represente al modelo 1 let modelo = TiempoModelo () Mostrar la descripci\u00f3n del tiempo (2 puntos) \u00b6 En este apartado conseguiremos que al pulsar en el bot\u00f3n \"consultar tiempo\" la descripci\u00f3n en modo texto (p.ej. \"sol\") aparezca en la pantalla del dispositivo. En el TiempoViewModel A\u00f1ade un import Bond Crear un observable de tipo String llamado estado , con valor inicial la cadena vac\u00eda (mira la sintaxis en transparencias/apuntes) Crea un m\u00e9todo consultarTiempo que admita como par\u00e1metro un String con el nombre de la localidad a consultar 1 2 3 4 5 func consultarTiempo ( de localidad : String ) { //AQUI 1. LLama a consultarTiempo del modelo . P\u00e1sale la localidad y como segundo par\u00e1metro una clausura a la que el modelo llamar\u00e1 cuando el servidor devuelva el estado del tiempo . Esta clausura recibe dos par\u00e1metros , el estado del tiempo como una cadena , y otra cadena con la url del icono que lo representa 2. Dentro de esa clausura actualiza el observable \"estado\" con el valor del primer par\u00e1metro , m\u00e1s tarde nos ocuparemos del icono } Ahora en la vista en el m\u00e9todo consultarTiempoPulsado sustituir la llamada al modelo por 1 self . viewModel . consultarTiempo ( de : loc ) en el viewDidLoad() vincular la propiedad estado del viewModel al texto de la etiqueta estadoLabel Mostrar el icono del tiempo (2 puntos) \u00b6 Haz lo mismo para el icono del tiempo, solo que ser\u00e1 m\u00e1s complicado ya que vinculamos un String con un icono ( UIImage ) Para convertir una String en un icono: Filtrar los Strings con filter solo dejando pasar los distintos de la cadena vac\u00eda Una vez filtrados, usar map para transformar de String->URL->Data->UIImage. En Swift puedes: llamar al inicializador URL(string:) obtener los datos binarios de una URL con Data(contentsOf:) crear un UIImage a partir de datos binarios con UIIMage(data:)","title":"6 ejercicios"},{"location":"cap10/6_ejercicios/#carpetas-para-los-fuentes","text":"Lo primero ser\u00e1 crear las \"carpetas\" necesarias para los fuentes (o groups como se llaman en Xcode) Crea un group llamado Vista ( File > New group... ) y mueve a \u00e9l la clase ViewController , ya que en MVVM el ViewController es parte de la vista. Crear otro group llamado ViewModel y en \u00e9l crear un archivo TiempoViewModel con una clase del mismo nombre vac\u00eda por el momento","title":"Carpetas para los fuentes"},{"location":"cap10/6_ejercicios/#ensamblaje-de-vista-modelo-y-viewmodel-1-punto","text":"En la clase de la vista (el ViewController ) a\u00f1adir una propiedad que represente al viewmodel 1 let viewModel = TiempoViewModel () En el TiempoViewModel a\u00f1adir una propiedad que represente al modelo 1 let modelo = TiempoModelo ()","title":"Ensamblaje de vista, modelo y viewmodel (1 punto)"},{"location":"cap10/6_ejercicios/#mostrar-la-descripcion-del-tiempo-2-puntos","text":"En este apartado conseguiremos que al pulsar en el bot\u00f3n \"consultar tiempo\" la descripci\u00f3n en modo texto (p.ej. \"sol\") aparezca en la pantalla del dispositivo. En el TiempoViewModel A\u00f1ade un import Bond Crear un observable de tipo String llamado estado , con valor inicial la cadena vac\u00eda (mira la sintaxis en transparencias/apuntes) Crea un m\u00e9todo consultarTiempo que admita como par\u00e1metro un String con el nombre de la localidad a consultar 1 2 3 4 5 func consultarTiempo ( de localidad : String ) { //AQUI 1. LLama a consultarTiempo del modelo . P\u00e1sale la localidad y como segundo par\u00e1metro una clausura a la que el modelo llamar\u00e1 cuando el servidor devuelva el estado del tiempo . Esta clausura recibe dos par\u00e1metros , el estado del tiempo como una cadena , y otra cadena con la url del icono que lo representa 2. Dentro de esa clausura actualiza el observable \"estado\" con el valor del primer par\u00e1metro , m\u00e1s tarde nos ocuparemos del icono } Ahora en la vista en el m\u00e9todo consultarTiempoPulsado sustituir la llamada al modelo por 1 self . viewModel . consultarTiempo ( de : loc ) en el viewDidLoad() vincular la propiedad estado del viewModel al texto de la etiqueta estadoLabel","title":"Mostrar la descripci\u00f3n del tiempo (2 puntos)"},{"location":"cap10/6_ejercicios/#mostrar-el-icono-del-tiempo-2-puntos","text":"Haz lo mismo para el icono del tiempo, solo que ser\u00e1 m\u00e1s complicado ya que vinculamos un String con un icono ( UIImage ) Para convertir una String en un icono: Filtrar los Strings con filter solo dejando pasar los distintos de la cadena vac\u00eda Una vez filtrados, usar map para transformar de String->URL->Data->UIImage. En Swift puedes: llamar al inicializador URL(string:) obtener los datos binarios de una URL con Data(contentsOf:) crear un UIImage a partir de datos binarios con UIIMage(data:)","title":"Mostrar el icono del tiempo (2 puntos)"},{"location":"cap10/6_ejercicios_redux/","text":"En las plantillas de la sesi\u00f3n tenemos una aplicaci\u00f3n que implementa una \"lista de la compra\" para apuntar cosas pendientes de comprar y que est\u00e1 desarrollada siguiendo el paradigma MVC. Queremos pasarla a Redux con la ayuda de ReSwift. IMPORTANTE: Abre el .xcworkspace , no el .xcodeproj como habitualmente. Tras abrirlo deber\u00edas ver dos proyectos: el principal ListaCompra y otro \"secundario\" Pods con las librer\u00edas adicionales ( ReSwift en este caso). Haz un build del proyecto antes de empezar a trabajar con \u00e9l, para que se compilen las dependencias. En todos los archivos que uses la librer\u00eda ReSwift necesitar\u00e1s un 1 import ReSwift El estado (0.5 puntos) \u00b6 Crea un group llamado State ( File > New group... ) para guardar el struct que implementa el estado. Por convenio en ReSwift se suele llamar AppState - Declara que es conforme al protocolo StateType - A\u00f1\u00e1dele un campo llamado lista de tipo ListaCompra Las acciones (0.5 puntos) \u00b6 En el ejercicio \u00fanicamente implementaremos una acci\u00f3n para a\u00f1adir un item a la lista. Crea un group llamado Actions ( File > New group... ) para guardar un struct AddItem que representar\u00e1 esta acci\u00f3n Declara que es conforme al protocolo Action A\u00f1\u00e1dele un campo de tipo Item para representar el item a\u00f1adido El reducer (1 punto) \u00b6 Crea un group llamado Reducers ( File > New group... ) para almacenar los reducers . Como es una aplicaci\u00f3n muy sencilla podemos hacerlo todo en un \u00fanico reducer . En el group Reducers crea un archivo AppReducer y en \u00e9l define la funci\u00f3n appReducer(accion: Action, estado: AppState?) -> AppState . Para implementarla puedes ayudarte de las transparencias. El store \u00b6 T\u00edpicamente se suele definir en el AppDelegate simplemente porque es accesible desde cualquier parte de la aplicaci\u00f3n 1 let store = Store < AppState >( reducer : appReducer , state : nil ) Suscribirse a los cambios de estado (1 punto) \u00b6 El ListaViewController es el view controller de la pantalla que muestra la lista de notas, y puede encargarse de recibir los cambios de estado. En la cabecera del ListaViewController indica que es conforme al protocolo StoreSubscriber . Quedar\u00e1: 1 class ListaViewController : UITableViewController , StoreSubscriber { Al poner el protocolo la clase est\u00e1 \"obligada\" a: Especificar el tipo del estado: Simplemente hay que poner en la clase typealias StoreSubscriberStateType = AppState Implementar el m\u00e9todo newState(state:) donde se reciben los cambios de estado. En este m\u00e9todo tendr\u00e1s que hacer 1 2 listaDataSource . setLista ( state . lista ) self . tableView . reloadData () CAMBIOS DEL CODIGO ANTERIOR: en el m\u00e9todo unwind sobra todo el c\u00f3digo que era el que antes recib\u00eda el nuevo item creado, ahora puedes dejarlo vac\u00edo (pero no lo elimines, si no no se podr\u00e1 volver a esta pantalla desde la de edici\u00f3n del item) Despachar las acciones (1 punto) \u00b6 Todav\u00eda nos falta disparar todo el proceso, es decir, despachar la acci\u00f3n de \"a\u00f1adir item\". Esto tendr\u00e1s que hacerlo desde la pantalla de editar item, controlada por el NuevoItemViewController . En el m\u00e9todo shouldPerformSegue , dentro del if identifier==\"guardar\" a\u00f1ade c\u00f3digo que despache la acci\u00f3n al store . CAMBIOS DEL CODIGO ANTERIOR: elimina la propiedad nuevoItem del controller ,ya no es necesaria, antes era el objeto que tomaba la pantalla principal para a\u00f1adirlo a la lista, pero ahora esta informaci\u00f3n no se la pasa este view controller sino el store . Una vez hecho todo esto la parte de a\u00f1adir ya deber\u00eda estar funcionando con redux.","title":"6 ejercicios redux"},{"location":"cap10/6_ejercicios_redux/#el-estado-05-puntos","text":"Crea un group llamado State ( File > New group... ) para guardar el struct que implementa el estado. Por convenio en ReSwift se suele llamar AppState - Declara que es conforme al protocolo StateType - A\u00f1\u00e1dele un campo llamado lista de tipo ListaCompra","title":"El estado (0.5 puntos)"},{"location":"cap10/6_ejercicios_redux/#las-acciones-05-puntos","text":"En el ejercicio \u00fanicamente implementaremos una acci\u00f3n para a\u00f1adir un item a la lista. Crea un group llamado Actions ( File > New group... ) para guardar un struct AddItem que representar\u00e1 esta acci\u00f3n Declara que es conforme al protocolo Action A\u00f1\u00e1dele un campo de tipo Item para representar el item a\u00f1adido","title":"Las acciones (0.5 puntos)"},{"location":"cap10/6_ejercicios_redux/#el-reducer-1-punto","text":"Crea un group llamado Reducers ( File > New group... ) para almacenar los reducers . Como es una aplicaci\u00f3n muy sencilla podemos hacerlo todo en un \u00fanico reducer . En el group Reducers crea un archivo AppReducer y en \u00e9l define la funci\u00f3n appReducer(accion: Action, estado: AppState?) -> AppState . Para implementarla puedes ayudarte de las transparencias.","title":"El reducer (1 punto)"},{"location":"cap10/6_ejercicios_redux/#el-store","text":"T\u00edpicamente se suele definir en el AppDelegate simplemente porque es accesible desde cualquier parte de la aplicaci\u00f3n 1 let store = Store < AppState >( reducer : appReducer , state : nil )","title":"El store"},{"location":"cap10/6_ejercicios_redux/#suscribirse-a-los-cambios-de-estado-1-punto","text":"El ListaViewController es el view controller de la pantalla que muestra la lista de notas, y puede encargarse de recibir los cambios de estado. En la cabecera del ListaViewController indica que es conforme al protocolo StoreSubscriber . Quedar\u00e1: 1 class ListaViewController : UITableViewController , StoreSubscriber { Al poner el protocolo la clase est\u00e1 \"obligada\" a: Especificar el tipo del estado: Simplemente hay que poner en la clase typealias StoreSubscriberStateType = AppState Implementar el m\u00e9todo newState(state:) donde se reciben los cambios de estado. En este m\u00e9todo tendr\u00e1s que hacer 1 2 listaDataSource . setLista ( state . lista ) self . tableView . reloadData () CAMBIOS DEL CODIGO ANTERIOR: en el m\u00e9todo unwind sobra todo el c\u00f3digo que era el que antes recib\u00eda el nuevo item creado, ahora puedes dejarlo vac\u00edo (pero no lo elimines, si no no se podr\u00e1 volver a esta pantalla desde la de edici\u00f3n del item)","title":"Suscribirse a los cambios de estado (1 punto)"},{"location":"cap10/6_ejercicios_redux/#despachar-las-acciones-1-punto","text":"Todav\u00eda nos falta disparar todo el proceso, es decir, despachar la acci\u00f3n de \"a\u00f1adir item\". Esto tendr\u00e1s que hacerlo desde la pantalla de editar item, controlada por el NuevoItemViewController . En el m\u00e9todo shouldPerformSegue , dentro del if identifier==\"guardar\" a\u00f1ade c\u00f3digo que despache la acci\u00f3n al store . CAMBIOS DEL CODIGO ANTERIOR: elimina la propiedad nuevoItem del controller ,ya no es necesaria, antes era el objeto que tomaba la pantalla principal para a\u00f1adirlo a la lista, pero ahora esta informaci\u00f3n no se la pasa este view controller sino el store . Una vez hecho todo esto la parte de a\u00f1adir ya deber\u00eda estar funcionando con redux.","title":"Despachar las acciones (1 punto)"},{"location":"cap10/6a_ejercicios1/","text":"Ejercicios de arquitecturas iOS, parte I \u00b6 En la aplicaci\u00f3n de Notas que venimos desarrollando en la asignatura, el view controller ListaNotasController tiene demasiadas funcionalidades. (4 puntos) Separa los m\u00e9todos que implementan el datasource de la tabla en una clase aparte: - Crea la clase ListaNotasDatasource : - A\u00f1\u00e1dele un m\u00e9todo setLista() que reciba un array de notas ( [Nota] ) como par\u00e1metro y se lo guarde en una propiedad de la clase llamada listaNotas - Ll\u00e9vate a esta clase el c\u00f3digo de los m\u00e9todos que implementan el datasource - En el ListaNotasViewController - A\u00f1ade una propiedad ds , de tipo ListaNotasDataSource - En el viewDidLoad , haz que el ds sea el datasource de la tabla 1 2 3 4 5 6 ```swift self.tableView.dataSource = self.ds ``` - En el `viewWillAppear`, cada vez que obtengas la lista de notas con el *fetch request*, p\u00e1saselas al `ds`, con `ds.setLista()` - La propiedad `listaNotas` del `ListaNotasViewController` ya sobra, porque la lista ahora la maneja el *datasource* (1 punto) En el ListaNotasDatasource separa el c\u00f3digo que se encarga de rellenar los campos de la celda y encaps\u00falalo en una clase aparte igual que se muestra en las transparencias","title":"6a ejercicios1"},{"location":"cap10/6a_ejercicios1/#ejercicios-de-arquitecturas-ios-parte-i","text":"En la aplicaci\u00f3n de Notas que venimos desarrollando en la asignatura, el view controller ListaNotasController tiene demasiadas funcionalidades. (4 puntos) Separa los m\u00e9todos que implementan el datasource de la tabla en una clase aparte: - Crea la clase ListaNotasDatasource : - A\u00f1\u00e1dele un m\u00e9todo setLista() que reciba un array de notas ( [Nota] ) como par\u00e1metro y se lo guarde en una propiedad de la clase llamada listaNotas - Ll\u00e9vate a esta clase el c\u00f3digo de los m\u00e9todos que implementan el datasource - En el ListaNotasViewController - A\u00f1ade una propiedad ds , de tipo ListaNotasDataSource - En el viewDidLoad , haz que el ds sea el datasource de la tabla 1 2 3 4 5 6 ```swift self.tableView.dataSource = self.ds ``` - En el `viewWillAppear`, cada vez que obtengas la lista de notas con el *fetch request*, p\u00e1saselas al `ds`, con `ds.setLista()` - La propiedad `listaNotas` del `ListaNotasViewController` ya sobra, porque la lista ahora la maneja el *datasource* (1 punto) En el ListaNotasDatasource separa el c\u00f3digo que se encarga de rellenar los campos de la celda y encaps\u00falalo en una clase aparte igual que se muestra en las transparencias","title":"Ejercicios de arquitecturas iOS, parte I"},{"location":"cap10/intro/","text":"En este tema veremos algo que no est\u00e1 directamente relacionado con la persistencia, pero que es pertinente en este punto del curso. Hasta ahora hemos visto multitud de tecnolog\u00edas para desarrollar aplicaciones en iOS, pero una cosa que nos falta es saber c\u00f3mo estructurar el c\u00f3digo de la aplicaci\u00f3n para hacerlo lo m\u00e1s claro, mantenible y testable que sea posible. Ya vimos al comienzo del curso que la arquitectura recomendada por Apple es Modelo/Vista/Controlador, pero aunque es muy apropiada para ejemplos y para aplicaciones peque\u00f1as, con aplicaciones m\u00e1s grandes presenta algunos problemas. Primero veremos cu\u00e1les son estos problemas y c\u00f3mo solucionarlos aunque sea parcialmente y luego abordaremos otras arquitecturas que se han propuesto como alternativas al cl\u00e1sico MVC.","title":"Intro"},{"location":"cap10/notas/","text":"Los problemas de MVC MVC de Apple: expectativa vs. realidad Adelgazar controladores. \u00bfPero d\u00f3nde ponemos el c\u00f3digo que sobra? MVx Viper Arquitecturas reactivas Referencias \u00b6 MVP \u00b6 http://iyadagha.com/using-mvp-ios-swift/ https://ios.james.ooo/model-view-controller-presenter-8bb4149fa5ef#.b63z6tbjy","title":"Notas"},{"location":"cap10/notas/#referencias","text":"","title":"Referencias"},{"location":"cap10/notas/#mvp","text":"http://iyadagha.com/using-mvp-ios-swift/ https://ios.james.ooo/model-view-controller-presenter-8bb4149fa5ef#.b63z6tbjy","title":"MVP"},{"location":"cap11/1_introduccion_BAAS/","text":"Aunque hay algunas aplicaciones que pueden funcionar por s\u00ed solas sin necesidad de un servidor, muchas aplicaciones actuales necesitan de un backend para poder almacenar datos \u201cen la nube\u201d. As\u00ed el usuario pueda acceder a su informaci\u00f3n independientemente del dispositivo que est\u00e9 usando. Otras muchas aplicaciones lo usan para que se pueda compartir informaci\u00f3n con otros usuarios. El problema es que desarrollar un backend para una aplicaci\u00f3n m\u00f3vil no es una tarea trivial, incluso si se tienen los conocimientos necesarios. Hay que escribir la aplicaci\u00f3n en el lado del servidor, desplegarla, alojarla en alg\u00fan hosting , hacerla escalable, \u2026. Y adem\u00e1s muchos desarrolladores de aplicaciones m\u00f3viles no tienen las habilidades necesarias, ya que en el backend se usan lenguajes, tecnolog\u00edas y herramientas totalmente diferentes de los usados para el desarrollo del cliente. Esto ha hecho que surja un mercado de lo que se conoce como \u201cBackend as a Service\u201d (o BaaS), es decir, ofrecer como servicio \u201clisto para usar\u201d las funcionalidades m\u00e1s t\u00edpicas de los backends para aplicaciones m\u00f3viles: autentificaci\u00f3n de usuarios, persistencia de datos \u201cen la nube\u201d, anal\u00edticas de tr\u00e1fico, notificaciones push etc. Por supuesto las propias plataformas de desarrollo m\u00f3vil ya ofrecen algunos de estos servicios (por ejemplo Apple ofrece persistencia \u201cen la nube\u201d con iCloud), pero ha surgido una serie de compa\u00f1\u00edas que ofrecen estos servicios con compatibilidad multiplataforma, de modo que por ejemplo podemos acceder a los mismos datos remotos estemos en la versi\u00f3n iOS, en la versi\u00f3n Android o incluso en la versi\u00f3n web de la aplicaci\u00f3n. En la actualidad existen m\u00faltiples plataformas de terceros que ofrecen funcionalidades de Baas. Vamos a centrarnos aqu\u00ed en Firebase simplemente porque es una de las m\u00e1s conocidas y porque es multiplataformas. El resto de plataformas ofrecen funcionalidades similares. Para usar Firebase lo primero es darse de alta en la plataforma . Una vez dados de alta, podremos crear proyectos en Firebase. Un proyecto es una app con un conjunto de usuarios, una base de datos, un espacio para alojar archivos, etc. Esta app Firebase puede tener varios clientes: iOS, Android, web, ... Para crear una aplicaci\u00f3n iOS que act\u00fae como cliente de nuestro proyecto de Firebase podemos seguir las instrucciones de Google: c\u00f3mo agregar Firebase a tu proyecto de iOS . Las instrucciones est\u00e1n bastante detalladas y adem\u00e1s traducidas a espa\u00f1ol.","title":"Backend as a Service"},{"location":"cap11/2_gestion_usuarios/","text":"La gran mayor\u00eda de aplicaciones tiene que gestionar datos de usuarios y autentificarlos para poder realizar ciertas operaciones. T\u00edpicamente vamos a tener que: Implementar un CRUD de usuarios, para poder darlos de alta, de baja y que puedan modificar sus datos de perfil. Implementar funcionalidades de login/logout para que el usuario se pueda autentificar en la aplicaci\u00f3n y as\u00ed tenga acceso a las funcionalidades que la requieran. Firebase cubre los dos tipos de funcionalidades. Adem\u00e1s no solo vamos a poder gestionar usuarios d\u00e1ndolos de alta en la aplicaci\u00f3n con login y password, sino que tambi\u00e9n nos permite autentificaci\u00f3n con credenciales externas, o identidad federada : el usuario puede identificarse en nuestra app con su login de otros sitios como Facebook, Twitter o Google, con lo que se evita tener que crearse un nuevo usuario/contrase\u00f1a solo para nuestra aplicaci\u00f3n. A\u00f1adir autentificaci\u00f3n a una app de Firebase \u00b6 Las funcionalidades de usuarios est\u00e1n en el m\u00f3dulo auth . Si usamos Cocoapods para gestionar las dependencias, tendremos que a\u00f1adir la siguiente dependencia al Podfile 1 pod 'Firebase/Auth' tras ello, ejecutar en la consola pod install . Para poder llamar a este API en nuestro c\u00f3digo necesitaremos un 1 import Firebase Pod\u00e9is consultar online y traducida al espa\u00f1ol la documentaci\u00f3n de las librer\u00edas de iOS para gesti\u00f3n de usuarios y autentificaci\u00f3n. Administraci\u00f3n de usuarios \u00b6 Los usuarios en Firebase tienen una serie de propiedades b\u00e1sicas: un id \u00fanico, una direcci\u00f3n de correo electr\u00f3nico, un nombre y la URL de su foto de perfil. Todos los usuarios tienen estos datos, aunque podemos simplemente ignorar alguno en nuestra app (por ejemplo la URL). A los objetos usuario no se les pueden a\u00f1adir m\u00e1s propiedades, si necesitamos m\u00e1s datos (fecha de nacimiento, sexo, e-mail secundario,...) tendremos que almacenarlos aparte en la base de datos de Firebase. Aunque Firebase permite que los usuarios puedan autentificarse con credenciales de Google, Facebook, Twitter, ... aqu\u00ed solo veremos la autentificaci\u00f3n con contrase\u00f1a, es decir, los usuarios van a darse de alta en nuestra app y elegir un login (que debe ser su email ) y un password . passwors no lo podremos consultar desde nuestra app , solo modificar). Para ver c\u00f3mo autentificarse con identidades federadas, consultar la documentaci\u00f3n de Firebase Como veremos, la mayor\u00eda de m\u00e9todos del API son as\u00edncronos, ya que requieren de interacci\u00f3n con el servidor y hacerlos s\u00edncronos bloquear\u00eda la app hasta que este respondiera. Los m\u00e9todos as\u00edncronos del API tienen como \u00faltimo par\u00e1metro una clausura que se ejecutar\u00e1 cuando el servidor complete la operaci\u00f3n. La clausura a ejecutar recibe como par\u00e1metro un error en caso de haberse producido alguno, y adem\u00e1s en algunos m\u00e9todos recibe un par\u00e1metro adicional con el resultado de la operaci\u00f3n si ha sido exitoso. Dar de alta usuarios \u00b6 Para dar de alta un usuario llamaremos al m\u00e9todo createUser(withEmail:,password:,completion:) . Es un m\u00e9todo as\u00edncrono, su \u00faltimo par\u00e1metro es una clausura que se ejecutar\u00e1 cuando se complete en el servidor el proceso de registro. Como ya se ha dicho esta clausura recibe como par\u00e1metro el error producido, si lo hay. Si no ha habido error, adem\u00e1s como primer par\u00e1metro se recibe un objeto de tipo AuthDataResult con el resultado de la operaci\u00f3n. Dentro de este objeto el campo user contiene informaci\u00f3n sobre el usuario reci\u00e9n creado. Por ejemplo: 1 2 3 4 5 6 7 8 9 Auth . auth (). createUser ( withEmail : email , password : password ) { ( result , error ) in if let error = error { print ( \"Error\" ) } else { print ( \"Dado de alta usuario con email: \\( result ?. user . email ! ) \" ) } } Como es l\u00f3gico, antes de poder llamar a este m\u00e9todo tenemos que haber hecho alg\u00fan formulario para que el usuario rellene sus datos, pedirle dos veces la contrase\u00f1a para chequear errores, etc. Esto es tarea nuestra y de ello no se va a ocupar createUser . Llamaremos a este m\u00e9todo solo cuando hayamos validado que los datos introducidos por el usuario son correctos (que el email no est\u00e1 vac\u00edo y tiene un formato adecuado, que los dos passwords del formulario coinciden, ...). Como crear las pantallas de alta, login, etc es un proceso tedioso, en Firebase existe un m\u00f3dulo denominado FirebaseUI que implementa la interfaz de las operaciones m\u00e1s comunes. Pod\u00e9is consultar m\u00e1s informaci\u00f3n en la documentaci\u00f3n de Firebase . N\u00f3tese adem\u00e1s que el createUser solo rellena los datos m\u00e1s b\u00e1sicos, para rellenar el resto de datos usaremos la funcionalidad de actualizar perfil. Validar el alta de un usuario \u00b6 En muchos sitios web cuando un usuario se da de alta se le env\u00eda por email un link para que confirme el registro. En Firebase podemos hacer esto con el m\u00e9todo sendEmailVerification del usuario actual. Este m\u00e9todo pertenece al usuario autentificado . Para obtener el usuario autentificado actualmente en la app accedemos a la propiedad Auth.auth().currentUser . Si es nil no hay ning\u00fan usuario autentificado. 1 2 3 Auth . auth (). currentUser ?. sendEmailVerification { ( error ) in // ... } Modificar el perfil de un usuario \u00b6 Para modificar los datos de un usuario, el objeto usuario correspondiente debe llamar a createProfileChangeRequest , hacemos los cambios y finalmente llamamos a commitChanges(completion:) , que es as\u00edncrono, y al que se le pasa una clausura a ejecutar cuando los cambios se hagan efectivos en el servidor. 1 2 3 4 5 6 7 8 9 10 let changeRequest = Auth . auth (). currentUser ?. createProfileChangeRequest () changeRequest ?. displayName = displayName changeRequest ?. commitChanges { ( error ) in if let error = error { print ( \"Error: \\( error ) \" ) } else { print ( \"Perfil actualizado OK\" ) } } Hay m\u00e9todos individuales para actualizar el email y el password : updateEmail y updatePassword . Son m\u00e9todos as\u00edncronos, y como par\u00e1metro, adem\u00e1s del nuevo valor, pasaremos una clausura a ejecutar cuando acabe la operaci\u00f3n: 1 2 3 4 5 6 Auth . auth (). currentUser ?. updateEmail ( to : email ) { ( error ) in // ... } Auth . auth (). currentUser ?. updatePassword ( to : password ) { ( error ) in // ... } Por razones de seguridad, cuando un usuario cambia su direcci\u00f3n de correo electr\u00f3nico, se le env\u00eda un email a la su direcci\u00f3n para que pueda consultar el cambio. Se puede cambiar la plantilla que se usa para este email en la consola de Firebase, en el apartado: Autenticaci\u00f3n > Plantillas . En lugar de actualizar el password directamente, podemos enviarle al usuario el t\u00edpico mensaje de resetear password , con un enlace en el que se hace clic se saltar\u00e1 a una p\u00e1gina (hecha por Google) con un formulario para cambiar el password . Dar de baja a un usuario \u00b6 Para borrar a un usuario, usamos delete , que de nuevo es un m\u00e9todo as\u00edncrono: 1 2 3 4 5 6 7 8 let user = Auth . auth (). currentUser user ?. delete { error in if let error = error { print ( \"Error\" ) } else { print ( \"Cuenta dada de baja\" ) } } Autentificaci\u00f3n \u00b6 Para hacer login en la aplicaci\u00f3n, llamamos al m\u00e9todo signIn , que como viene siendo habitual es as\u00edncrono. Si la autentificaci\u00f3n tiene \u00e9xito se devuelve un objeto de tipo AuthDataResult que contiene entre otros datos la referencia al usuario autentificado en su campo user . 1 2 3 4 5 6 7 8 Auth . auth (). signIn ( withEmail : email , password : password ) { ( result , error ) in if let error = error { print ( \"Error\" ) } else { print ( \"Login de: \\( result ?. user . email ! ) \" ) } } como ya hemos visto en el apartado anterior, para saber el usuario actual podemos acceder a Auth.auth().currentUser . Hay que destacar que la \"sesi\u00f3n\" actual se guarda de manera persistente, as\u00ed que si salimos de la aplicaci\u00f3n y volvemos a entrar, el usuario seguir\u00e1 estando activo hasta que cerremos expl\u00edcitamente la sesi\u00f3n. Para cerrar la sesi\u00f3n, llamar al m\u00e9todo signOut , que es s\u00edncrono: 1 2 3 4 5 do { try Auth . auth (). signOut () } catch let signOutError as NSError { print ( \"Error cerrando la sesi\u00f3n: \\( signOutError ) \" ) } Podemos detectar el sign-in y sign-out del usuario con addStateDidChangeListener . Le pasaremos una clausura que se ejecutar\u00e1 cuando se haga una de estas dos operaciones, es decir, es un listener del cambio de estado. T\u00edpicamente se usa para mostrar el estado actual en la interfaz de usuario, por lo que normalmente se a\u00f1adir\u00e1 el listener al mostrar la pantalla con los datos, es decir en el viewWillAppear del controlador de la vista: 1 2 3 4 //donde \"handle\" ser\u00eda una propiedad del view controller self . handle = Auth . auth (). addStateDidChangeListener { ( auth , user ) in // ... } El valor de retorno del m\u00e9todo anterior se usa para eliminar el listener . Habitualmente el lugar m\u00e1s apropiado es cuando salimos de la pantalla, en el viewWillDisappear ) del controlador de la vista: `swift Auth.auth().removeStateDidChangeListener(self.handle)","title":"Gesti\u00f3n de usuarios en Firebase"},{"location":"cap11/2_gestion_usuarios/#anadir-autentificacion-a-una-app-de-firebase","text":"Las funcionalidades de usuarios est\u00e1n en el m\u00f3dulo auth . Si usamos Cocoapods para gestionar las dependencias, tendremos que a\u00f1adir la siguiente dependencia al Podfile 1 pod 'Firebase/Auth' tras ello, ejecutar en la consola pod install . Para poder llamar a este API en nuestro c\u00f3digo necesitaremos un 1 import Firebase Pod\u00e9is consultar online y traducida al espa\u00f1ol la documentaci\u00f3n de las librer\u00edas de iOS para gesti\u00f3n de usuarios y autentificaci\u00f3n.","title":"A\u00f1adir autentificaci\u00f3n a una app de Firebase"},{"location":"cap11/2_gestion_usuarios/#administracion-de-usuarios","text":"Los usuarios en Firebase tienen una serie de propiedades b\u00e1sicas: un id \u00fanico, una direcci\u00f3n de correo electr\u00f3nico, un nombre y la URL de su foto de perfil. Todos los usuarios tienen estos datos, aunque podemos simplemente ignorar alguno en nuestra app (por ejemplo la URL). A los objetos usuario no se les pueden a\u00f1adir m\u00e1s propiedades, si necesitamos m\u00e1s datos (fecha de nacimiento, sexo, e-mail secundario,...) tendremos que almacenarlos aparte en la base de datos de Firebase. Aunque Firebase permite que los usuarios puedan autentificarse con credenciales de Google, Facebook, Twitter, ... aqu\u00ed solo veremos la autentificaci\u00f3n con contrase\u00f1a, es decir, los usuarios van a darse de alta en nuestra app y elegir un login (que debe ser su email ) y un password . passwors no lo podremos consultar desde nuestra app , solo modificar). Para ver c\u00f3mo autentificarse con identidades federadas, consultar la documentaci\u00f3n de Firebase Como veremos, la mayor\u00eda de m\u00e9todos del API son as\u00edncronos, ya que requieren de interacci\u00f3n con el servidor y hacerlos s\u00edncronos bloquear\u00eda la app hasta que este respondiera. Los m\u00e9todos as\u00edncronos del API tienen como \u00faltimo par\u00e1metro una clausura que se ejecutar\u00e1 cuando el servidor complete la operaci\u00f3n. La clausura a ejecutar recibe como par\u00e1metro un error en caso de haberse producido alguno, y adem\u00e1s en algunos m\u00e9todos recibe un par\u00e1metro adicional con el resultado de la operaci\u00f3n si ha sido exitoso.","title":"Administraci\u00f3n de usuarios"},{"location":"cap11/2_gestion_usuarios/#dar-de-alta-usuarios","text":"Para dar de alta un usuario llamaremos al m\u00e9todo createUser(withEmail:,password:,completion:) . Es un m\u00e9todo as\u00edncrono, su \u00faltimo par\u00e1metro es una clausura que se ejecutar\u00e1 cuando se complete en el servidor el proceso de registro. Como ya se ha dicho esta clausura recibe como par\u00e1metro el error producido, si lo hay. Si no ha habido error, adem\u00e1s como primer par\u00e1metro se recibe un objeto de tipo AuthDataResult con el resultado de la operaci\u00f3n. Dentro de este objeto el campo user contiene informaci\u00f3n sobre el usuario reci\u00e9n creado. Por ejemplo: 1 2 3 4 5 6 7 8 9 Auth . auth (). createUser ( withEmail : email , password : password ) { ( result , error ) in if let error = error { print ( \"Error\" ) } else { print ( \"Dado de alta usuario con email: \\( result ?. user . email ! ) \" ) } } Como es l\u00f3gico, antes de poder llamar a este m\u00e9todo tenemos que haber hecho alg\u00fan formulario para que el usuario rellene sus datos, pedirle dos veces la contrase\u00f1a para chequear errores, etc. Esto es tarea nuestra y de ello no se va a ocupar createUser . Llamaremos a este m\u00e9todo solo cuando hayamos validado que los datos introducidos por el usuario son correctos (que el email no est\u00e1 vac\u00edo y tiene un formato adecuado, que los dos passwords del formulario coinciden, ...). Como crear las pantallas de alta, login, etc es un proceso tedioso, en Firebase existe un m\u00f3dulo denominado FirebaseUI que implementa la interfaz de las operaciones m\u00e1s comunes. Pod\u00e9is consultar m\u00e1s informaci\u00f3n en la documentaci\u00f3n de Firebase . N\u00f3tese adem\u00e1s que el createUser solo rellena los datos m\u00e1s b\u00e1sicos, para rellenar el resto de datos usaremos la funcionalidad de actualizar perfil.","title":"Dar de alta usuarios"},{"location":"cap11/2_gestion_usuarios/#validar-el-alta-de-un-usuario","text":"En muchos sitios web cuando un usuario se da de alta se le env\u00eda por email un link para que confirme el registro. En Firebase podemos hacer esto con el m\u00e9todo sendEmailVerification del usuario actual. Este m\u00e9todo pertenece al usuario autentificado . Para obtener el usuario autentificado actualmente en la app accedemos a la propiedad Auth.auth().currentUser . Si es nil no hay ning\u00fan usuario autentificado. 1 2 3 Auth . auth (). currentUser ?. sendEmailVerification { ( error ) in // ... }","title":"Validar el alta de un usuario"},{"location":"cap11/2_gestion_usuarios/#modificar-el-perfil-de-un-usuario","text":"Para modificar los datos de un usuario, el objeto usuario correspondiente debe llamar a createProfileChangeRequest , hacemos los cambios y finalmente llamamos a commitChanges(completion:) , que es as\u00edncrono, y al que se le pasa una clausura a ejecutar cuando los cambios se hagan efectivos en el servidor. 1 2 3 4 5 6 7 8 9 10 let changeRequest = Auth . auth (). currentUser ?. createProfileChangeRequest () changeRequest ?. displayName = displayName changeRequest ?. commitChanges { ( error ) in if let error = error { print ( \"Error: \\( error ) \" ) } else { print ( \"Perfil actualizado OK\" ) } } Hay m\u00e9todos individuales para actualizar el email y el password : updateEmail y updatePassword . Son m\u00e9todos as\u00edncronos, y como par\u00e1metro, adem\u00e1s del nuevo valor, pasaremos una clausura a ejecutar cuando acabe la operaci\u00f3n: 1 2 3 4 5 6 Auth . auth (). currentUser ?. updateEmail ( to : email ) { ( error ) in // ... } Auth . auth (). currentUser ?. updatePassword ( to : password ) { ( error ) in // ... } Por razones de seguridad, cuando un usuario cambia su direcci\u00f3n de correo electr\u00f3nico, se le env\u00eda un email a la su direcci\u00f3n para que pueda consultar el cambio. Se puede cambiar la plantilla que se usa para este email en la consola de Firebase, en el apartado: Autenticaci\u00f3n > Plantillas . En lugar de actualizar el password directamente, podemos enviarle al usuario el t\u00edpico mensaje de resetear password , con un enlace en el que se hace clic se saltar\u00e1 a una p\u00e1gina (hecha por Google) con un formulario para cambiar el password .","title":"Modificar el perfil de un usuario"},{"location":"cap11/2_gestion_usuarios/#dar-de-baja-a-un-usuario","text":"Para borrar a un usuario, usamos delete , que de nuevo es un m\u00e9todo as\u00edncrono: 1 2 3 4 5 6 7 8 let user = Auth . auth (). currentUser user ?. delete { error in if let error = error { print ( \"Error\" ) } else { print ( \"Cuenta dada de baja\" ) } }","title":"Dar de baja a un usuario"},{"location":"cap11/2_gestion_usuarios/#autentificacion","text":"Para hacer login en la aplicaci\u00f3n, llamamos al m\u00e9todo signIn , que como viene siendo habitual es as\u00edncrono. Si la autentificaci\u00f3n tiene \u00e9xito se devuelve un objeto de tipo AuthDataResult que contiene entre otros datos la referencia al usuario autentificado en su campo user . 1 2 3 4 5 6 7 8 Auth . auth (). signIn ( withEmail : email , password : password ) { ( result , error ) in if let error = error { print ( \"Error\" ) } else { print ( \"Login de: \\( result ?. user . email ! ) \" ) } } como ya hemos visto en el apartado anterior, para saber el usuario actual podemos acceder a Auth.auth().currentUser . Hay que destacar que la \"sesi\u00f3n\" actual se guarda de manera persistente, as\u00ed que si salimos de la aplicaci\u00f3n y volvemos a entrar, el usuario seguir\u00e1 estando activo hasta que cerremos expl\u00edcitamente la sesi\u00f3n. Para cerrar la sesi\u00f3n, llamar al m\u00e9todo signOut , que es s\u00edncrono: 1 2 3 4 5 do { try Auth . auth (). signOut () } catch let signOutError as NSError { print ( \"Error cerrando la sesi\u00f3n: \\( signOutError ) \" ) } Podemos detectar el sign-in y sign-out del usuario con addStateDidChangeListener . Le pasaremos una clausura que se ejecutar\u00e1 cuando se haga una de estas dos operaciones, es decir, es un listener del cambio de estado. T\u00edpicamente se usa para mostrar el estado actual en la interfaz de usuario, por lo que normalmente se a\u00f1adir\u00e1 el listener al mostrar la pantalla con los datos, es decir en el viewWillAppear del controlador de la vista: 1 2 3 4 //donde \"handle\" ser\u00eda una propiedad del view controller self . handle = Auth . auth (). addStateDidChangeListener { ( auth , user ) in // ... } El valor de retorno del m\u00e9todo anterior se usa para eliminar el listener . Habitualmente el lugar m\u00e1s apropiado es cuando salimos de la pantalla, en el viewWillDisappear ) del controlador de la vista: `swift Auth.auth().removeStateDidChangeListener(self.handle)","title":"Autentificaci\u00f3n"},{"location":"cap11/3_persistencia/","text":"Actualmente hay dos bases de datos disponibles en Firebase: la realtime database, que es la \"original\" y el cloud firestore , que se introdujo posteriormente. Ambas son bases de datos NoSQL, aunque la realtime tiene una estructura de datos algo m\u00e1s peculiar. Vamos a ver aqu\u00ed la realtime database , que como su nombre indica es especialmente apropiada para aplicaciones en tiempo real , ya que adem\u00e1s de poder hacer las t\u00edpicas consultas podemos \"escuchar\" los cambios en los datos. No obstante se puede usar en cualquier tipo de aplicaci\u00f3n. Pod\u00e9is consultar online y traducida al espa\u00f1ol la documentaci\u00f3n de los APIs de iOS para la realtime database . Estructurar los datos \u00b6 Como ya hemos comentado, las dos bases de datos disponibles en Firebase son NoSQL. Esto quiere decir que los datos no tienen la divisi\u00f3n habitual en tablas a la que estamos acostumbrados en bases de datos relacionales. La base de datos tampoco se ocupa de comprobar autom\u00e1ticamente la consistencia o la integridad de los datos, quedando esta tarea en manos de la aplicaci\u00f3n. En la realtime database todos los datos est\u00e1n contenidos en un \u00fanico \"\u00e1rbol\" de pares clave-valor. Los valores pueden ser primitivos (n\u00fameros, cadenas o valores booleanos) o pueden ser valores compuestos a su vez de pares clave-valor. Por ejemplo podr\u00edamos tener algo como: 1 2 3 4 5 6 7 8 9 10 11 12 { \"personas\" : { \"jap2\" : { \"nombre\" : \"Juan\" , \"apellidos\" : \"Arriquitaun P\u00e9rez\" }, \"ems21\" : { \"nombre\" : \"Eva\" , \"apellidos\" : \"Mar\u00edn Salgado\" } } } En este caso el \u00e1rbol contiene un \u00fanico par clave/valor en su nivel superior. El valor asociado a la clave \"personas\" es compuesto y consiste de dos pares cuyas claves son \"jap2\" y \"ems21\", y as\u00ed sucesivamente. N\u00f3tese que la clave se separa del valor por \":\", que un par se separa del siguiente con una coma y que los valores compuestos se delimitan entre llaves. Es decir, es un formato de datos muy similar a JSON, aunque en JSON se pueden representar listas de datos con [] y esa posibilidad no existe aqu\u00ed. N\u00f3tese que, al contrario que en las bases de datos relacionales no existe un esquema inicial que restrinja el formato de los datos. Mientras se respete la estructura b\u00e1sica de pares clave/valor los datos tienen un formato libre. Por ejemplo no necesariamente tendr\u00edamos que tener propiedad \"nombre\" para todas las personas de la BD, o podr\u00edamos tener alguna propiedad m\u00e1s para algunas personas s\u00ed y para otras no. Al no existir tablas ni relaciones entre ellas, la forma m\u00e1s habitual de representar las relaciones entre datos es \"embeber\" unos datos dentro de otros. Por ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 { \"personas\" : { \"ems21\" : { \"apellidos\" : \"Mar\u00edn Salgado\" , \"nombre\" : \"Eva\" , \"mensajes\" : { \"m1\" : { \"texto\" : \"Hola amigos\" , \"timestamp\" : 19029898493 }, \"m2\" : { \"texto\" : \"\u00bfNo me contesta nadie? :(\" , \"timestamp\" : 20458569556 } } }, \"jap2\" : { \"apellidos\" : \"Arriquitaun P\u00e9rez\" , \"direccion\" : { \"calle\" : \"Pez, 25\" , \"localidad\" : \"Madrid\" }, \"mensajes\" : { \"m3\" : { \"texto\" : \"Hola, s\u00ed!!\" \"timestamp\" : 21020129382 } }, \"nombre\" : \"Juan\" } } } En el c\u00f3digo anterior podemos ver algunos de ejemplos de lo que en bases de datos relaciones ser\u00edan precisamente relaciones. Por un lado una relaci\u00f3n 1:1 entre \"persona\" y \"direccion\", que se reperesenta aqu\u00ed con la propiedad compuesta \"direccion\" dentro de la persona. Por otro lado una relaci\u00f3n 1:N entre \"persona\" y \"mensajes\", que se representa de la misma forma, guardando los \"mensajes\" dentro de la \"persona\". El problema de las estructuras de datos anidadas es a la hora de sacar la informaci\u00f3n de la BD. Como veremos, con Firebase podemos listar y filtrar de forma sencilla todos los nodos hijos de un nodo dado (por ejemplo obtener todos los mensajes de la persona \"ems21\" ordenados por timestamp ). El problema lo tendr\u00edamos si quisi\u00e9ramos obtener una lista de todos los mensajes independientemente de qui\u00e9n los ha enviado, que con la estructura de datos anterior requerir\u00eda ejecutar una consulta por cada usuario para finalmente unir todos los resultados y ordenarlos. Este problema se puede resolver desnormalizando los datos, es decir, duplicando la informaci\u00f3n. Adem\u00e1s de la estructura anterior podr\u00edamos tener repetidos por otro lado todos los mensajes dentro de un nodo \"mensajes\" independientemente de qui\u00e9n los haya enviado: 1 2 3 4 5 6 7 8 9 { \"personas\" : { //Igual que antes, personas con sus mensajes } \"mensajes\" : { //Aqu\u00ed todos los mensajes de todos los usuarios } } Referencias \u00b6 Un concepto fundamental y necesario para poder leer y escribir datos es el de referencia . Una referencia representa un nodo del \u00e1rbol de datos. Con los m\u00e9todos del API podemos obtener directamente una referencia a un nodo cualquiera si conocemos su path desde la ra\u00edz. O bien podemos partir de una referencia que ya tengamos a un nodo y movernos a uno de sus hijos. Una vez obtenida la referencia al nodo que nos interesa, podremos leer su estado/modificarlo con otros m\u00e9todos del API. Por ejemplo supongamos que tenemos la estructura de datos en Firebase que vimos en el apartado anterior. 1 2 3 4 5 6 7 8 9 10 11 12 { \"personas\" : { \"jap2\" : { \"nombre\" : \"Juan\" , \"apellidos\" : \"Arriquitaun P\u00e9rez\" }, \"ems21\" : { \"nombre\" : \"Eva\" , \"apellidos\" : \"Mar\u00edn Salgado\" } } } Para obtener una referencia a un nodo, lo primero es obtener la base de datos en s\u00ed, a la que accedemos con Database.database() . A partir de aqu\u00ed: El nodo ra\u00edz lo podemos obtener con reference() , y podemos ir bajando por los hijos con child() , por ejemplo: 1 2 3 4 5 6 //El \u00e1rbol completo, dicho de otro modo el nodo ra\u00edz let rootRef = Database . database (). reference () //El nodo \"personas\" let personasRef = rootRef . child ( \"personas\" ) //El nodo \"nombre\" perteneciente a \"jap2\" let nombreRef = personasRef . child ( \"jap2\" ). child ( \"nombre\" ) Tambi\u00e9n podemos acceder a un nodo con su path desde el nodo ra\u00edz, para ello usamos el m\u00e9todo reference(withPath:) , por ejemplo: 1 2 3 let db = Database . database () //El nodo \"nombre\" perteneciente a \"jap2\" let nombreRef = db . reference ( withPath : \"personas/jap2/nombre\" ) N\u00f3tese que podemos obtener una referencia a un nodo aunque este no exista todav\u00eda en la base de datos. Por ejemplo, esto ser\u00eda v\u00e1lido en el ejemplo que estamos siguiendo, aunque en la BD no hay nada relativo a pedidos: 1 let ref = db . reference ( withPath ( \"pedidos/1\" )) Esto nos permitir\u00e1 crear un nuevo pedido cuyos datos sean hijos del nodo \"pedidos/1\" sin necesidad de haber creado previamente los nodos intermedios. Crear y actualizar datos \u00b6 Para modificar un nodo usamos setValue(<nuevovalor>) sobre su referencia. Este m\u00e9todo es destructivo, ya que sustituye completamente el valor actual del nodo, incluso aunque este tenga otros nodos hijos. Por ejemplo: 1 2 3 4 5 6 7 let db = Database . database () let nombreRef = db . reference ( withPath : \"personas/jap2/nombre\" ) //El nombre cambia de Juan a John nombreRef . setValue ( \"John\" ) //CUIDADO, sustituye el valor de \"personas\", con todo lo que hay por debajo let personasRef = db . reference ( withPath : \"personas\" ) personasRef . setValue ( \"La que has liao, pollito\" ) N\u00f3tese que el segundo cambio modifica el valor de un nodo compuesto, sustituyendo todo lo que hay \"por debajo\", as\u00ed que el \u00e1rbol quedar\u00eda 1 2 3 { \"personas\" : \"La que has liao, pollito\" } Tambi\u00e9n podemos crear un nodo aunque los nodos intermedios no existan 1 2 3 4 self . db = Database . database () //Este nodo no existe, pero vamos a usar la referencia para crear un valor let mlmj15 = db . reference ( withPath : \"personas/mlmj15\" ) mlmj15 . setValue ([ \"nombre\" : \"Mar\u00eda Luisa\" , \"apellidos\" : \"Mar\u00edn Ju\u00e1rez\" ]) El resultado ser\u00eda: 1 2 3 4 5 6 7 8 { \"personas\" : { \"mlmj15\" : { \"apellidos\" : \"Mar\u00edn Ju\u00e1rez\" , \"nombre\" : \"Mar\u00eda Luisa\" } } } En los ejemplos anteriores hemos asignado un nuevo valor que es un dato primitivo, pero tambi\u00e9n podr\u00eda ser asignar un valor compuesto, basta con pasar un diccionario . Por ejemplo, Podr\u00edamos cambiar los datos de \"mlmj15\" con: 1 2 3 let db = Database . database () let ref = db . reference ( withPath : \"personas/mlmj15\" ) ref . setValue ([ \"nombre\" : \"Mari Loli\" , \"apellidos\" : \"Mart\u00ednez Ja\u00e9n\" ]) En lugar de sobreescribir totalmente un nodo podemos actualizar solo algunas de sus propiedades con updateChildValues 1 2 3 let db = Database . database () let ref = db . reference ( withPath : \"personas/mlmj15\" ) ref . updateChildValues ([ \"nombre\" : \"M.L.\" ]) En este ejemplo estamos usando un identificador generado manualmente para cada persona, pero en muchos casos necesitaremos generar el identificador autom\u00e1ticamente. Podemos hacerlo con childByAutoId . 1 2 3 4 let db = Database . database () let personasRef = db . reference ( withPath : \"personas\" ) let nuevoIdRef = personasRef . childByAutoId () nuevoIdRef . setValue ([ \"nombre\" : \"Luis Ricardo\" , \"apellidos\" : \"Borriquero\" ]) quedando algo como: 1 2 3 4 5 6 7 8 9 { \"personas\" : { \"L33iv1bhzKkFkQd_ff4\" : { \"apellidos\" : \"Borriquero\" , \"nombre\" : \"Luis Ricardo\" }, ... } } El algoritmo de generaci\u00f3n de ids asegura que no va a haber colisiones entre los identificadores generados por los distintos clientes. Adem\u00e1s el id incluye un timestamp , de modo que si ordenamos por id estamos ordenando impl\u00edcitamente por orden de inserci\u00f3n en la base de datos. Finalmente, podemos borrar datos con removeValue() . Tambi\u00e9n podr\u00edamos hacer setValue(nil) , o poner a nil alguna propiedad en updateChildValues . Consultas \u00b6 La realtime Database , como su propio nombre indica, tiene funcionalidades apropiadas para aplicaciones que necesitan datos en tiempo real. En concreto podemos escuchar los cambios en los datos . Como luego veremos podemos usar este API tambi\u00e9n para hacer consultas al estilo m\u00e1s cl\u00e1sico, que simplemente devuelvan el estado actual de la BD. Para observar los cambios en los datos de un nodo, incluyendo tambi\u00e9n todos los nodos que hay \"por debajo\", podemos usar observe(_,withBlock:) , donde el \u00faltimo par\u00e1metro es una clausura a ejecutar cuando se produzca el evento. Por ejemplo: 1 2 3 4 5 6 let db = Database . database () let personasRef = db . reference ( withPath : \"personas\" ) personasRef . observe (. value ) { snapshot in print ( \"Algo ha cambiado en \\( snapshot . value ) \" ) } El par\u00e1metro de la clausura es un objeto de tipo DataSnapshot , que representa un snapshot de un fragmento de datos en un determinado momento. Hay que llevar cuidado con el nivel en el que estamos escuchando, ya que se detectar\u00e1 cualquier cambio en los niveles que hay por debajo y esto puede ser costoso para los niveles superiores del \u00e1rbol. La clausura se llamar\u00e1 una vez con el valor actual de la BD y a partir de ese momento, de nuevo cada vez que se produzca un cambio. Para dejar de \"escuchar\" los cambios podemos usar removeObserverWithHandle() . A este m\u00e9todo hay que pasarle el handle del listener creado por observe . Este handle lo devuelve el m\u00e9todo observe , aunque en el ejemplo anterior hemos ignorado el valor. De modo que har\u00edamos algo como: 1 2 3 4 5 6 7 8 9 ... //a\u00f1adimos el \"listener\" y nos guardamos el handle let handle = personasRef . observe (. value ) { ... } //eliminamos el \"listener\" anterior usando el handle personasRef . removeObserver ( withHandle : handle ) //tambi\u00e9n podr\u00edamos hacer esto para eliminar todos los listener sobre personasRef personasRef . removeAllObservers () Podemos escuchar otros eventos, no solo los cambios de valor. En concreto, podemos saber cu\u00e1ndo ha cambiado alg\u00fan hijo de un nodo dado (ha sido a\u00f1adido, modificado o borrado). En ese caso el snapshot solo contendr\u00e1 el nodo que ha cambiado. Por ejemplo, as\u00ed podr\u00edamos saber si ha sido insertado un nuevo nodo que sea hijo del nodo \"personas\": 1 2 3 4 5 6 self . db = Database . database () let personasRef = db . reference ( withPath : \"personas\" ) personasRef . observe (. childAdded ) { snapshot in print ( \" \\( snapshot . key ) = \\( snapshot . value ) \" ) } Tambi\u00e9n podemos hacer consultas m\u00e1s cl\u00e1sicas, en las que simplemente queremos conocer el estado actual de la base de datos pero no nos interesan los sucesivos cambios. Podemos hacerlo sustituyendo observe por observeSingleEvent . Por lo dem\u00e1s el c\u00f3digo es igual: 1 2 3 4 5 6 self . db = Database . database () let personasRef = db . reference ( withPath : \"personas\" ) personasRef . observeSingleEvent (. childAdded ) { snapshot in print ( \" \\( snapshot . key ) = \\( snapshot . value ) \" ) }","title":"Persistencia en Firebase"},{"location":"cap11/3_persistencia/#estructurar-los-datos","text":"Como ya hemos comentado, las dos bases de datos disponibles en Firebase son NoSQL. Esto quiere decir que los datos no tienen la divisi\u00f3n habitual en tablas a la que estamos acostumbrados en bases de datos relacionales. La base de datos tampoco se ocupa de comprobar autom\u00e1ticamente la consistencia o la integridad de los datos, quedando esta tarea en manos de la aplicaci\u00f3n. En la realtime database todos los datos est\u00e1n contenidos en un \u00fanico \"\u00e1rbol\" de pares clave-valor. Los valores pueden ser primitivos (n\u00fameros, cadenas o valores booleanos) o pueden ser valores compuestos a su vez de pares clave-valor. Por ejemplo podr\u00edamos tener algo como: 1 2 3 4 5 6 7 8 9 10 11 12 { \"personas\" : { \"jap2\" : { \"nombre\" : \"Juan\" , \"apellidos\" : \"Arriquitaun P\u00e9rez\" }, \"ems21\" : { \"nombre\" : \"Eva\" , \"apellidos\" : \"Mar\u00edn Salgado\" } } } En este caso el \u00e1rbol contiene un \u00fanico par clave/valor en su nivel superior. El valor asociado a la clave \"personas\" es compuesto y consiste de dos pares cuyas claves son \"jap2\" y \"ems21\", y as\u00ed sucesivamente. N\u00f3tese que la clave se separa del valor por \":\", que un par se separa del siguiente con una coma y que los valores compuestos se delimitan entre llaves. Es decir, es un formato de datos muy similar a JSON, aunque en JSON se pueden representar listas de datos con [] y esa posibilidad no existe aqu\u00ed. N\u00f3tese que, al contrario que en las bases de datos relacionales no existe un esquema inicial que restrinja el formato de los datos. Mientras se respete la estructura b\u00e1sica de pares clave/valor los datos tienen un formato libre. Por ejemplo no necesariamente tendr\u00edamos que tener propiedad \"nombre\" para todas las personas de la BD, o podr\u00edamos tener alguna propiedad m\u00e1s para algunas personas s\u00ed y para otras no. Al no existir tablas ni relaciones entre ellas, la forma m\u00e1s habitual de representar las relaciones entre datos es \"embeber\" unos datos dentro de otros. Por ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 { \"personas\" : { \"ems21\" : { \"apellidos\" : \"Mar\u00edn Salgado\" , \"nombre\" : \"Eva\" , \"mensajes\" : { \"m1\" : { \"texto\" : \"Hola amigos\" , \"timestamp\" : 19029898493 }, \"m2\" : { \"texto\" : \"\u00bfNo me contesta nadie? :(\" , \"timestamp\" : 20458569556 } } }, \"jap2\" : { \"apellidos\" : \"Arriquitaun P\u00e9rez\" , \"direccion\" : { \"calle\" : \"Pez, 25\" , \"localidad\" : \"Madrid\" }, \"mensajes\" : { \"m3\" : { \"texto\" : \"Hola, s\u00ed!!\" \"timestamp\" : 21020129382 } }, \"nombre\" : \"Juan\" } } } En el c\u00f3digo anterior podemos ver algunos de ejemplos de lo que en bases de datos relaciones ser\u00edan precisamente relaciones. Por un lado una relaci\u00f3n 1:1 entre \"persona\" y \"direccion\", que se reperesenta aqu\u00ed con la propiedad compuesta \"direccion\" dentro de la persona. Por otro lado una relaci\u00f3n 1:N entre \"persona\" y \"mensajes\", que se representa de la misma forma, guardando los \"mensajes\" dentro de la \"persona\". El problema de las estructuras de datos anidadas es a la hora de sacar la informaci\u00f3n de la BD. Como veremos, con Firebase podemos listar y filtrar de forma sencilla todos los nodos hijos de un nodo dado (por ejemplo obtener todos los mensajes de la persona \"ems21\" ordenados por timestamp ). El problema lo tendr\u00edamos si quisi\u00e9ramos obtener una lista de todos los mensajes independientemente de qui\u00e9n los ha enviado, que con la estructura de datos anterior requerir\u00eda ejecutar una consulta por cada usuario para finalmente unir todos los resultados y ordenarlos. Este problema se puede resolver desnormalizando los datos, es decir, duplicando la informaci\u00f3n. Adem\u00e1s de la estructura anterior podr\u00edamos tener repetidos por otro lado todos los mensajes dentro de un nodo \"mensajes\" independientemente de qui\u00e9n los haya enviado: 1 2 3 4 5 6 7 8 9 { \"personas\" : { //Igual que antes, personas con sus mensajes } \"mensajes\" : { //Aqu\u00ed todos los mensajes de todos los usuarios } }","title":"Estructurar los datos"},{"location":"cap11/3_persistencia/#referencias","text":"Un concepto fundamental y necesario para poder leer y escribir datos es el de referencia . Una referencia representa un nodo del \u00e1rbol de datos. Con los m\u00e9todos del API podemos obtener directamente una referencia a un nodo cualquiera si conocemos su path desde la ra\u00edz. O bien podemos partir de una referencia que ya tengamos a un nodo y movernos a uno de sus hijos. Una vez obtenida la referencia al nodo que nos interesa, podremos leer su estado/modificarlo con otros m\u00e9todos del API. Por ejemplo supongamos que tenemos la estructura de datos en Firebase que vimos en el apartado anterior. 1 2 3 4 5 6 7 8 9 10 11 12 { \"personas\" : { \"jap2\" : { \"nombre\" : \"Juan\" , \"apellidos\" : \"Arriquitaun P\u00e9rez\" }, \"ems21\" : { \"nombre\" : \"Eva\" , \"apellidos\" : \"Mar\u00edn Salgado\" } } } Para obtener una referencia a un nodo, lo primero es obtener la base de datos en s\u00ed, a la que accedemos con Database.database() . A partir de aqu\u00ed: El nodo ra\u00edz lo podemos obtener con reference() , y podemos ir bajando por los hijos con child() , por ejemplo: 1 2 3 4 5 6 //El \u00e1rbol completo, dicho de otro modo el nodo ra\u00edz let rootRef = Database . database (). reference () //El nodo \"personas\" let personasRef = rootRef . child ( \"personas\" ) //El nodo \"nombre\" perteneciente a \"jap2\" let nombreRef = personasRef . child ( \"jap2\" ). child ( \"nombre\" ) Tambi\u00e9n podemos acceder a un nodo con su path desde el nodo ra\u00edz, para ello usamos el m\u00e9todo reference(withPath:) , por ejemplo: 1 2 3 let db = Database . database () //El nodo \"nombre\" perteneciente a \"jap2\" let nombreRef = db . reference ( withPath : \"personas/jap2/nombre\" ) N\u00f3tese que podemos obtener una referencia a un nodo aunque este no exista todav\u00eda en la base de datos. Por ejemplo, esto ser\u00eda v\u00e1lido en el ejemplo que estamos siguiendo, aunque en la BD no hay nada relativo a pedidos: 1 let ref = db . reference ( withPath ( \"pedidos/1\" )) Esto nos permitir\u00e1 crear un nuevo pedido cuyos datos sean hijos del nodo \"pedidos/1\" sin necesidad de haber creado previamente los nodos intermedios.","title":"Referencias"},{"location":"cap11/3_persistencia/#crear-y-actualizar-datos","text":"Para modificar un nodo usamos setValue(<nuevovalor>) sobre su referencia. Este m\u00e9todo es destructivo, ya que sustituye completamente el valor actual del nodo, incluso aunque este tenga otros nodos hijos. Por ejemplo: 1 2 3 4 5 6 7 let db = Database . database () let nombreRef = db . reference ( withPath : \"personas/jap2/nombre\" ) //El nombre cambia de Juan a John nombreRef . setValue ( \"John\" ) //CUIDADO, sustituye el valor de \"personas\", con todo lo que hay por debajo let personasRef = db . reference ( withPath : \"personas\" ) personasRef . setValue ( \"La que has liao, pollito\" ) N\u00f3tese que el segundo cambio modifica el valor de un nodo compuesto, sustituyendo todo lo que hay \"por debajo\", as\u00ed que el \u00e1rbol quedar\u00eda 1 2 3 { \"personas\" : \"La que has liao, pollito\" } Tambi\u00e9n podemos crear un nodo aunque los nodos intermedios no existan 1 2 3 4 self . db = Database . database () //Este nodo no existe, pero vamos a usar la referencia para crear un valor let mlmj15 = db . reference ( withPath : \"personas/mlmj15\" ) mlmj15 . setValue ([ \"nombre\" : \"Mar\u00eda Luisa\" , \"apellidos\" : \"Mar\u00edn Ju\u00e1rez\" ]) El resultado ser\u00eda: 1 2 3 4 5 6 7 8 { \"personas\" : { \"mlmj15\" : { \"apellidos\" : \"Mar\u00edn Ju\u00e1rez\" , \"nombre\" : \"Mar\u00eda Luisa\" } } } En los ejemplos anteriores hemos asignado un nuevo valor que es un dato primitivo, pero tambi\u00e9n podr\u00eda ser asignar un valor compuesto, basta con pasar un diccionario . Por ejemplo, Podr\u00edamos cambiar los datos de \"mlmj15\" con: 1 2 3 let db = Database . database () let ref = db . reference ( withPath : \"personas/mlmj15\" ) ref . setValue ([ \"nombre\" : \"Mari Loli\" , \"apellidos\" : \"Mart\u00ednez Ja\u00e9n\" ]) En lugar de sobreescribir totalmente un nodo podemos actualizar solo algunas de sus propiedades con updateChildValues 1 2 3 let db = Database . database () let ref = db . reference ( withPath : \"personas/mlmj15\" ) ref . updateChildValues ([ \"nombre\" : \"M.L.\" ]) En este ejemplo estamos usando un identificador generado manualmente para cada persona, pero en muchos casos necesitaremos generar el identificador autom\u00e1ticamente. Podemos hacerlo con childByAutoId . 1 2 3 4 let db = Database . database () let personasRef = db . reference ( withPath : \"personas\" ) let nuevoIdRef = personasRef . childByAutoId () nuevoIdRef . setValue ([ \"nombre\" : \"Luis Ricardo\" , \"apellidos\" : \"Borriquero\" ]) quedando algo como: 1 2 3 4 5 6 7 8 9 { \"personas\" : { \"L33iv1bhzKkFkQd_ff4\" : { \"apellidos\" : \"Borriquero\" , \"nombre\" : \"Luis Ricardo\" }, ... } } El algoritmo de generaci\u00f3n de ids asegura que no va a haber colisiones entre los identificadores generados por los distintos clientes. Adem\u00e1s el id incluye un timestamp , de modo que si ordenamos por id estamos ordenando impl\u00edcitamente por orden de inserci\u00f3n en la base de datos. Finalmente, podemos borrar datos con removeValue() . Tambi\u00e9n podr\u00edamos hacer setValue(nil) , o poner a nil alguna propiedad en updateChildValues .","title":"Crear y actualizar datos"},{"location":"cap11/3_persistencia/#consultas","text":"La realtime Database , como su propio nombre indica, tiene funcionalidades apropiadas para aplicaciones que necesitan datos en tiempo real. En concreto podemos escuchar los cambios en los datos . Como luego veremos podemos usar este API tambi\u00e9n para hacer consultas al estilo m\u00e1s cl\u00e1sico, que simplemente devuelvan el estado actual de la BD. Para observar los cambios en los datos de un nodo, incluyendo tambi\u00e9n todos los nodos que hay \"por debajo\", podemos usar observe(_,withBlock:) , donde el \u00faltimo par\u00e1metro es una clausura a ejecutar cuando se produzca el evento. Por ejemplo: 1 2 3 4 5 6 let db = Database . database () let personasRef = db . reference ( withPath : \"personas\" ) personasRef . observe (. value ) { snapshot in print ( \"Algo ha cambiado en \\( snapshot . value ) \" ) } El par\u00e1metro de la clausura es un objeto de tipo DataSnapshot , que representa un snapshot de un fragmento de datos en un determinado momento. Hay que llevar cuidado con el nivel en el que estamos escuchando, ya que se detectar\u00e1 cualquier cambio en los niveles que hay por debajo y esto puede ser costoso para los niveles superiores del \u00e1rbol. La clausura se llamar\u00e1 una vez con el valor actual de la BD y a partir de ese momento, de nuevo cada vez que se produzca un cambio. Para dejar de \"escuchar\" los cambios podemos usar removeObserverWithHandle() . A este m\u00e9todo hay que pasarle el handle del listener creado por observe . Este handle lo devuelve el m\u00e9todo observe , aunque en el ejemplo anterior hemos ignorado el valor. De modo que har\u00edamos algo como: 1 2 3 4 5 6 7 8 9 ... //a\u00f1adimos el \"listener\" y nos guardamos el handle let handle = personasRef . observe (. value ) { ... } //eliminamos el \"listener\" anterior usando el handle personasRef . removeObserver ( withHandle : handle ) //tambi\u00e9n podr\u00edamos hacer esto para eliminar todos los listener sobre personasRef personasRef . removeAllObservers () Podemos escuchar otros eventos, no solo los cambios de valor. En concreto, podemos saber cu\u00e1ndo ha cambiado alg\u00fan hijo de un nodo dado (ha sido a\u00f1adido, modificado o borrado). En ese caso el snapshot solo contendr\u00e1 el nodo que ha cambiado. Por ejemplo, as\u00ed podr\u00edamos saber si ha sido insertado un nuevo nodo que sea hijo del nodo \"personas\": 1 2 3 4 5 6 self . db = Database . database () let personasRef = db . reference ( withPath : \"personas\" ) personasRef . observe (. childAdded ) { snapshot in print ( \" \\( snapshot . key ) = \\( snapshot . value ) \" ) } Tambi\u00e9n podemos hacer consultas m\u00e1s cl\u00e1sicas, en las que simplemente queremos conocer el estado actual de la base de datos pero no nos interesan los sucesivos cambios. Podemos hacerlo sustituyendo observe por observeSingleEvent . Por lo dem\u00e1s el c\u00f3digo es igual: 1 2 3 4 5 6 self . db = Database . database () let personasRef = db . reference ( withPath : \"personas\" ) personasRef . observeSingleEvent (. childAdded ) { snapshot in print ( \" \\( snapshot . key ) = \\( snapshot . value ) \" ) }","title":"Consultas"},{"location":"cap11/4_ejercicios/","text":"En las plantillas de la sesi\u00f3n hay un proyecto Xcode con las librer\u00edas de Firebase ya instaladas y configuradas. El proyecto est\u00e1 vinculado con una aplicaci\u00f3n ya dada de alta en el servidor de Firebase. IMPORTANTE: para trabajar con el proyecto, abrir el .xcworkspace , NO el .xcodeproj que abrimos habitualmente. Al abrir el workspace ver\u00e9is dos proyectos, uno con la app en s\u00ed, llamado ChatFirebase y otro con las librer\u00edas auxiliares llamado pods . Tras abrir el workspace lo primero que deber\u00edais hacer es Product > Build . El objetivo es desarrollar un peque\u00f1o chat con la realtime database . La plantilla ya tiene la interfaz hecha y hay que a\u00f1adirle el c\u00f3digo de Firebase. Login/logout (0,5 puntos) \u00b6 Pantalla inicial: \u00b6 En la pantalla inicial de la app hay un formulario para hacer login. A\u00f1ade el c\u00f3digo necesario para que cuando se pulse sobre el bot\u00f3n \"Entrar\" se haga login en Firebase . Si el login ha tenido \u00e9xito habr\u00e1 que saltar a la segunda pantalla por el segue llamado \"login\" 1 performSegue ( withIdentifier : \"login\" , sender : self ) Segunda pantalla \u00b6 En el outlet usuarioLabel deber\u00eda aparecer el login del usuario que se ha autentificado. A\u00f1ade el c\u00f3digo necesario para mostrar el email del usuario actual de Firebase en el usuarioLabel . Puedes hacerlo en el m\u00e9todo viewWillAppear del ChatViewController . Finalmente, a\u00f1ade el c\u00f3digo necesario para que al pulsar sobre Salir se haga logout en Firebase. Mensajes del chat (1 punto) \u00b6 Usaremos la siguiente estructura para almacenar los mensajes del chat: 1 2 3 4 5 6 7 8 9 10 11 12 { \"mensajes\" : { \"1jdakdueidas\" : { \"texto\" : \"hola qu\u00e9 tal\" , \"usuario\" : \"pepe@ua.es\" }, \"uiusd_ur48850_d\" : { \"texto\" : \"bien,y t\u00fa?\" , \"usuario\" : \"pepa@ua.es\" } } } donde los identificadores de mensaje deber\u00edan ser generados autom\u00e1ticamente por la base de datos con childByAutoId() Llevad mucho cuidado, ya que con vuestro usuario ten\u00e9is permiso total para escribir en la base de datos, por lo que por error podr\u00edais borrar los mensajes enviados por los dem\u00e1s. Para que funcione el chat hay que implementar dos funcionalidades: Que cuando se pulse sobre \"Enviar\" se guarde el mensaje en la BD. Usando el API de la base de datos habr\u00e1 que: Obtener la referencia al nodo \"mensajes\" Generar la referencia a un nuevo nodo id hijo de la referencia anterior con childByAutoId() Fijar el valor de este nuevo nodo con setValue() a un diccionario Swift con las claves \"texto\" y \"usuario\" y que contenga el texto del mensaje y el email del usuario actual de Firebase. Con el HTML que se incluye en las plantillas pod\u00e9is ver el estado actual de la BD y pod\u00e9is comprobar si se ha insertado correctamente vuestro mensaje Que cuando alguien env\u00eda un mensaje al chat este aparezca en la tabla Recibir el mensaje: en el viewWillAppear del ChatViewController a\u00f1adir un listener para que escuche el evento .childAdded sobre el nodo \"mensajes\" Ten en cuenta que el c\u00f3digo que recibe el evento recibe un par\u00e1metro snapshot con los nuevos valores en el campo value . En nuestro caso ser\u00e1 un diccionario con el texto y el usuario. Podemos hacer el cast a un diccionario con claves y valores String para poder usarlo en el c\u00f3digo, algo como: 1 2 3 if let valor = snapshot . value , let v = valor as ? [ String : String ] { //Aqu\u00ed ya podr\u00edamos acceder a los valores con v[\"texto\"] y v[\"usuario\"] } Cuando se reciba el evento, mostrar el mensaje en la tabla. Con el texto del mensaje y el email del usuario construir un struct de tipo Mensaje y a\u00f1adirlo al array self.mensajes del ChatViewController . Para que aparezca visualmente en la tabla tienes adem\u00e1s que a\u00f1adir una fila en la posici\u00f3n correspondiente: 1 2 3 let indexPath = IndexPath ( row : self . mensajes . count - 1 , section : 0 ) self . miTabla . insertRows ( at : [ indexPath ], with : UITableViewRowAnimation . bottom )","title":"Ejercicios"},{"location":"cap11/4_ejercicios/#loginlogout-05-puntos","text":"","title":"Login/logout (0,5 puntos)"},{"location":"cap11/4_ejercicios/#pantalla-inicial","text":"En la pantalla inicial de la app hay un formulario para hacer login. A\u00f1ade el c\u00f3digo necesario para que cuando se pulse sobre el bot\u00f3n \"Entrar\" se haga login en Firebase . Si el login ha tenido \u00e9xito habr\u00e1 que saltar a la segunda pantalla por el segue llamado \"login\" 1 performSegue ( withIdentifier : \"login\" , sender : self )","title":"Pantalla inicial:"},{"location":"cap11/4_ejercicios/#segunda-pantalla","text":"En el outlet usuarioLabel deber\u00eda aparecer el login del usuario que se ha autentificado. A\u00f1ade el c\u00f3digo necesario para mostrar el email del usuario actual de Firebase en el usuarioLabel . Puedes hacerlo en el m\u00e9todo viewWillAppear del ChatViewController . Finalmente, a\u00f1ade el c\u00f3digo necesario para que al pulsar sobre Salir se haga logout en Firebase.","title":"Segunda pantalla"},{"location":"cap11/4_ejercicios/#mensajes-del-chat-1-punto","text":"Usaremos la siguiente estructura para almacenar los mensajes del chat: 1 2 3 4 5 6 7 8 9 10 11 12 { \"mensajes\" : { \"1jdakdueidas\" : { \"texto\" : \"hola qu\u00e9 tal\" , \"usuario\" : \"pepe@ua.es\" }, \"uiusd_ur48850_d\" : { \"texto\" : \"bien,y t\u00fa?\" , \"usuario\" : \"pepa@ua.es\" } } } donde los identificadores de mensaje deber\u00edan ser generados autom\u00e1ticamente por la base de datos con childByAutoId() Llevad mucho cuidado, ya que con vuestro usuario ten\u00e9is permiso total para escribir en la base de datos, por lo que por error podr\u00edais borrar los mensajes enviados por los dem\u00e1s. Para que funcione el chat hay que implementar dos funcionalidades: Que cuando se pulse sobre \"Enviar\" se guarde el mensaje en la BD. Usando el API de la base de datos habr\u00e1 que: Obtener la referencia al nodo \"mensajes\" Generar la referencia a un nuevo nodo id hijo de la referencia anterior con childByAutoId() Fijar el valor de este nuevo nodo con setValue() a un diccionario Swift con las claves \"texto\" y \"usuario\" y que contenga el texto del mensaje y el email del usuario actual de Firebase. Con el HTML que se incluye en las plantillas pod\u00e9is ver el estado actual de la BD y pod\u00e9is comprobar si se ha insertado correctamente vuestro mensaje Que cuando alguien env\u00eda un mensaje al chat este aparezca en la tabla Recibir el mensaje: en el viewWillAppear del ChatViewController a\u00f1adir un listener para que escuche el evento .childAdded sobre el nodo \"mensajes\" Ten en cuenta que el c\u00f3digo que recibe el evento recibe un par\u00e1metro snapshot con los nuevos valores en el campo value . En nuestro caso ser\u00e1 un diccionario con el texto y el usuario. Podemos hacer el cast a un diccionario con claves y valores String para poder usarlo en el c\u00f3digo, algo como: 1 2 3 if let valor = snapshot . value , let v = valor as ? [ String : String ] { //Aqu\u00ed ya podr\u00edamos acceder a los valores con v[\"texto\"] y v[\"usuario\"] } Cuando se reciba el evento, mostrar el mensaje en la tabla. Con el texto del mensaje y el email del usuario construir un struct de tipo Mensaje y a\u00f1adirlo al array self.mensajes del ChatViewController . Para que aparezca visualmente en la tabla tienes adem\u00e1s que a\u00f1adir una fila en la posici\u00f3n correspondiente: 1 2 3 let indexPath = IndexPath ( row : self . mensajes . count - 1 , section : 0 ) self . miTabla . insertRows ( at : [ indexPath ], with : UITableViewRowAnimation . bottom )","title":"Mensajes del chat (1 punto)"},{"location":"cap2/2.1_intro_SQLite/","text":"Introducci\u00f3n a SQLite en iOS \u00b6 En iOS no hay ning\u00fan framework est\u00e1ndar para trabajar con SQLite de forma nativa. Lo m\u00e1s habitual es usar directamente el API C de la librer\u00eda . Al ser C un subconjunto de Objective-C (e interoperable con Swift) usar este API no es mayor problema, salvo por el \u201cengorro\u201d de tener que emplear funcionalidades de bajo nivel y tipos de datos de C ( char * en lugar de String , por ejemplo). Como vamos a ver, el API es considerablemente de nivel m\u00e1s bajo que los que hab\u00e9is usado en Android. Es muy improbable que en el futuro aparezca en iOS un API SQLite de nivel m\u00e1s alto, ya que Apple recomienda el uso del framework \"Core data\" sobre el uso directo de SQLite (como veremos, Core Data usa habitualmente SQLite de modo interno). No obstante, para casos de uso relativamente sencillos SQLite va a ser una alternativa mucho m\u00e1s ligera en recursos que Core Data. Adem\u00e1s SQLite supone una barrera de entrada bastante baja para cualquier desarrollador habituado a trabajar con SQL y bases de datos, cosa que no se puede decir de Core Data. Configurar el proyecto \u00b6 Para poder usar SQLite en un proyecto iOS primero hay que a\u00f1adir manualmente la librer\u00eda , no se a\u00f1ade autom\u00e1ticamente al contrario que otros frameworks . Seleccionamos el icono del proyecto (el azul) y en las propiedades del proyecto, opci\u00f3n General , al final de las opciones en Linked frameworks and libraries , (Xcode<11) o Frameworks, Libraries and Embedded Content (Xcode>=11) pulsar sobre + y a\u00f1adir libsqlite3.tdb . Para poder usar c\u00f3digo C en un proyecto Swift necesitamos crear un archivo especial con los include necesarios. Esto es lo que se llama un bridging header . Para crear el *bridging header * vamos en Xcode a File > New > File... y en las plantillas seleccionamos \"header file\". Le damos cualquier nombre, por ejemplo b-h.h . El contenido de la plantilla que crea Xcode no nos sirve, debemos borrarlo y sustituirlo simplemente por esto: 1 #include <sqlite3.h> Ahora debemos decirle a Xcode que este .h es efectivamente un bridging header . Para eso seleccionamos el icono del proyecto (el azul) y en el apartado build settings seleccionamos All y en el cuadro de b\u00fasqueda buscamos \"bridging header\". Aparecer\u00e1 una opci\u00f3n llamada Objective-C Bridging Header , que estar\u00e1 vac\u00eda, y en la que debemos escribir el nombre de nuestro b-h.h (si lo has metido en una carpeta dentro del proyecto tendr\u00e1s que poner delante su nombre) Este proceso es mucho m\u00e1s simple cuando importamos directamente c\u00f3digo C u Obj-C a nuestro proyecto, ya que al a\u00f1adir el .c o .m Xcode lo detecta y crea y configura el bridging header autom\u00e1ticamente. No es este el caso, ya que aqu\u00ed estamos usando una librer\u00eda ya compilada. Incluir la base de datos en el proyecto \u00b6 La forma m\u00e1s t\u00edpica de incluir la base de datos en el proyecto es copiarla al bundle de la aplicaci\u00f3n. No arrastres el archivo desde el finder hasta la ventana de Xcode. Se copiar\u00e1 en el directorio del proyecto pero no en el bundle de la aplicaci\u00f3n Pulsa con el bot\u00f3n derecho sobre el proyecto y selecciona la opci\u00f3n de Add files to \"(nombre_del_proyecto)\" . En el cuadro de di\u00e1logo que aparecer\u00e1, seleccionar el archivo con la base de datos, pulsar sobre el bot\u00f3n Options y asegurarse de que est\u00e1 marcada la casilla Copy items if needed , para hacer una copia en el directorio del proyecto y no usar simplemente una referencia al archivo original. Manejar bases de datos desde la consola \u00b6 Aunque en el Mac no hay ninguna herramienta gr\u00e1fica por defecto para gestionar bases de datos SQLite s\u00ed hay preinstalada una herramienta en l\u00ednea de comandos: sqlite3 . Para abrir una base de datos, desde la terminal: 1 sqlite3 nombre_bd Se abrir\u00e1 un prompt donde podemos usar varios comandos, por ejemplo: .tables , para listar tablas .schema nombre_de_tabla para ver estructura de una tabla Se pueden teclear directamente sentencias SQL, termin\u00e1ndolas en `;``","title":"Introducci\u00f3n"},{"location":"cap2/2.1_intro_SQLite/#introduccion-a-sqlite-en-ios","text":"En iOS no hay ning\u00fan framework est\u00e1ndar para trabajar con SQLite de forma nativa. Lo m\u00e1s habitual es usar directamente el API C de la librer\u00eda . Al ser C un subconjunto de Objective-C (e interoperable con Swift) usar este API no es mayor problema, salvo por el \u201cengorro\u201d de tener que emplear funcionalidades de bajo nivel y tipos de datos de C ( char * en lugar de String , por ejemplo). Como vamos a ver, el API es considerablemente de nivel m\u00e1s bajo que los que hab\u00e9is usado en Android. Es muy improbable que en el futuro aparezca en iOS un API SQLite de nivel m\u00e1s alto, ya que Apple recomienda el uso del framework \"Core data\" sobre el uso directo de SQLite (como veremos, Core Data usa habitualmente SQLite de modo interno). No obstante, para casos de uso relativamente sencillos SQLite va a ser una alternativa mucho m\u00e1s ligera en recursos que Core Data. Adem\u00e1s SQLite supone una barrera de entrada bastante baja para cualquier desarrollador habituado a trabajar con SQL y bases de datos, cosa que no se puede decir de Core Data.","title":"Introducci\u00f3n a SQLite en iOS"},{"location":"cap2/2.1_intro_SQLite/#configurar-el-proyecto","text":"Para poder usar SQLite en un proyecto iOS primero hay que a\u00f1adir manualmente la librer\u00eda , no se a\u00f1ade autom\u00e1ticamente al contrario que otros frameworks . Seleccionamos el icono del proyecto (el azul) y en las propiedades del proyecto, opci\u00f3n General , al final de las opciones en Linked frameworks and libraries , (Xcode<11) o Frameworks, Libraries and Embedded Content (Xcode>=11) pulsar sobre + y a\u00f1adir libsqlite3.tdb . Para poder usar c\u00f3digo C en un proyecto Swift necesitamos crear un archivo especial con los include necesarios. Esto es lo que se llama un bridging header . Para crear el *bridging header * vamos en Xcode a File > New > File... y en las plantillas seleccionamos \"header file\". Le damos cualquier nombre, por ejemplo b-h.h . El contenido de la plantilla que crea Xcode no nos sirve, debemos borrarlo y sustituirlo simplemente por esto: 1 #include <sqlite3.h> Ahora debemos decirle a Xcode que este .h es efectivamente un bridging header . Para eso seleccionamos el icono del proyecto (el azul) y en el apartado build settings seleccionamos All y en el cuadro de b\u00fasqueda buscamos \"bridging header\". Aparecer\u00e1 una opci\u00f3n llamada Objective-C Bridging Header , que estar\u00e1 vac\u00eda, y en la que debemos escribir el nombre de nuestro b-h.h (si lo has metido en una carpeta dentro del proyecto tendr\u00e1s que poner delante su nombre) Este proceso es mucho m\u00e1s simple cuando importamos directamente c\u00f3digo C u Obj-C a nuestro proyecto, ya que al a\u00f1adir el .c o .m Xcode lo detecta y crea y configura el bridging header autom\u00e1ticamente. No es este el caso, ya que aqu\u00ed estamos usando una librer\u00eda ya compilada.","title":"Configurar el proyecto"},{"location":"cap2/2.1_intro_SQLite/#incluir-la-base-de-datos-en-el-proyecto","text":"La forma m\u00e1s t\u00edpica de incluir la base de datos en el proyecto es copiarla al bundle de la aplicaci\u00f3n. No arrastres el archivo desde el finder hasta la ventana de Xcode. Se copiar\u00e1 en el directorio del proyecto pero no en el bundle de la aplicaci\u00f3n Pulsa con el bot\u00f3n derecho sobre el proyecto y selecciona la opci\u00f3n de Add files to \"(nombre_del_proyecto)\" . En el cuadro de di\u00e1logo que aparecer\u00e1, seleccionar el archivo con la base de datos, pulsar sobre el bot\u00f3n Options y asegurarse de que est\u00e1 marcada la casilla Copy items if needed , para hacer una copia en el directorio del proyecto y no usar simplemente una referencia al archivo original.","title":"Incluir la base de datos en el proyecto"},{"location":"cap2/2.1_intro_SQLite/#manejar-bases-de-datos-desde-la-consola","text":"Aunque en el Mac no hay ninguna herramienta gr\u00e1fica por defecto para gestionar bases de datos SQLite s\u00ed hay preinstalada una herramienta en l\u00ednea de comandos: sqlite3 . Para abrir una base de datos, desde la terminal: 1 sqlite3 nombre_bd Se abrir\u00e1 un prompt donde podemos usar varios comandos, por ejemplo: .tables , para listar tablas .schema nombre_de_tabla para ver estructura de una tabla Se pueden teclear directamente sentencias SQL, termin\u00e1ndolas en `;``","title":"Manejar bases de datos desde la consola"},{"location":"cap2/2.2_API_SQLite/","text":"El API de SQLite \u00b6 Acceder a la BD \u00b6 Vamos a ver aqu\u00ed c\u00f3mo abrir la base de datos para comenzar a trabajar con ella. Abrir y cerrar la BD En el API C de SQLite la base de datos se representa en nuestro c\u00f3digo mediante un puntero a un struct de tipo sqlite3 . En swift podemos representar un puntero de C con el tipo OpaquePointer , as\u00ed que en nuestro c\u00f3digo tendremos algo como 1 var db : OpaquePointer ? = nil Para abrir la BD se usa la funci\u00f3n sqlite3_open , a la que hay que pasarle el path de la base de datos y la referencia a este struct 1 sqlite3_open ( path_db , & db ); Vamos a crear una clase DBManager en la que implementaremos los m\u00e9todos que interact\u00faan con la base de datos. En esta clase creamos una variable miembro privada para almacenar la referencia a la base de datos. 1 2 3 class DBManager { var db : OpaquePointer ? = nil } Podemos implementar un inicializador que abra la base de datos suponiendo que est\u00e1 incluida en el bundle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class DBManager { var db : OpaquePointer ? = nil init ( conDB nombreDB : String ) { if let dbPath = Bundle . main . path ( forResource : nombreDB , ofType : \"db\" ) { if sqlite3_open ( dbPath , & ( self . db )) == SQLITE_OK { print ( \"Base de datos \\( dbPath ) abierta OK\" ) } else { let error = String ( cString : sqlite3_errmsg ( db )) print ( \"Error al intentar abrir la BD: \\( error ) \" ) } } else { print ( \"El archivo no se encuentra\" ) } } } Del c\u00f3digo anterior debemos destacar los siguientes aspectos: Las llamadas al API de SQLite devuelven la constante SQLITE_OK si no ha habido error, as\u00ed que para saber si sqlite3_open ha tenido \u00e9xito comprobamos si ha devuelto este valor. Si se produce un error, para ver cu\u00e1l es podemos usar la funci\u00f3n sqlite3_errmsg , que devuelve el mensaje del error m\u00e1s reciente asociado a una llamada hecha al API de SQLite. Al ser c\u00f3digo C el mensaje de error se devuelve como un char * , ya que en C no existe el tipo String . En nuestro c\u00f3digo convertimos este tipo a un String de Swift, para poder tratarlo (imprimirlo, en nuestro caso). Esta conversi\u00f3n la hacemos con el inicializador String(cString:) A la inversa, las funciones C que requieren un char * como par\u00e1metro aceptan directamente un String de Swift. Esto por ejemplo pasa al hacer el sqlite3_open , que en realidad requiere que se le pase un char * con el path de la BD. Para cerrar la base de datos se usa la funci\u00f3n sqlite3_close() a la que se le pasa como par\u00e1metro el puntero al struct con la informaci\u00f3n de la base de datos. Abrir la BD con \u201cpermiso de escritura\u201d Un problema que tiene incluir f\u00edsicamente la base de datos en el bundle de la aplicaci\u00f3n es que este es de solo lectura. Eso quiere decir que no podr\u00edamos ejecutar consultas de actualizaci\u00f3n sobre la base de datos. La forma m\u00e1s habitual de resolver este problema es crear una copia de la base de datos en alg\u00fan directorio con permiso de escritura cuando se arranca la aplicaci\u00f3n. T\u00edpicamente se usa el directorio Documents ya que es el m\u00e1s apropiado para este prop\u00f3sito. Aqu\u00ed tenemos un m\u00e9todo que copia la BD del bundle al directorio Documents , si es que no se ha copiado ya: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func copyDB ( conNombre nombre : String )-> URL ? { let fileManager = FileManager . default let docsURL = fileManager . urls ( for : . documentDirectory , in : . userDomainMask )[ 0 ] let dbCopiaURL = docsURL . appendingPathComponent ( nombre ). appendingPathExtension ( \"db\" ) if fileManager . fileExists ( atPath : dbCopiaURL . path ) { return dbCopiaURL } else { if let dbOriginalURL = Bundle . main . url ( forResource : nombre , withExtension : \"db\" ) { if ( try ? fileManager . copyItem ( at : dbOriginalURL , to : dbCopiaURL )) != nil { return dbCopiaURL } else { return nil } } else { return nil } } } Tendremos que modificar el inicializador del apartado anterior para que llame a este m\u00e9todo y despu\u00e9s no abra la base de datos del bundle sino la de Documents : 1 2 3 4 5 6 7 8 9 class DBManager { var db : OpaquePointer ? = nil init ( conDB nombreDB : String ) { if let dbCopiaURL = copyDB ( conNombre : nombreDB ) { if sqlite3_open ( dbCopiaURL . path , & ( self . db )) == SQLITE_OK { print ( \"Base de datos \\( dbCopiaURL ) abierta OK\" ) } //contin\u00faa como antes... Consultas de selecci\u00f3n \u00b6 Compilar y ejecutar una consulta de selecci\u00f3n El esquema general para ejecutar una consulta de selecci\u00f3n y recorrer los registros resultantes es el siguiente: Compilar la query (convertirla de SQL en \"modo texto\" a un formato \"ejecutable\" por SQLite) Ir avanzando registro a registro por los resultados, mientras queden registros Obtener los campos que nos interesen del registro actual, sabiendo el n\u00famero de columna que ocupan. Las columnas empiezan en 0 Habitualmente \u201cempaquetaremos\u201d los valores del registro actual en un objeto o struct de Swift, e iremos construyendo una lista de resultados (un array es lo m\u00e1s sencillo). Liberar la memoria ocupada por la query compilada Vamos a ver un ejemplo de c\u00f3digo que implementa este esquema: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 let querySQL = \"SELECT * FROM Personas\" var statement : OpaquePointer ?; var lista : [ Persona ] = []; let result = sqlite3_prepare_v2 ( db , querySQL , - 1 , & statement , nil ) if ( result == SQLITE_OK ) { while ( sqlite3_step ( statement ) == SQLITE_ROW ) { let id = sqlite3_column_int ( statement , 0 ) let nombre = String ( cString : sqlite3_column_text ( statement , 1 )) let persona = Persona ( id : Int ( id ), nombre : nombre ) lista . append ( persona ) } } sqlite3_finalize ( statement ); for p in lista { print ( \" \\( p . id ) \\( p . nombre ) \" ) } En la funci\u00f3n sqlite3_prepare_v2() Los dos primeros argumentos son el struct que representa la base de datos y la cadena con la query . Aunque en el ejemplo no usamos esta funcionalidad se podr\u00edan poner varias sentencias SQL en la misma cadena y compilar solo una de ellas. El tercer argumento de indica la longitud en caracteres que queremos tomar de la query (-1 indica leer toda la cadena). Con el \u00faltimo argumento SQLite nos informa qu\u00e9 parte de query queda por ejecutar, en este caso pasamos nil ya que no nos interesa esta funcionalidad. Vamos avanzando por los registros con sqlite_step() . Mientras que esta funci\u00f3n devuelva SQLITE_ROW tenemos una nueva fila y podemos obtener sus campos con sqlite_column_XXX() , donde XXX es el tipo de campo De nuevo tenemos el problema de que como el API de SQLite est\u00e1 en C, devuelve char * para los campos de tipo cadena, y no String por lo que debemos hacer la conversi\u00f3n con el inicializador String(cString:) Aqu\u00ed usamos la estrategia de \u201cempaquetar\u201d los datos obtenidos de la BD en un objeto y guardar todos los objetos en un array. Finalmente sqlite3_finalize libera la memoria ocupada por la query Fechas en SQLite SQLite no tiene el tipo fecha. Posibles alternativas son representar una fecha en formato cadena o bien como un entero, el t\u00edpico \" UNIX timestamp \" (n\u00famero de segundos transcurridos desde el 1 de enero de 1970). Por ejemplo si sabemos que la fecha est\u00e1 almacenada como un timestamp podr\u00edamos hacer algo como: 1 2 3 4 5 6 7 8 9 //supongamos que la columna 2 es una fecha en formato timestamp UNIX let unix_time = sqlite3_column_int ( statement , 2 ); //TimeInterval es equivalente a Double. Hacemos una conversi\u00f3n let fecha = Date ( timeIntervalSince1970 : TimeInterval ( valor )) //La clase DateFormatter nos permite mostrar una fecha let df = DateFormatter () //Hay una serie de estilos predefinidos df . dateStyle = . full print ( \" \\( df . string ( from : fecha )) \" ) En el ejemplo se usa la clase DateFormatter para mostrar la fecha, se puede configurar para variar el locale y el formato concreto. Hay una serie de formatos predefinidos ( .short , .medium , .full , ...) y tambi\u00e9n podemos especificar mediante una cadena de formato qu\u00e9 componentes queremos mostrar y en qu\u00e9 orden. Para m\u00e1s informaci\u00f3n consultar la documentaci\u00f3n de DateFormatter . Tambi\u00e9n podr\u00edamos almacenar las fechas en formato cadena (formato a\u00f1o-mes-dia horas:minutos:segundos ). Parsear las fechas ser\u00e1 algo m\u00e1s tedioso que con timestamps , pod\u00e9is consultar este ejemplo . Consultas con par\u00e1metros En el ejemplo del apartado anterior la consulta SQL era una cadena fija pero en muchos casos necesitaremos parametrizar la consulta (por ejemplo obtener todos los alumnos cuyo apellido empiece por una letra, o los nacidos despu\u00e9s de una fecha determinada). Aunque podemos construir el String concatenando subcadenas es m\u00e1s \"limpio\" usar par\u00e1metros, que adem\u00e1s nos protegen contra posibles intentos de inyecci\u00f3n SQL. Al igual que en la mayor\u00eda de BD los par\u00e1metros se especifican con el s\u00edmbolo ? 1 let querySQL = \"SELECT * FROM alumnos WHERE fecha_nacimiento < ?\" Para instanciar el par\u00e1metro con un determinado valor usaremos la familia de funciones sqlite3_bind_XXX , en la que las XXX indican el tipo de datos del par\u00e1metro ( int , double , text ,\u2026). Esta instanciaci\u00f3n se debe hacer despu\u00e9s de \"preparar\" la query con sqlite3_prepare_v2 pero antes de ejecutarla con sqlite3_step() . Por ejemplo, vamos a buscar todas las personas que tengan m\u00e1s de 18 a\u00f1os (cuya fecha de nacimiento sea anterior a la actual rest\u00e1ndole 18 a\u00f1os) 1 2 3 4 5 6 7 let querySQL = \"SELECT * FROM alumnos WHERE fecha_nacimiento<?\" var statement : OpaquePointer ? let result = sqlite3_prepare_v2 ( db , querySQL , - 1 , & statement , nil ) let cal = Calendar . current let hace18 = cal . date ( byAdding : Calendar . Component . year , value : - 18 , to : Date (), wrappingComponents : false ) sqlite3_bind_int ( statement , 1 , Int32 ( hace18 !. timeIntervalSince1970 )) N\u00f3tese que para instanciar un par\u00e1metro debemos conocer su posici\u00f3n y que las posiciones de los par\u00e1metros comienzan en 1 , no en 0. En SQLite tambi\u00e9n se pueden definir par\u00e1metros por nombre con el formato :nombre , por ejemplo 1 let querySQL = \"SELECT * FROM alumnos WHERE fecha_nacimiento < :fecha\" ; No obstante el API C no nos permite instanciar el par\u00e1metro directamente por nombre. Primero debemos obtener su posici\u00f3n con la funci\u00f3n sqlite3_bind_parameter_index(sentencia,nombre) y luego aplicar la ya conocida sqlite3_bind_XXX() . Consultas de actualizaci\u00f3n \u00b6 Como ya hemos comentado, para que se puedan ejecutar consultas de actualizaci\u00f3n sobre la base de datos esta tiene que estar almacenada en un directorio con permisos de escritura Las consultas de actualizaci\u00f3n se manejan de un modo similar a las de selecci\u00f3n: se preparan con sqlite3_prepare_v2() , se vinculan los par\u00e1metros si estos existen con sqlite3_bind_XXX() y se ejecutan con sqlite3_step() . Por supuesto en ellas no hay bucle para recorrer los resultados. 1 2 3 4 5 6 7 8 9 let querySQL = \"INSERT INTO alumnos (nombre, fecha_nacimiento) VALUES (?,?)\" var statement : OpaquePointer ? sqlite3_prepare_v2 ( db , querySQL , - 1 , & statement , nil ); sqlite3_bind_text ( statement , 1 , nombre , - 1 , nil ); sqlite3_bind_int ( statement , 2 , Int32 ( fechaNacimiento . timeIntervalSince1970 )); let result = sqlite3_step ( statement ); if ( result == SQLITE_DONE ) { print ( \"Registro almacenado OK\" ); } Como vemos, cuando se ejecuta con \u00e9xito una consulta de actualizaci\u00f3n, la ejecuci\u00f3n devuelve el valor SQLITE_DONE . N\u00f3tese que el sqlite3_bind_text tiene un par de par\u00e1metros adicionales con respecto a sqlite3_bind_int . En los casos m\u00e1s habituales se pasan siempre los valores -1 y nil respectivamente. Para ver m\u00e1s informaci\u00f3n sobre estos par\u00e1metros, consultar la documentaci\u00f3n de SQLite Podemos contar cu\u00e1ntas filas han sido afectadas por la consulta de actualizaci\u00f3n (en el ejemplo cu\u00e1ntas filas se han insertado, o sea 1) con la funci\u00f3n sqlite3_changes() a la que hay que pasarle el struct que representa a la base de datos: 1 2 3 var db : OpaquePointer ? ... print ( \"Filas afectadas: \\( sqlite3_changes ( db )) \" ;","title":"El API de SQLIte"},{"location":"cap2/2.2_API_SQLite/#el-api-de-sqlite","text":"","title":"El API de SQLite"},{"location":"cap2/2.2_API_SQLite/#acceder-a-la-bd","text":"Vamos a ver aqu\u00ed c\u00f3mo abrir la base de datos para comenzar a trabajar con ella.","title":"Acceder a la BD"},{"location":"cap2/2.2_API_SQLite/#consultas-de-seleccion","text":"","title":"Consultas de selecci\u00f3n"},{"location":"cap2/2.2_API_SQLite/#consultas-de-actualizacion","text":"Como ya hemos comentado, para que se puedan ejecutar consultas de actualizaci\u00f3n sobre la base de datos esta tiene que estar almacenada en un directorio con permisos de escritura Las consultas de actualizaci\u00f3n se manejan de un modo similar a las de selecci\u00f3n: se preparan con sqlite3_prepare_v2() , se vinculan los par\u00e1metros si estos existen con sqlite3_bind_XXX() y se ejecutan con sqlite3_step() . Por supuesto en ellas no hay bucle para recorrer los resultados. 1 2 3 4 5 6 7 8 9 let querySQL = \"INSERT INTO alumnos (nombre, fecha_nacimiento) VALUES (?,?)\" var statement : OpaquePointer ? sqlite3_prepare_v2 ( db , querySQL , - 1 , & statement , nil ); sqlite3_bind_text ( statement , 1 , nombre , - 1 , nil ); sqlite3_bind_int ( statement , 2 , Int32 ( fechaNacimiento . timeIntervalSince1970 )); let result = sqlite3_step ( statement ); if ( result == SQLITE_DONE ) { print ( \"Registro almacenado OK\" ); } Como vemos, cuando se ejecuta con \u00e9xito una consulta de actualizaci\u00f3n, la ejecuci\u00f3n devuelve el valor SQLITE_DONE . N\u00f3tese que el sqlite3_bind_text tiene un par de par\u00e1metros adicionales con respecto a sqlite3_bind_int . En los casos m\u00e1s habituales se pasan siempre los valores -1 y nil respectivamente. Para ver m\u00e1s informaci\u00f3n sobre estos par\u00e1metros, consultar la documentaci\u00f3n de SQLite Podemos contar cu\u00e1ntas filas han sido afectadas por la consulta de actualizaci\u00f3n (en el ejemplo cu\u00e1ntas filas se han insertado, o sea 1) con la funci\u00f3n sqlite3_changes() a la que hay que pasarle el struct que representa a la base de datos: 1 2 3 var db : OpaquePointer ? ... print ( \"Filas afectadas: \\( sqlite3_changes ( db )) \" ;","title":"Consultas de actualizaci\u00f3n"},{"location":"cap2/2.3_frameworks/","text":"Frameworks de terceros \u00b6 Ya hemos visto que no hay un API en Swift (ni en Objective-C) para usar SQLite y que tampoco es de esperar que aparezca ninguno, dado el \u00e9nfasis que Apple hace en Core Data para las tareas de persistencia. No obstante esto no ha impedido que aparezcan librer\u00edas de terceros implementando un API para SQLite que sea de m\u00e1s alto nivel y m\u00e1s sencillo de usar en iOS. Hay multitud de wrappers de SQLite en Swift. De ellos uno de los m\u00e1s conocidos es SQLite.swift . No obstante los frameworks m\u00e1s usados para SQLite siguen siendo Objective-C, el m\u00e1s conocido es probablemente FMDB . Vamos a ver una introducci\u00f3n muy b\u00e1sica a este framework Uso de FMDB en proyectos Swift \u00b6 Swift es una librer\u00eda hecha en Objective-C pero ya sabemos que podemos mezclar Objective-C con Swift en un proyecto. Instalaci\u00f3n de la librer\u00eda Aunque la forma recomendada para instalar FMDB en un proyecto es a trav\u00e9s del uso de CocoaPods probablemente es m\u00e1s simple importar directamente los fuentes. Para eso nos podemos bajar directamente el .zip de FMDB de su repositorio de Github . Una vez descomprimido el .zip vamos al directorio fmdb-master/src/fmdb e importamos todos los archivos de este directorio a nuestro proyecto (menos el .plist , que no es necesario). Al importarlos, Xcode detectar\u00e1 que son archivos en Objective-C y nos preguntar\u00e1 si queremos crear el \"bridging header\". Le decimos que s\u00ed y se crear\u00e1 el fichero vac\u00edo <nombre-del-proyecto>-Bridging-Header.h , en el que a\u00f1adiremos la siguiente l\u00ednea: 1 #import \"FMDB.h\" A partir de este momento ya podemos usar las clases de FMDB dentro de nuestro c\u00f3digo Swift El API de FMDB Vamos a ver unos cuantos ejemplos de uso de la librer\u00eda FMDB para que se vea que es bastante m\u00e1s f\u00e1cil de usar que el API C. La librer\u00eda tiene varias clases b\u00e1sicas (pod\u00e9is consultar online la referencia del API ). De ellas las dos m\u00e1s usadas en un c\u00f3digo t\u00edpico son: FMDatabase , que es un objeto que representa a la base de datos. Es la clase m\u00e1s importante y con la que se va a interactuar la mayor parte del tiempo. Se usa para abrir/cerrar la conexi\u00f3n y tambi\u00e9n para ejecutar las consultas. FMResultSet , que encapsula un conjunto de registros resultado de una consulta de selecci\u00f3n. Podemos ir iterando por el conjunto y obtener los campos del registro actual, al igual que con el API C, pero de forma mucho m\u00e1s sencilla: por ejemplo podemos obtener el valor de un campo por nombre, y las llamadas est\u00e1n bastante simplificadas para adaptarse mejor a los casos de uso m\u00e1s t\u00edpicos. Por ejemplo, veamos c\u00f3mo se abrir\u00eda una base de datos, se ejecutar\u00eda una consulta de selecci\u00f3n y se ir\u00eda iterando por el conjunto de registros resultante 1 2 3 4 5 6 7 8 9 10 11 12 13 let dbPath = Bundle . main . path ( forResource : \"prueba\" , ofType : \"db\" ) if let db = FMDatabase ( path : dbPath ) { if ( ! db . open ()) { print ( \"Error al abrir la bd: \\( db . lastErrorMessage ()) \" ) } else { if let resultSet = try ? db . executeQuery ( \"SELECT * FROM Personas\" , values : nil ) { while ( resultSet . next ()) { print ( resultSet . string ( forColumn : \"nombre\" )) } } } } Para inicializar la BD necesitamos el path y usamos el m\u00e9todo de clase databaseWithPath Abrir y cerrar la BD es tan sencillo como llamar a open y close . El m\u00e9todo open devuelve un valor booleano que indica si se ha abierto o no correctamente. En caso de error en una operaci\u00f3n de BD podemos acceder a m\u00e1s informaci\u00f3n sobre el mismo con los m\u00e9todos lastErrorMessage o lastErrorCode . Cuando se abre una BD que no existe, FMDB la crea autom\u00e1ticamente, se puede cambiar este comportamiento llamando a openWithFlags con los par\u00e1metros adecuados, en lugar de a open . Tambi\u00e9n se puede usar una BD en memoria si se le pasa NULL como path a databaseWithPath Las consultas se ejecutan con executeQuery y devuelven una instancia de la clase FMResultSet . Para iterar por el resultset usamos el m\u00e9todo next . Podemos obtener los campos del registro actual con una serie de m\u00e9todos XXXForColumn: , donde la parte inicial del nombre es el tipo de datos de la columna ( string , int , long , date ,\u2026). Obs\u00e9rvese adem\u00e1s que se accede a la columna por nombre y no por posici\u00f3n (aunque tambi\u00e9n se puede acceder por posici\u00f3n con XXXForColumnIndex: ). Por supuesto podemos ejecutar consultas con par\u00e1metros. El m\u00e9todo executeQuery: admite una lista de argumentos con los valores, por ejemplo: 1 2 let rs = db . executeQuery ( \"SELECT * FROM alumnos where fecha_nacimiento<?\" , values :[ fecha_ref ]; Para ejecutar una consulta de actualizaci\u00f3n se usa executeUpdate: en lugar de executeQuery . Tambi\u00e9n podemos usar de forma sencilla par\u00e1metros por nombre (algo que en el API C es un poco tedioso). Basta con crear un diccionario con los nombres de los par\u00e1metros como claves y los valores deseados 1 2 3 4 5 6 let query = \"INSERT INTO personas (dni, nombre) VALUES (:dni, :nombre)\" let datos = [ \"dni\" : \"1222333K\" , \"nombre\" : \"Pepito\" ] db . executeUpdate ( query , withParameterDictionary : datos )","title":"Frameworks para SQLite"},{"location":"cap2/2.3_frameworks/#frameworks-de-terceros","text":"Ya hemos visto que no hay un API en Swift (ni en Objective-C) para usar SQLite y que tampoco es de esperar que aparezca ninguno, dado el \u00e9nfasis que Apple hace en Core Data para las tareas de persistencia. No obstante esto no ha impedido que aparezcan librer\u00edas de terceros implementando un API para SQLite que sea de m\u00e1s alto nivel y m\u00e1s sencillo de usar en iOS. Hay multitud de wrappers de SQLite en Swift. De ellos uno de los m\u00e1s conocidos es SQLite.swift . No obstante los frameworks m\u00e1s usados para SQLite siguen siendo Objective-C, el m\u00e1s conocido es probablemente FMDB . Vamos a ver una introducci\u00f3n muy b\u00e1sica a este framework","title":"Frameworks de terceros"},{"location":"cap2/2.3_frameworks/#uso-de-fmdb-en-proyectos-swift","text":"Swift es una librer\u00eda hecha en Objective-C pero ya sabemos que podemos mezclar Objective-C con Swift en un proyecto.","title":"Uso de FMDB en proyectos Swift"},{"location":"cap2/2.4_ejercicios/","text":"Ejercicio de SQLite: app de tareas pendientes (5 puntos) \u00b6 En este ejercicio vamos a crear una peque\u00f1a aplicaci\u00f3n de gesti\u00f3n de tareas pendientes, en la que se puedan listar tareas y a\u00f1adir tareas nuevas. Cada tarea tiene un id (entero, autonum\u00e9rico), un titulo (cadena), un vencimiento (fecha) y una una descripcion (cadena). Las columnas est\u00e1n por este orden en la tabla. La base de datos ya est\u00e1 creada, y t\u00fa debes copiarla a tu proyecto como se explica a continuaci\u00f3n. Infraestructura b\u00e1sica (1 punto) \u00b6 Configurar el proyecto \u00b6 Crear un proyecto llamado TareasSQLite de tipo *Master-Detail Application * En la carpeta archivos SQLite de las plantillas hay unos cuantos recursos que debes copiar al proyecto Copia en el proyecto la base de datos tareas.db . NO LO HAGAS ARRASTRANDO , usa el men\u00fa File > Add files to TareasSQLite... y selecciona el archivo tareas.db . En el cuadro de di\u00e1logo de copia, pulsa sobre el boton options de la parte inferior y aseg\u00farate de que la casilla de Copy items if needed est\u00e1 marcada . En caso contrario est\u00e1s haciendo solo una referencia al archivo original, que se pierde si mueves el proyecto, y tampoco se sube al repositorio. Crea en el proyecto un DBManager.swift con el siguiente c\u00f3digo, es muy parecido al que tienes en los apuntes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import Foundation class DBManager { var db : OpaquePointer ? = nil init ( db nombreDB : String , reload : Bool ) { if let dbCopiaURL = copyDB ( conNombre : nombreDB , reload : reload ) { if sqlite3_open ( dbCopiaURL . path , & ( self . db )) == SQLITE_OK { print ( \"Base de datos \\( dbCopiaURL ) abierta OK\" ) } else { let error = String ( cString : sqlite3_errmsg ( db )) print ( \"Error al intentar abrir la BD: \\( error ) \" ) } } else { print ( \"El archivo no se encuentra\" ) } } deinit { sqlite3_close ( self . db ) } //Copia la base de datos desde el bundle al directorio Documents, para que se pueda modificar //si el par\u00e1metro \"machaca\" es true, copia la BD aunque ya est\u00e9 en Documents. //En una app normal esto no lo har\u00edamos cada vez que arranquemos, ya que se machacar\u00eda la BD func copyDB ( conNombre nombre : String , reload machaca : Bool )-> URL ? { let fileManager = FileManager . default let docsURL = fileManager . urls ( for : . documentDirectory , in : . userDomainMask )[ 0 ] let dbCopiaURL = docsURL . appendingPathComponent ( nombre ) let existe = fileManager . fileExists ( atPath : dbCopiaURL . path ) if existe && ! machaca { return dbCopiaURL } else { if let dbOriginalURL = Bundle . main . url ( forResource : nombre , withExtension : \"\" ) { if ( existe ) { try ! fileManager . removeItem ( at : dbCopiaURL ) } if ( try ? fileManager . copyItem ( at : dbOriginalURL , to : dbCopiaURL )) != nil { return dbCopiaURL } else { return nil } } else { return nil } } } } De momento, dar\u00e1 errores de compilaci\u00f3n porque todav\u00eda no has incluido SQLite en el proyecto. Ahora hay que configurar el proyecto para poder usar SQLite. A\u00f1ade la librer\u00eda libsqlite3.tbd y crea el Bridging Header seg\u00fan se explica en el apartado \"Configurar el proyecto\" de los apuntes. Para comprobar que funciona, introduce el siguiente c\u00f3digo en el m\u00e9todo viewDidLoad del MasterViewController 1 let manager = DBManager ( db : \"tareas.db\" , reload : false ) Si todo es correcto, en el log debe aparecer el mensaje \"Base de datos url_enormemente_larga_de_la_BD abierta OK\". Una vez que sepas que funciona, quita la l\u00ednea que has insertado en el viewDidLoad para que no interfiera con el resto del ejercicio. N\u00f3tese que como primer par\u00e1metro se pasa el nombre de la BD, y como segundo un booleano indicando si la copia de la BD de Documents se va a sobreescribir cada vez que se arranque la aplicaci\u00f3n (\u00fatil cuando en desarrollo estamos cambiando \u201cdesde fuera\u201d la BD para hacer pruebas) Si por alg\u00fan motivo cambias manualmente la estructura o el contenido de la base de datos, recuerda poner el par\u00e1metro reload a true la primera vez que ejecutes la aplicaci\u00f3n tras la modificaci\u00f3n C\u00f3digo base \u00b6 Crea una struct Swift llamada Tarea en un archivo Tarea.swift y a\u00f1\u00e1dele como propiedades: id de tipo Int titulo de tipo String vencimiento de tipo Date descripcion de tipo String Crea un archivo TareasManager.swift donde se defina una clase del mismo nombre, y que sea una subclase de DBManager . En los siguientes apartados implementaremos aqu\u00ed las operaciones con la tabla de tareas. Funcionalidad 1: Listar tareas (3 puntos) \u00b6 Implementar el listado en s\u00ed \u00b6 En TareasManager Implementa un m\u00e9todo listarTareas que debe hacer un SELECT de la tabla tareas ordenado por fecha de vencimiento y devolver un array de objetos Tarea . Ser\u00e1 muy similar al c\u00f3digo que sirve para listar personas en los apuntes . Recuerda que en la tabla tareas las columnas son los mismos campos que en la struct Tarea : id , titulo , vencimiento y descripcion . Para ir paso a paso, puedes implementar primero en TareasManager una versi\u00f3n inicial de listarTareas que solo saque de la BD el campo titulo (columna 1, de tipo cadena), y ponga el resto de campos a valores fijos y arbitrarios. Una vez lo tengas puedes probarlo en el MasterViewController . A\u00f1ade la siguiente propiedad para almacenar una referencia al TareasManager 1 var tm : TareasManager ! = nil y ahora en el viewDidLoad a\u00f1ade: 1 2 3 4 5 self . tm = TareasManager ( db : \"tareas.db\" , reload : false ) let lista = self . tm . listarTareas () for t in lista { print ( \" \\( t . titulo ) \" ); } Deber\u00edan salir los t\u00edtulos de 3 tareas distintas. Si esto va, ya sabes que la parte b\u00e1sica te funciona y ahora puedes a\u00f1adir en listarTareas el resto de campos: id , descripcion y vencimiento . Este \u00faltimo campo ten en cuenta que usa \u201ctiempo UNIX\u201d: n\u00famero de segundos transcurridos desde el 1/1/1970. Mostrar las tareas en la tabla \u00b6 Vamos a modificar el c\u00f3digo del viewDidLoad para integrarlo mejor con la plantilla que ha generado Xcode. Fijate que lo que nosotros definimos como lista la plantilla lo define en la propiedad objects de la clase MasterViewController , y que es un array de objetos cualesquiera ( [Any]() ). C\u00e1mbialo por un array de tareas, [Tarea]() ), y cambia el c\u00f3digo del apartado anterior para que use self.objects en vez de lista . Quedar\u00e1 como: 1 2 self . tm = TareasManager ( db : \"tareas.db\" , reload : false ) self . objects = self . tm . listarTareas () Para que las tareas aparezcan correctamente el interfaz gr\u00e1fico puedes cambiar las l\u00ednea en el m\u00e9todo tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) que dicen 1 2 let object = objects [ indexPath . row ] as ! NSDate cell . textLabel !. text = object . description por otras que usen la clase Tarea y referencien su propiedad titulo : 1 2 let tarea = objects [ indexPath . row ] cell . textLabel !. text = tarea . titulo Para evitar errores de compilaci\u00f3n, en el m\u00e9todo insertNewObject cambia la primera l\u00ednea ( objects.insert... ) por: 1 objects . insert ( Tarea ( id : 0 , titulo : \"Prueba\" , descripcion : \"\" , vencimiento : Date ()), at : 0 ) Ahora puedes probar la app y los t\u00edtulos de las tareas deber\u00edan aparecer en la lista (aunque si pinchas en alguna de ellas dar\u00e1 error en tiempo de ejecuci\u00f3n, ya que la plantilla asume que son NSDate y no objetos Tarea ) Para poder ver alg\u00fan detalle m\u00e1s en la lista, por ejemplo la fecha de vencimiento, abre el storyboard y selecciona la celda de tabla que aparece en la segunda pantalla de la aplicaci\u00f3n. En las propiedades, cambiar el Style de Basic a Subtitle , por ejemplo (aunque tambi\u00e9n valdr\u00edan los otros dos estilos). En el c\u00f3digo de tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) debes incluir c\u00f3digo que convierta object a Tarea acceda a su propiedad vencimiento , que ser\u00e1 una fecha, y la convierta a texto con DateFormatter (mira las transparencias) Asigne esta fecha en formato texto a cell.detailTextLabel.text . Finalmente, para que funcione la pantalla secundaria de detalle hay que: En el m\u00e9todo prepare del MasterViewController cambiar la l\u00ednea 1 let object = objects [ indexPath . row ] as ! NSDate eliminando la conversi\u00f3n a NSDate , quedar\u00e1 simplemente como 1 let object = objects [ indexPath . row ] En la l\u00ednea 31 de la clase DetailViewController cambiar el tipo de DetailItem de NSDate a Tarea En la l\u00ednea 20 de la misma clase cambiar detail.description por detail.descripcion que es un campo que s\u00ed tienen los objetos Tarea Funcionalidad 2: Insertar nueva tarea (2 puntos) \u00b6 Implementar un m\u00e9todo func insertar(tarea : Tarea)->Bool en la clase TareasManager , que inserte una nueva tarea en la BD y devuelva true si todo ha ido bien y false en caso contrario. Al campo id no es necesario darle valor al insertar un registro ya que es autonum\u00e9rico. Primero comprueba que funciona correctamente, insertando una tarea con datos fijos desde el viewDidLoad del MasterViewController. (hazlo antes del que las lista, para que la nueva est\u00e9 incluida tambi\u00e9n en la lista de tareas) 1 2 3 4 5 6 let nueva = Tarea () nueva . titulo = \"Tarea nueva\" ; nueva . descripcion = \"nueva descripcion\" ; //24*60*60 segundos posterior a la fecha actual -> ma\u00f1ana a la misma hora nueva . vencimiento = Date ( timeIntervalSinceNow : 24 * 60 * 60 ); self . tm . insertar ( tarea : nueva ) Una vez comprobado puedes eliminar el c\u00f3digo anterior. Para a\u00f1adir la funcionalidad en la interfaz de forma sencilla podemos usar un UIAlertAction Ser\u00eda mucho m\u00e1s elegante tener una pantalla aparte para introducir los datos de la tarea, pero lo que nos importa en esta sesi\u00f3n es trabajar con SQLite y \"perder\u00edamos\" demasiado tiempo en crear la interfaz. Copia este m\u00e9todo en el MasterViewController : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @objc func nuevaTarea () { let alert = UIAlertController ( title : \"Nueva tarea\" , message : \"Introduce los datos\" , preferredStyle : . alert ) let crear = UIAlertAction ( title : \"Crear\" , style : . default ) { action in let tit = alert . textFields ![ 0 ]. text ! if let desc = alert . textFields ![ 1 ]. text { if let diasVenc = Double ( alert . textFields ![ 2 ]. text !) { let venc = Date ( timeIntervalSinceNow : 24 * 60 * 60 * diasVenc ) let t = Tarea ( id : 0 , titulo : tit , descripcion : desc , vencimiento : venc ) if ( self . tm . insertar ( tarea : t )) { self . objects . insert ( t , at : 0 ) let indexPath = IndexPath ( row : 0 , section : 0 ) self . tableView . insertRows ( at : [ indexPath ], with : . automatic ) } } } } let cancelar = UIAlertAction ( title : \"Cancelar\" , style : . cancel ) { action in print ( \"Cancelada creaci\u00f3n de tarea\" ) } alert . addAction ( crear ) alert . addAction ( cancelar ) alert . addTextField () { $0 . placeholder = \"T\u00edtulo\" } alert . addTextField () { $0 . placeholder = \"Descripci\u00f3n\" } alert . addTextField () { $0 . placeholder = \"Vencimiento (d\u00edas)\" } self . present ( alert , animated : true ) } Ahora hay que vincular el bot\u00f3n + de la interfaz con este m\u00e9todo. En el viewDidLoad busca la l\u00ednea 1 let addButton = UIBarButtonItem ( barButtonSystemItem : . add , target : self , action : #selector ( insertNewObject ( _ ))) y d\u00e9jala como 1 let addButton = UIBarButtonItem ( barButtonSystemItem : . add , target : self , action : #selector ( nuevaTarea )) Ahora al pulsar el bot\u00f3n + deber\u00eda aparecer un alert para escribir los datos de la tarea. En esta versi\u00f3n simplificada no se puede poner una fecha de vencimiento d\u00eda-mes-a\u00f1o, sino solo un n\u00famero de d\u00edas a partir de la fecha actual.","title":"Ejercicios"},{"location":"cap2/2.4_ejercicios/#ejercicio-de-sqlite-app-de-tareas-pendientes-5-puntos","text":"En este ejercicio vamos a crear una peque\u00f1a aplicaci\u00f3n de gesti\u00f3n de tareas pendientes, en la que se puedan listar tareas y a\u00f1adir tareas nuevas. Cada tarea tiene un id (entero, autonum\u00e9rico), un titulo (cadena), un vencimiento (fecha) y una una descripcion (cadena). Las columnas est\u00e1n por este orden en la tabla. La base de datos ya est\u00e1 creada, y t\u00fa debes copiarla a tu proyecto como se explica a continuaci\u00f3n.","title":"Ejercicio de SQLite: app de tareas pendientes (5 puntos)"},{"location":"cap2/2.4_ejercicios/#infraestructura-basica-1-punto","text":"","title":"Infraestructura b\u00e1sica (1 punto)"},{"location":"cap2/2.4_ejercicios/#configurar-el-proyecto","text":"Crear un proyecto llamado TareasSQLite de tipo *Master-Detail Application * En la carpeta archivos SQLite de las plantillas hay unos cuantos recursos que debes copiar al proyecto Copia en el proyecto la base de datos tareas.db . NO LO HAGAS ARRASTRANDO , usa el men\u00fa File > Add files to TareasSQLite... y selecciona el archivo tareas.db . En el cuadro de di\u00e1logo de copia, pulsa sobre el boton options de la parte inferior y aseg\u00farate de que la casilla de Copy items if needed est\u00e1 marcada . En caso contrario est\u00e1s haciendo solo una referencia al archivo original, que se pierde si mueves el proyecto, y tampoco se sube al repositorio. Crea en el proyecto un DBManager.swift con el siguiente c\u00f3digo, es muy parecido al que tienes en los apuntes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import Foundation class DBManager { var db : OpaquePointer ? = nil init ( db nombreDB : String , reload : Bool ) { if let dbCopiaURL = copyDB ( conNombre : nombreDB , reload : reload ) { if sqlite3_open ( dbCopiaURL . path , & ( self . db )) == SQLITE_OK { print ( \"Base de datos \\( dbCopiaURL ) abierta OK\" ) } else { let error = String ( cString : sqlite3_errmsg ( db )) print ( \"Error al intentar abrir la BD: \\( error ) \" ) } } else { print ( \"El archivo no se encuentra\" ) } } deinit { sqlite3_close ( self . db ) } //Copia la base de datos desde el bundle al directorio Documents, para que se pueda modificar //si el par\u00e1metro \"machaca\" es true, copia la BD aunque ya est\u00e9 en Documents. //En una app normal esto no lo har\u00edamos cada vez que arranquemos, ya que se machacar\u00eda la BD func copyDB ( conNombre nombre : String , reload machaca : Bool )-> URL ? { let fileManager = FileManager . default let docsURL = fileManager . urls ( for : . documentDirectory , in : . userDomainMask )[ 0 ] let dbCopiaURL = docsURL . appendingPathComponent ( nombre ) let existe = fileManager . fileExists ( atPath : dbCopiaURL . path ) if existe && ! machaca { return dbCopiaURL } else { if let dbOriginalURL = Bundle . main . url ( forResource : nombre , withExtension : \"\" ) { if ( existe ) { try ! fileManager . removeItem ( at : dbCopiaURL ) } if ( try ? fileManager . copyItem ( at : dbOriginalURL , to : dbCopiaURL )) != nil { return dbCopiaURL } else { return nil } } else { return nil } } } } De momento, dar\u00e1 errores de compilaci\u00f3n porque todav\u00eda no has incluido SQLite en el proyecto. Ahora hay que configurar el proyecto para poder usar SQLite. A\u00f1ade la librer\u00eda libsqlite3.tbd y crea el Bridging Header seg\u00fan se explica en el apartado \"Configurar el proyecto\" de los apuntes. Para comprobar que funciona, introduce el siguiente c\u00f3digo en el m\u00e9todo viewDidLoad del MasterViewController 1 let manager = DBManager ( db : \"tareas.db\" , reload : false ) Si todo es correcto, en el log debe aparecer el mensaje \"Base de datos url_enormemente_larga_de_la_BD abierta OK\". Una vez que sepas que funciona, quita la l\u00ednea que has insertado en el viewDidLoad para que no interfiera con el resto del ejercicio. N\u00f3tese que como primer par\u00e1metro se pasa el nombre de la BD, y como segundo un booleano indicando si la copia de la BD de Documents se va a sobreescribir cada vez que se arranque la aplicaci\u00f3n (\u00fatil cuando en desarrollo estamos cambiando \u201cdesde fuera\u201d la BD para hacer pruebas) Si por alg\u00fan motivo cambias manualmente la estructura o el contenido de la base de datos, recuerda poner el par\u00e1metro reload a true la primera vez que ejecutes la aplicaci\u00f3n tras la modificaci\u00f3n","title":"Configurar el proyecto"},{"location":"cap2/2.4_ejercicios/#codigo-base","text":"Crea una struct Swift llamada Tarea en un archivo Tarea.swift y a\u00f1\u00e1dele como propiedades: id de tipo Int titulo de tipo String vencimiento de tipo Date descripcion de tipo String Crea un archivo TareasManager.swift donde se defina una clase del mismo nombre, y que sea una subclase de DBManager . En los siguientes apartados implementaremos aqu\u00ed las operaciones con la tabla de tareas.","title":"C\u00f3digo base"},{"location":"cap2/2.4_ejercicios/#funcionalidad-1-listar-tareas-3-puntos","text":"","title":"Funcionalidad 1: Listar tareas (3 puntos)"},{"location":"cap2/2.4_ejercicios/#implementar-el-listado-en-si","text":"En TareasManager Implementa un m\u00e9todo listarTareas que debe hacer un SELECT de la tabla tareas ordenado por fecha de vencimiento y devolver un array de objetos Tarea . Ser\u00e1 muy similar al c\u00f3digo que sirve para listar personas en los apuntes . Recuerda que en la tabla tareas las columnas son los mismos campos que en la struct Tarea : id , titulo , vencimiento y descripcion . Para ir paso a paso, puedes implementar primero en TareasManager una versi\u00f3n inicial de listarTareas que solo saque de la BD el campo titulo (columna 1, de tipo cadena), y ponga el resto de campos a valores fijos y arbitrarios. Una vez lo tengas puedes probarlo en el MasterViewController . A\u00f1ade la siguiente propiedad para almacenar una referencia al TareasManager 1 var tm : TareasManager ! = nil y ahora en el viewDidLoad a\u00f1ade: 1 2 3 4 5 self . tm = TareasManager ( db : \"tareas.db\" , reload : false ) let lista = self . tm . listarTareas () for t in lista { print ( \" \\( t . titulo ) \" ); } Deber\u00edan salir los t\u00edtulos de 3 tareas distintas. Si esto va, ya sabes que la parte b\u00e1sica te funciona y ahora puedes a\u00f1adir en listarTareas el resto de campos: id , descripcion y vencimiento . Este \u00faltimo campo ten en cuenta que usa \u201ctiempo UNIX\u201d: n\u00famero de segundos transcurridos desde el 1/1/1970.","title":"Implementar el listado en s\u00ed"},{"location":"cap2/2.4_ejercicios/#mostrar-las-tareas-en-la-tabla","text":"Vamos a modificar el c\u00f3digo del viewDidLoad para integrarlo mejor con la plantilla que ha generado Xcode. Fijate que lo que nosotros definimos como lista la plantilla lo define en la propiedad objects de la clase MasterViewController , y que es un array de objetos cualesquiera ( [Any]() ). C\u00e1mbialo por un array de tareas, [Tarea]() ), y cambia el c\u00f3digo del apartado anterior para que use self.objects en vez de lista . Quedar\u00e1 como: 1 2 self . tm = TareasManager ( db : \"tareas.db\" , reload : false ) self . objects = self . tm . listarTareas () Para que las tareas aparezcan correctamente el interfaz gr\u00e1fico puedes cambiar las l\u00ednea en el m\u00e9todo tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) que dicen 1 2 let object = objects [ indexPath . row ] as ! NSDate cell . textLabel !. text = object . description por otras que usen la clase Tarea y referencien su propiedad titulo : 1 2 let tarea = objects [ indexPath . row ] cell . textLabel !. text = tarea . titulo Para evitar errores de compilaci\u00f3n, en el m\u00e9todo insertNewObject cambia la primera l\u00ednea ( objects.insert... ) por: 1 objects . insert ( Tarea ( id : 0 , titulo : \"Prueba\" , descripcion : \"\" , vencimiento : Date ()), at : 0 ) Ahora puedes probar la app y los t\u00edtulos de las tareas deber\u00edan aparecer en la lista (aunque si pinchas en alguna de ellas dar\u00e1 error en tiempo de ejecuci\u00f3n, ya que la plantilla asume que son NSDate y no objetos Tarea ) Para poder ver alg\u00fan detalle m\u00e1s en la lista, por ejemplo la fecha de vencimiento, abre el storyboard y selecciona la celda de tabla que aparece en la segunda pantalla de la aplicaci\u00f3n. En las propiedades, cambiar el Style de Basic a Subtitle , por ejemplo (aunque tambi\u00e9n valdr\u00edan los otros dos estilos). En el c\u00f3digo de tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) debes incluir c\u00f3digo que convierta object a Tarea acceda a su propiedad vencimiento , que ser\u00e1 una fecha, y la convierta a texto con DateFormatter (mira las transparencias) Asigne esta fecha en formato texto a cell.detailTextLabel.text . Finalmente, para que funcione la pantalla secundaria de detalle hay que: En el m\u00e9todo prepare del MasterViewController cambiar la l\u00ednea 1 let object = objects [ indexPath . row ] as ! NSDate eliminando la conversi\u00f3n a NSDate , quedar\u00e1 simplemente como 1 let object = objects [ indexPath . row ] En la l\u00ednea 31 de la clase DetailViewController cambiar el tipo de DetailItem de NSDate a Tarea En la l\u00ednea 20 de la misma clase cambiar detail.description por detail.descripcion que es un campo que s\u00ed tienen los objetos Tarea","title":"Mostrar las tareas en la tabla"},{"location":"cap2/2.4_ejercicios/#funcionalidad-2-insertar-nueva-tarea-2-puntos","text":"Implementar un m\u00e9todo func insertar(tarea : Tarea)->Bool en la clase TareasManager , que inserte una nueva tarea en la BD y devuelva true si todo ha ido bien y false en caso contrario. Al campo id no es necesario darle valor al insertar un registro ya que es autonum\u00e9rico. Primero comprueba que funciona correctamente, insertando una tarea con datos fijos desde el viewDidLoad del MasterViewController. (hazlo antes del que las lista, para que la nueva est\u00e9 incluida tambi\u00e9n en la lista de tareas) 1 2 3 4 5 6 let nueva = Tarea () nueva . titulo = \"Tarea nueva\" ; nueva . descripcion = \"nueva descripcion\" ; //24*60*60 segundos posterior a la fecha actual -> ma\u00f1ana a la misma hora nueva . vencimiento = Date ( timeIntervalSinceNow : 24 * 60 * 60 ); self . tm . insertar ( tarea : nueva ) Una vez comprobado puedes eliminar el c\u00f3digo anterior. Para a\u00f1adir la funcionalidad en la interfaz de forma sencilla podemos usar un UIAlertAction Ser\u00eda mucho m\u00e1s elegante tener una pantalla aparte para introducir los datos de la tarea, pero lo que nos importa en esta sesi\u00f3n es trabajar con SQLite y \"perder\u00edamos\" demasiado tiempo en crear la interfaz. Copia este m\u00e9todo en el MasterViewController : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @objc func nuevaTarea () { let alert = UIAlertController ( title : \"Nueva tarea\" , message : \"Introduce los datos\" , preferredStyle : . alert ) let crear = UIAlertAction ( title : \"Crear\" , style : . default ) { action in let tit = alert . textFields ![ 0 ]. text ! if let desc = alert . textFields ![ 1 ]. text { if let diasVenc = Double ( alert . textFields ![ 2 ]. text !) { let venc = Date ( timeIntervalSinceNow : 24 * 60 * 60 * diasVenc ) let t = Tarea ( id : 0 , titulo : tit , descripcion : desc , vencimiento : venc ) if ( self . tm . insertar ( tarea : t )) { self . objects . insert ( t , at : 0 ) let indexPath = IndexPath ( row : 0 , section : 0 ) self . tableView . insertRows ( at : [ indexPath ], with : . automatic ) } } } } let cancelar = UIAlertAction ( title : \"Cancelar\" , style : . cancel ) { action in print ( \"Cancelada creaci\u00f3n de tarea\" ) } alert . addAction ( crear ) alert . addAction ( cancelar ) alert . addTextField () { $0 . placeholder = \"T\u00edtulo\" } alert . addTextField () { $0 . placeholder = \"Descripci\u00f3n\" } alert . addTextField () { $0 . placeholder = \"Vencimiento (d\u00edas)\" } self . present ( alert , animated : true ) } Ahora hay que vincular el bot\u00f3n + de la interfaz con este m\u00e9todo. En el viewDidLoad busca la l\u00ednea 1 let addButton = UIBarButtonItem ( barButtonSystemItem : . add , target : self , action : #selector ( insertNewObject ( _ ))) y d\u00e9jala como 1 let addButton = UIBarButtonItem ( barButtonSystemItem : . add , target : self , action : #selector ( nuevaTarea )) Ahora al pulsar el bot\u00f3n + deber\u00eda aparecer un alert para escribir los datos de la tarea. En esta versi\u00f3n simplificada no se puede poner una fecha de vencimiento d\u00eda-mes-a\u00f1o, sino solo un n\u00famero de d\u00edas a partir de la fecha actual.","title":"Funcionalidad 2: Insertar nueva tarea (2 puntos)"},{"location":"cap2/intro/","text":"SQLite \u00b6 En este cap\u00edtulo veremos c\u00f3mo usar la base de datos SQLite en iOS. Esta base de datos es m\u00e1s adecuada que las herramientas del cap\u00edtulo anterior si necesitamos hacer b\u00fasquedas o bien queremos guardar una cantidad de datos apreciable. Aunque Apple recomienda el uso del API Core Data para estas tareas, el uso de SQLite tiene la ventaja de presentar una baja barrera de entrada: simplemente conociendo SQL podemos trabajar con una base de datos relacional en iOS sin necesidad de aprender APIs complejos como Core Data.","title":"SQLite"},{"location":"cap2/intro/#sqlite","text":"En este cap\u00edtulo veremos c\u00f3mo usar la base de datos SQLite en iOS. Esta base de datos es m\u00e1s adecuada que las herramientas del cap\u00edtulo anterior si necesitamos hacer b\u00fasquedas o bien queremos guardar una cantidad de datos apreciable. Aunque Apple recomienda el uso del API Core Data para estas tareas, el uso de SQLite tiene la ventaja de presentar una baja barrera de entrada: simplemente conociendo SQL podemos trabajar con una base de datos relacional en iOS sin necesidad de aprender APIs complejos como Core Data.","title":"SQLite"},{"location":"cap3/3.1_intro/","text":"\u00bfQu\u00e9 es Core Data? \u00b6 Core Data es el principal framework de persistencia de iOS. Nos proporciona un mecanismo para poder almacenar de forma persistente los objetos de nuestra aplicaci\u00f3n y luego recuperarlos. Es capaz de guardar autom\u00e1ticamente un grafo entero de objetos con las relaciones (uno a uno, uno a muchos, muchos a muchos) que hay entre ellos. Si bien es un API complejo y tiene una curva de aprendizaje pronunciada, para cualquier aplicaci\u00f3n medianamente grande usar Core Data nos va a resultar mucho m\u00e1s sencillo que implementar nosotros la persistencia de manera manual con, digamos, SQLite. Core Data se puede considerar en cierto modo como un ORM ( object relational mapper ). A los desarrolladores que hayan usado un ORM en cualquier lenguaje les va a resultar familiar si no el API s\u00ed al menos las ideas b\u00e1sicas y la filosof\u00eda de trabajo. A\u00fan m\u00e1s, ciertos t\u00e9rminos usados en Core Data (objetos gestionados, contexto, ...) son t\u00edpicos tambi\u00e9n de otros ORM como por ejemplo JPA en Java. Siendo puristas, Core Data no es un ORM estrictamente hablando, ya que su objetivo no es la persistencia \u00fanicamente en bases de datos relacionales. En principio el backend de persistencia podr\u00eda ser cualquiera. Con la implementaci\u00f3n actual Core Data admite como \u00fanica BD relacional para persistencia SQLite, y tambi\u00e9n puede almacenar datos en memoria y en XML (esto \u00faltimo solo en OSX). El stack de Core Data \u00b6 El stack de Core Data usa un cierto n\u00famero de clases con una terminolog\u00eda que al principio puede resultar un poco confusa o complicada. La tarea de almacenar de forma persistente un grafo de objetos en realidad es complicada , as\u00ed que en parte por eso lo es la infraestructura necesaria. Vamos a resumir aqu\u00ed brevemente el papel de cada componente del stack Por supuesto, para poder almacenar informaci\u00f3n de forma persistente lo primero es disponer de un medio de almacenamiento persistente (una base de datos relacional, un fichero XML, un archivo JSON,\u2026). El NSPersistentStore es la clase que se ocupa de gestionar este almacenamiento persistente. Core Data nos proporciona dos implementaciones de almacenamiento \"persistente\" en iOS: la BD relacional SQLite, que ya conocemos, y el almacenamiento en memoria. Tambi\u00e9n podemos escribir nuestras propias implementaciones de NSPersistentStore . Es evidente que el almacenamiento en memoria no es precisamente persistente, pero va a ser muy r\u00e1pido y es apropiado para manejar datos de solo lectura o que puedan ser f\u00e1cilmente re-creados. El NSPersistentStoreCoordinator podr\u00eda considerarse como el n\u00facleo de Core Data. Es la clase responsable de gestionar la persistencia y por eso tiene que interactuar con el NSPersistentStore . No obstante, por muy importante que sea su papel de modo interno nuestro c\u00f3digo no va a interactuar apenas con esta clase, salvo en su inicializaci\u00f3n. Para poder hacer su trabajo, el NSPersistentStoreCoordinator necesita de un modelo de datos, o NSManagedObjectModel . Este modelo, que es similar a lo que ser\u00eda un modelo E-R en una base de datos relacional, define las \u201cclases\u201d que componen nuestro modelo del dominio, especificando sus atributos y las relaciones entre clases. Como veremos, en el proyecto de Xcode un modelo de datos se representa con un archivo .xcdatamodeld . El NSManagedObjectModel ser\u00eda como la versi\u00f3n compilada y binaria de este archivo. De nuevo solo vamos a usar directamente esta clase en nuestro c\u00f3digo en la parte de inicializaci\u00f3n (aunque por supuesto crear y editar el archivo .xcdatamodeld nos va a llevar bastante tiempo para cualquier modelo no trivial). Llegamos ya a las clases con las que nuestro c\u00f3digo va a interactuar m\u00e1s habitualmente: NSManagedObjectContext es el \u201ccontexto de persistencia\u201d. Este contexto es un grafo de objetos, relacionados entre s\u00ed, y cuyo ciclo de vida est\u00e1 gestionado por Core Data (de ah\u00ed la terminolog\u00eda de managed objects ). Esto significa que por ejemplo no creamos los objetos persistentes como habitualmente (con el inicializador) sino que le debemos pedir al NSManagedObjectContext que los cree por nosotros. Cada vez que necesitemos recuperar un objeto del almacenamiento persistente o guardarlo all\u00ed, tambi\u00e9n tendremos que ped\u00edrselo al contexto. As\u00ed que no es dif\u00edcil ver por qu\u00e9 va esta clase va a aparecer tanto en nuestro c\u00f3digo. Como hemos dicho, los objetos gestionados por el contexto de persistencia son los que representan nuestro modelo del dominio. Estos objetos son de la clase NSManagedObject o de clases descendientes de ella. Conforme vayamos realizando operaciones en la aplicaci\u00f3n iremos llen\u00e1ndolos de datos, relacion\u00e1ndolos entre s\u00ed, guard\u00e1ndolos, busc\u00e1ndolos, etc. Finalmente, si para buscar datos en una base de datos relacional se usa SQL, para recuperar objetos del almacenamiento persistente en Core Data usaremos NSFetchRequest . Al igual que en SQL podemos ejecutar consultas especificando las condiciones que deben cumplir los objetos a recuperar.","title":"Introducci\u00f3n a Core Data"},{"location":"cap3/3.1_intro/#que-es-core-data","text":"Core Data es el principal framework de persistencia de iOS. Nos proporciona un mecanismo para poder almacenar de forma persistente los objetos de nuestra aplicaci\u00f3n y luego recuperarlos. Es capaz de guardar autom\u00e1ticamente un grafo entero de objetos con las relaciones (uno a uno, uno a muchos, muchos a muchos) que hay entre ellos. Si bien es un API complejo y tiene una curva de aprendizaje pronunciada, para cualquier aplicaci\u00f3n medianamente grande usar Core Data nos va a resultar mucho m\u00e1s sencillo que implementar nosotros la persistencia de manera manual con, digamos, SQLite. Core Data se puede considerar en cierto modo como un ORM ( object relational mapper ). A los desarrolladores que hayan usado un ORM en cualquier lenguaje les va a resultar familiar si no el API s\u00ed al menos las ideas b\u00e1sicas y la filosof\u00eda de trabajo. A\u00fan m\u00e1s, ciertos t\u00e9rminos usados en Core Data (objetos gestionados, contexto, ...) son t\u00edpicos tambi\u00e9n de otros ORM como por ejemplo JPA en Java. Siendo puristas, Core Data no es un ORM estrictamente hablando, ya que su objetivo no es la persistencia \u00fanicamente en bases de datos relacionales. En principio el backend de persistencia podr\u00eda ser cualquiera. Con la implementaci\u00f3n actual Core Data admite como \u00fanica BD relacional para persistencia SQLite, y tambi\u00e9n puede almacenar datos en memoria y en XML (esto \u00faltimo solo en OSX).","title":"\u00bfQu\u00e9 es Core Data?"},{"location":"cap3/3.1_intro/#el-stack-de-core-data","text":"El stack de Core Data usa un cierto n\u00famero de clases con una terminolog\u00eda que al principio puede resultar un poco confusa o complicada. La tarea de almacenar de forma persistente un grafo de objetos en realidad es complicada , as\u00ed que en parte por eso lo es la infraestructura necesaria. Vamos a resumir aqu\u00ed brevemente el papel de cada componente del stack Por supuesto, para poder almacenar informaci\u00f3n de forma persistente lo primero es disponer de un medio de almacenamiento persistente (una base de datos relacional, un fichero XML, un archivo JSON,\u2026). El NSPersistentStore es la clase que se ocupa de gestionar este almacenamiento persistente. Core Data nos proporciona dos implementaciones de almacenamiento \"persistente\" en iOS: la BD relacional SQLite, que ya conocemos, y el almacenamiento en memoria. Tambi\u00e9n podemos escribir nuestras propias implementaciones de NSPersistentStore . Es evidente que el almacenamiento en memoria no es precisamente persistente, pero va a ser muy r\u00e1pido y es apropiado para manejar datos de solo lectura o que puedan ser f\u00e1cilmente re-creados. El NSPersistentStoreCoordinator podr\u00eda considerarse como el n\u00facleo de Core Data. Es la clase responsable de gestionar la persistencia y por eso tiene que interactuar con el NSPersistentStore . No obstante, por muy importante que sea su papel de modo interno nuestro c\u00f3digo no va a interactuar apenas con esta clase, salvo en su inicializaci\u00f3n. Para poder hacer su trabajo, el NSPersistentStoreCoordinator necesita de un modelo de datos, o NSManagedObjectModel . Este modelo, que es similar a lo que ser\u00eda un modelo E-R en una base de datos relacional, define las \u201cclases\u201d que componen nuestro modelo del dominio, especificando sus atributos y las relaciones entre clases. Como veremos, en el proyecto de Xcode un modelo de datos se representa con un archivo .xcdatamodeld . El NSManagedObjectModel ser\u00eda como la versi\u00f3n compilada y binaria de este archivo. De nuevo solo vamos a usar directamente esta clase en nuestro c\u00f3digo en la parte de inicializaci\u00f3n (aunque por supuesto crear y editar el archivo .xcdatamodeld nos va a llevar bastante tiempo para cualquier modelo no trivial). Llegamos ya a las clases con las que nuestro c\u00f3digo va a interactuar m\u00e1s habitualmente: NSManagedObjectContext es el \u201ccontexto de persistencia\u201d. Este contexto es un grafo de objetos, relacionados entre s\u00ed, y cuyo ciclo de vida est\u00e1 gestionado por Core Data (de ah\u00ed la terminolog\u00eda de managed objects ). Esto significa que por ejemplo no creamos los objetos persistentes como habitualmente (con el inicializador) sino que le debemos pedir al NSManagedObjectContext que los cree por nosotros. Cada vez que necesitemos recuperar un objeto del almacenamiento persistente o guardarlo all\u00ed, tambi\u00e9n tendremos que ped\u00edrselo al contexto. As\u00ed que no es dif\u00edcil ver por qu\u00e9 va esta clase va a aparecer tanto en nuestro c\u00f3digo. Como hemos dicho, los objetos gestionados por el contexto de persistencia son los que representan nuestro modelo del dominio. Estos objetos son de la clase NSManagedObject o de clases descendientes de ella. Conforme vayamos realizando operaciones en la aplicaci\u00f3n iremos llen\u00e1ndolos de datos, relacion\u00e1ndolos entre s\u00ed, guard\u00e1ndolos, busc\u00e1ndolos, etc. Finalmente, si para buscar datos en una base de datos relacional se usa SQL, para recuperar objetos del almacenamiento persistente en Core Data usaremos NSFetchRequest . Al igual que en SQL podemos ejecutar consultas especificando las condiciones que deben cumplir los objetos a recuperar.","title":"El stack de Core Data"},{"location":"cap3/3.2_stack/","text":"Vamos a introducir las funcionalidades b\u00e1sicas de Core Data implementando una peque\u00f1a aplicaci\u00f3n para almacenar y listar notas de texto. Lo primero que necesitamos para poder trabajar con Core Data es inicializar su stack , es decir instanciar las clases y crear los archivos de configuraci\u00f3n necesarios para poder almacenar y recuperar objetos persistentes. Salvo que tengamos necesidades especiales no es necesario escribir el c\u00f3digo de inicializaci\u00f3n manualmente, Xcode lo puede hacer por nosotros. Para ello, hay que marcar la casilla de \"Use Core Data\" que aparece al crear un nuevo proyecto de Xcode, tras elegir la plantilla. Crea un nuevo proyecto NotasCoreData usando como plantilla *Single View App y aseg\u00farate de que en la segunda pantalla del asistente de creaci\u00f3n marcas la opci\u00f3n de \"Use Core Data\" . Marcar esta casilla tiene dos efectos: Crea un archivo con el mismo nombre del proyecto y extensi\u00f3n .xcdatamodeld donde se va a almacenar nuestro modelo de datos Incluye una serie de m\u00e9todos auxiliares en la clase AppDelegate para ayudarnos a trabajar con Core Data sin tener que escribir c\u00f3digo partiendo de cero, ya que la parte de inicializaci\u00f3n es algo tediosa, o al menos lo era hasta iOS 10. Reconociendo que la inicializaci\u00f3n del stack era laboriosa, desde iOS 10 Apple la ha encapsulado en una nueva clase NSPersistentContainer que simplifica considerablemente el c\u00f3digo con respecto a las versiones anteriores. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 lazy var persistentContainer : NSPersistentContainer = { let container = NSPersistentContainer ( name : \"PruebaCoreData\" ) container . loadPersistentStores ( completionHandler : { ( storeDescription , error ) in if let error = error as NSError ? { fatalError ( \"Unresolved error \\( error ) , \\( error . userInfo ) \" ) } }) return container }() // MARK: - Core Data Saving support func saveContext () { let context = persistentContainer . viewContext if context . hasChanges { do { try context . save () } catch { let nserror = error as NSError fatalError ( \"Unresolved error \\( nserror ) , \\( nserror . userInfo ) \" ) } } } B\u00e1sicamente, esta es la clase que centraliza todo el manejo de Core Data. Nos permite acceder al NSManagedObjectContext , mediante su propiedad viewContext . Esto, que es lo que se denomina el contexto de persistencia es lo que necesitaremos para guardar y recuperar objetos. La funci\u00f3n saveContext es una funci\u00f3n de conveniencia para poder guardar los objetos pendientes en el contexto de forma simple.","title":"Crear el stack de Core Data en iOS"},{"location":"cap3/3.3_entidades/","text":"Info Esta secci\u00f3n es un ejercicio a seguir paso a paso que vale 0.75 puntos de la nota del bloque de iOS Crear las entidades (0,25 puntos) \u00b6 Las entidades son los objetos que queremos hacer persistentes en nuestra aplicaci\u00f3n. Debemos especificar sus propiedades (nombre y tipo) y como veremos en sesiones posteriores podemos establecer relaciones con otros objetos. Para gestionar las entidades debemos editar el archivo xcdatamodeld . En el editor visual de Xcode podemos, entre otras cosas, a\u00f1adir entidades. Vamos a crear la \u00fanica entidad que necesitamos en nuestra aplicaci\u00f3n: Nota . Para ello seguir estos pasos: Abrir el modelo de datos : por defecto Xcode lo crea con el mismo nombre que el proyecto y extensi\u00f3n xcdatamodeld . A\u00f1adir una entidad pulsando el bot\u00f3n Add Entity de la parte inferior. Crear\u00e1 una nueva entidad llamada por defecto Entity . Podemos cambiarle el nombre haciendo doble clic sobre \u00e9l. Cambiarle el nombre a la entidad a Nota A\u00f1adir los atributos pulsando sobre el bot\u00f3n + de la secci\u00f3n Attributes . Para cada atributo hay que especificar su nombre y tipo. A\u00f1adiremos dos atributos, fecha , de tipo Date y texto de tipo String IMPORTANTE: Los nombres de las entidades deben comenzar por may\u00fascula y los nombres de los atributos por min\u00fascula. El editor no nos dejar\u00e1 hacer lo contrario. Selecciona la entidad Nota en el editor y selecciona el Data Model Inspector en el panel de la derecha de Xcode (el cuarto icono en Xcode 12 , tercer icono en Xcode 11 y anteriores ). En el apartado Class ver\u00e1s los datos de la clase Swift que Xcode va a autogenerar para representar a tu entidad. Por defecto: El nombre es el mismo que la entidad La clase se crea en el \"Global Namespace\", lo que quiere decir que no te har\u00e1n falta import s para usarla En el campo codegen deber\u00eda aparecer seleccionado Class definition , ese es el m\u00e9todo que usa Xcode para generar el c\u00f3digo , lo veremos con m\u00e1s detalle en la siguiente sesi\u00f3n. Para terminar, aseg\u00farate de guardar el .xcdatamodel ( File > Save ). Hay veces que no se genera la clase Swift correspondiente a la entidad si no se hace esto Crear datos persistentes (0,5 puntos) \u00b6 Aqu\u00ed nos ocuparemos de crear y guardar una nueva nota. Por el momento no se podr\u00e1n editar ni borrar notas, para simplificar la aplicaci\u00f3n, \u00fanicamente crear notas nuevas. La interfaz de usuario para crear notas \u00b6 En la (por el momento) \u00fanica pantalla de la aplicaci\u00f3n a\u00f1adir los siguientes componentes : Un campo de texto de varias l\u00edneas ( text view ) para escribir la nota en s\u00ed. Una etiqueta ( label ) para mostrar la fecha y hora de la nota Un par de botones, uno para crear una nueva nota en blanco y otro para guardar la nota actual Una etiqueta ( label ) para mostrar mensajes al usuario Una vez a\u00f1adidos los componentes, hay que crear un outlet para las dos etiquetas y el campo de texto y as\u00ed poder acceder a/cambiar su contenido por c\u00f3digo. Recordad que hay que hacer Ctrl+Arrastrar desde el componente hasta el archivo donde queremos crear la propiedad (en nuestro caso ViewController.swift ). Adem\u00e1s hay que crear un action para cada bot\u00f3n , para poder ejecutar nuestro c\u00f3digo cuando se pulsen (con Ctrl+Arrastrar igual que antes). Debemos vincular los action al evento Touch up inside , que es el que aparece por defecto. El c\u00f3digo que implementa \u201ccrear nueva nota\u201d \u00b6 Debes implementar el c\u00f3digo del action del bot\u00f3n de \"crear\" . Este c\u00f3digo simplemente limpiar\u00e1 la etiqueta de la fecha, el campo de texto de varias l\u00edneas y la etiqueta para mensajes al usuario, asign\u00e1ndoles a las tres la cadena vac\u00eda. El c\u00f3digo que implementa el guardado \u00b6 En el c\u00f3digo del action asociado al bot\u00f3n de \u201cguardar\u201d debemos tomar el valor del campo de texto, crear una nueva nota con este texto y la fecha y hora actual y hacerla persistente. Adem\u00e1s actualizaremos la etiqueta con la fecha y hora actual para que muestre cu\u00e1ndo se ha guardado la nota. Vamos a verlo paso a paso. Para crear un nuevo objeto persistente debemos solicit\u00e1rselo al contexto, ya que este debe gestionar su ciclo de vida y si lo cre\u00e1ramos nosotros llamando al inicializador el contexto desconocer\u00eda de su existencia. Lo primero por tanto es obtener la referencia al contexto de persistencia . Como hemos visto en la secci\u00f3n anterior, en la plantilla de Xcode se guarda todo lo de Core Data en el application delegate , por lo que vamos a obtenerlo de ah\u00ed En el action asociado al bot\u00f3n de \"guardar\" a\u00f1ade el siguiente c\u00f3digo: 1 2 3 4 5 6 7 8 9 10 11 12 //No te olvides de a\u00f1adir este import AL PRINCIPIO DEL ARCHIVO import CoreData //obtenemos una referencia al \"application delegate\" de la aplicaci\u00f3n //En nuestro caso es de la clase AppDelegate //si esto fallara no tiene sentido continuar, de ah\u00ed el guard...else return guard let miDelegate = UIApplication . shared . delegate as ? AppDelegate else { return } //el acceso al API de core data nos lo da el persistent container //Lo que m\u00e1s usaremos (con mucho) es el contexto de persistencia let miContexto = miDelegate . persistentContainer . viewContext Hay que recalcar de nuevo que el hecho de que el persistentContainer est\u00e9 dentro del delegate no es propio de Core Data en s\u00ed, sino de la plantilla generada por Xcode para inicializar el stack . Para crear un nuevo objeto necesitamos relacionarlo con el contexto de persistencia. La clase Nota generada por Xcode tendr\u00e1 un inicializador que acepta como par\u00e1metro el contexto: 1 2 3 let nuevaNota = Nota ( context : miContexto ) nuevaNota . fecha = Date () nuevoNota . texto = \"<asignar aqu\u00ed el contenido del text view>\" Si Xcode da error con el c\u00f3digo anterior y no reconoce la clase Nota puedes probar a recompilar el proyecto con Product > Clean Build Folder y luego Product > Build . A veces se genera el c\u00f3digo para Nota pero no se compila o a veces no se ha generado. Tambi\u00e9n ayuda a veces ir al .xcdatamodel y guardarlo: ( File > Save ) Finalmente guardamos el objeto en el almacenamiento persistente . Esto se hace guardando el contexto, que guardar\u00e1 todos los objetos pendientes. El m\u00e9todo save puede lanzar una excepci\u00f3n que debemos tratar de alg\u00fan modo, en este ejemplo usamos un do...catch 1 2 3 4 5 do { try miContexto . save () } catch { print ( \"Error al guardar el contexto: \\( error ) \" ) } El m\u00e9todo de utilidad llamado saveContext de la plantilla generada por Xcode hace algo muy similar a lo anterior, aunque genera un error fatal que causa la terminaci\u00f3n inmediata de la aplicaci\u00f3n. Faltar\u00eda actualizar la etiqueta con la fecha y hora de la nota para que refleje la fecha asignada, y tambi\u00e9n actualizar la etiqueta con el mensaje al usuario que indique \"nota guardada\" o algo similar . Escribe el c\u00f3digo necesario para hacer esto . Tal y como est\u00e1 ahora el c\u00f3digo, cada vez que pulses sobre Guardar se crear\u00e1 una nueva nota , as\u00ed que aunque no modifiques el texto si pulsas varias veces tendr\u00e1s varias notas, que ser\u00e1n iguales en contenido, aunque no con la misma fecha/hora). No es necesario que soluciones esto, d\u00e9jalo as\u00ed por el momento.","title":"Ejercicio parte I. almacenar datos"},{"location":"cap3/3.3_entidades/#crear-las-entidades-025-puntos","text":"Las entidades son los objetos que queremos hacer persistentes en nuestra aplicaci\u00f3n. Debemos especificar sus propiedades (nombre y tipo) y como veremos en sesiones posteriores podemos establecer relaciones con otros objetos. Para gestionar las entidades debemos editar el archivo xcdatamodeld . En el editor visual de Xcode podemos, entre otras cosas, a\u00f1adir entidades. Vamos a crear la \u00fanica entidad que necesitamos en nuestra aplicaci\u00f3n: Nota . Para ello seguir estos pasos: Abrir el modelo de datos : por defecto Xcode lo crea con el mismo nombre que el proyecto y extensi\u00f3n xcdatamodeld . A\u00f1adir una entidad pulsando el bot\u00f3n Add Entity de la parte inferior. Crear\u00e1 una nueva entidad llamada por defecto Entity . Podemos cambiarle el nombre haciendo doble clic sobre \u00e9l. Cambiarle el nombre a la entidad a Nota A\u00f1adir los atributos pulsando sobre el bot\u00f3n + de la secci\u00f3n Attributes . Para cada atributo hay que especificar su nombre y tipo. A\u00f1adiremos dos atributos, fecha , de tipo Date y texto de tipo String IMPORTANTE: Los nombres de las entidades deben comenzar por may\u00fascula y los nombres de los atributos por min\u00fascula. El editor no nos dejar\u00e1 hacer lo contrario. Selecciona la entidad Nota en el editor y selecciona el Data Model Inspector en el panel de la derecha de Xcode (el cuarto icono en Xcode 12 , tercer icono en Xcode 11 y anteriores ). En el apartado Class ver\u00e1s los datos de la clase Swift que Xcode va a autogenerar para representar a tu entidad. Por defecto: El nombre es el mismo que la entidad La clase se crea en el \"Global Namespace\", lo que quiere decir que no te har\u00e1n falta import s para usarla En el campo codegen deber\u00eda aparecer seleccionado Class definition , ese es el m\u00e9todo que usa Xcode para generar el c\u00f3digo , lo veremos con m\u00e1s detalle en la siguiente sesi\u00f3n. Para terminar, aseg\u00farate de guardar el .xcdatamodel ( File > Save ). Hay veces que no se genera la clase Swift correspondiente a la entidad si no se hace esto","title":"Crear las entidades (0,25 puntos)"},{"location":"cap3/3.3_entidades/#crear-datos-persistentes-05-puntos","text":"Aqu\u00ed nos ocuparemos de crear y guardar una nueva nota. Por el momento no se podr\u00e1n editar ni borrar notas, para simplificar la aplicaci\u00f3n, \u00fanicamente crear notas nuevas.","title":"Crear datos persistentes (0,5 puntos)"},{"location":"cap3/3.3_entidades/#la-interfaz-de-usuario-para-crear-notas","text":"En la (por el momento) \u00fanica pantalla de la aplicaci\u00f3n a\u00f1adir los siguientes componentes : Un campo de texto de varias l\u00edneas ( text view ) para escribir la nota en s\u00ed. Una etiqueta ( label ) para mostrar la fecha y hora de la nota Un par de botones, uno para crear una nueva nota en blanco y otro para guardar la nota actual Una etiqueta ( label ) para mostrar mensajes al usuario Una vez a\u00f1adidos los componentes, hay que crear un outlet para las dos etiquetas y el campo de texto y as\u00ed poder acceder a/cambiar su contenido por c\u00f3digo. Recordad que hay que hacer Ctrl+Arrastrar desde el componente hasta el archivo donde queremos crear la propiedad (en nuestro caso ViewController.swift ). Adem\u00e1s hay que crear un action para cada bot\u00f3n , para poder ejecutar nuestro c\u00f3digo cuando se pulsen (con Ctrl+Arrastrar igual que antes). Debemos vincular los action al evento Touch up inside , que es el que aparece por defecto.","title":"La interfaz de usuario para crear notas"},{"location":"cap3/3.3_entidades/#el-codigo-que-implementa-crear-nueva-nota","text":"Debes implementar el c\u00f3digo del action del bot\u00f3n de \"crear\" . Este c\u00f3digo simplemente limpiar\u00e1 la etiqueta de la fecha, el campo de texto de varias l\u00edneas y la etiqueta para mensajes al usuario, asign\u00e1ndoles a las tres la cadena vac\u00eda.","title":"El c\u00f3digo que implementa \u201ccrear nueva nota\u201d"},{"location":"cap3/3.3_entidades/#el-codigo-que-implementa-el-guardado","text":"En el c\u00f3digo del action asociado al bot\u00f3n de \u201cguardar\u201d debemos tomar el valor del campo de texto, crear una nueva nota con este texto y la fecha y hora actual y hacerla persistente. Adem\u00e1s actualizaremos la etiqueta con la fecha y hora actual para que muestre cu\u00e1ndo se ha guardado la nota. Vamos a verlo paso a paso. Para crear un nuevo objeto persistente debemos solicit\u00e1rselo al contexto, ya que este debe gestionar su ciclo de vida y si lo cre\u00e1ramos nosotros llamando al inicializador el contexto desconocer\u00eda de su existencia. Lo primero por tanto es obtener la referencia al contexto de persistencia . Como hemos visto en la secci\u00f3n anterior, en la plantilla de Xcode se guarda todo lo de Core Data en el application delegate , por lo que vamos a obtenerlo de ah\u00ed En el action asociado al bot\u00f3n de \"guardar\" a\u00f1ade el siguiente c\u00f3digo: 1 2 3 4 5 6 7 8 9 10 11 12 //No te olvides de a\u00f1adir este import AL PRINCIPIO DEL ARCHIVO import CoreData //obtenemos una referencia al \"application delegate\" de la aplicaci\u00f3n //En nuestro caso es de la clase AppDelegate //si esto fallara no tiene sentido continuar, de ah\u00ed el guard...else return guard let miDelegate = UIApplication . shared . delegate as ? AppDelegate else { return } //el acceso al API de core data nos lo da el persistent container //Lo que m\u00e1s usaremos (con mucho) es el contexto de persistencia let miContexto = miDelegate . persistentContainer . viewContext Hay que recalcar de nuevo que el hecho de que el persistentContainer est\u00e9 dentro del delegate no es propio de Core Data en s\u00ed, sino de la plantilla generada por Xcode para inicializar el stack . Para crear un nuevo objeto necesitamos relacionarlo con el contexto de persistencia. La clase Nota generada por Xcode tendr\u00e1 un inicializador que acepta como par\u00e1metro el contexto: 1 2 3 let nuevaNota = Nota ( context : miContexto ) nuevaNota . fecha = Date () nuevoNota . texto = \"<asignar aqu\u00ed el contenido del text view>\" Si Xcode da error con el c\u00f3digo anterior y no reconoce la clase Nota puedes probar a recompilar el proyecto con Product > Clean Build Folder y luego Product > Build . A veces se genera el c\u00f3digo para Nota pero no se compila o a veces no se ha generado. Tambi\u00e9n ayuda a veces ir al .xcdatamodel y guardarlo: ( File > Save ) Finalmente guardamos el objeto en el almacenamiento persistente . Esto se hace guardando el contexto, que guardar\u00e1 todos los objetos pendientes. El m\u00e9todo save puede lanzar una excepci\u00f3n que debemos tratar de alg\u00fan modo, en este ejemplo usamos un do...catch 1 2 3 4 5 do { try miContexto . save () } catch { print ( \"Error al guardar el contexto: \\( error ) \" ) } El m\u00e9todo de utilidad llamado saveContext de la plantilla generada por Xcode hace algo muy similar a lo anterior, aunque genera un error fatal que causa la terminaci\u00f3n inmediata de la aplicaci\u00f3n. Faltar\u00eda actualizar la etiqueta con la fecha y hora de la nota para que refleje la fecha asignada, y tambi\u00e9n actualizar la etiqueta con el mensaje al usuario que indique \"nota guardada\" o algo similar . Escribe el c\u00f3digo necesario para hacer esto . Tal y como est\u00e1 ahora el c\u00f3digo, cada vez que pulses sobre Guardar se crear\u00e1 una nueva nota , as\u00ed que aunque no modifiques el texto si pulsas varias veces tendr\u00e1s varias notas, que ser\u00e1n iguales en contenido, aunque no con la misma fecha/hora). No es necesario que soluciones esto, d\u00e9jalo as\u00ed por el momento.","title":"El c\u00f3digo que implementa el guardado"},{"location":"cap3/3.4_recuperar_datos/","text":"Info Esta secci\u00f3n es un ejercicio a seguir paso a paso que vale 0,75 puntos de la nota del bloque de iOS Vamos a a\u00f1adir una pantalla donde se puedan consultar las notas que tenemos almacenadas. Las listaremos en una table view y por el momento se ver\u00e1n todas, no se podr\u00e1n filtrar (a\u00f1adiremos esa posibilidad cuando veamos la sintaxis de las \"consultas\" o fetch requests ). La interfaz de usuario \u00b6 Sigue estos pasos: Crear el Tab Bar Controller : teniendo seleccionada la \u00fanica pantalla de la aplicaci\u00f3n, ve al men\u00fa y selecciona Editor > Embed In > Tab Bar Controller . Se crear\u00e1 el tab bar controller , por el momento con una \u00fanica \"solapa\" que ser\u00e1 la pantalla de creaci\u00f3n de notas En la pantalla de creaci\u00f3n de notas, pulsa sobre el item de la barra inferior para editarlo, y ponle como Title por ejemplo Nueva , para que se vea que es la pantalla de creaci\u00f3n de notas Crear la pantalla para listar notas: Arrastrar al storyboard un Table view controller . Recuerda que es una especie de tabla a \u201cpantalla completa\u201d. Vincular la nueva pantalla al tab bar controller : hacer Ctrl+Arrastrar desde la pantalla del tab bar hasta la de listado de notas. En el men\u00fa contextual elegir como tipo del segue el de, View Controllers (bajo Relationship Segue ). Cambia el t\u00edtulo del item de la barra inferior para que ponga \"Lista\" o algo similar. Vamos a configurar la interfaz de la nueva pantalla Cambia el aspecto del prototipo de la tabla: pulsa sobre la celda prototipo de la tabla, y en las propiedades cambia el Style a `Basic Pon un reuse identifier : pon alg\u00fan Identifier por ejemplo MiCelda (recuerda que este identificador se emplea luego en el c\u00f3digo para solicitar al sistema instancias reutilizables de celdas) Ahora vamos a configurar el controlador de la pantalla Primero tenemos que crear un controlador ( File>New>File... ). De las plantillas que aparecen usa Cocoa Touch Class , as\u00ed Xcode generar\u00e1 c\u00f3digo por nosotros. La clase se debe llamar ListaNotasController y heredar\u00e1 de UITableViewController . Ahora hacer que la nueva clase sea el controlador de la pantalla de listado de notas: en el storyboard tienes que seleccionar la pantalla de listado de notas (primero de los iconos de la barra superior, el de fondo amarillo) En el Identity Inspector (cuarto de los iconos del panel de la derecha de Xcode, ), como Class poner ListaNotasController` Pon un print(\"hola soy ListaNotasController\") en el viewDidLoad del ListaNotasController para comprobar que efectivamente se usa esta clase como controlador de la nueva pantalla. Prueba a ejecutar el proyecto para ver que funciona el cambio de pantallas en el tab bar controller y que efectivamente en la pantalla de lista aparece el print hecho por ListaNotasController . El c\u00f3digo de la pantalla de listado \u00b6 En la tabla vamos a mostrar un array de notas. Lo primero ser\u00e1 definir una propiedad para almacenarlas en la clase ListaNotasController 1 2 3 4 5 6 7 //RECUERDA que hace falta este import al principio del archivo import CoreData class ListaNotasController : UITableViewController { var listaNotas : [ Nota ] ! } Solo nos queda rellenar el array de notas. En ListaNotasController crea un m\u00e9todo 1 2 3 override func viewWillAppear ( _ animated : Bool ) { } Vamos a rellenarlo de c\u00f3digo. Para recuperar datos de Core Data se usa un fetch request , que ser\u00eda algo as\u00ed como una consulta. para crearlo, inicializamos una instancia pas\u00e1ndole el nombre de la entidad resultado de la consulta. Para ejecutarlo, llamamos al m\u00e9todo fetch del contexto. Veamos un ejemplo. Escribe el siguiente c\u00f3digo en el viewWillAppear (Recuerda que debes sacar de alg\u00fan lado el contexto de Core Data ( miContexto )). Este c\u00f3digo todav\u00eda no mostrar\u00e1 las notas en la tabla pero al menos s\u00ed por la consola. 1 2 3 4 5 6 7 8 let request : NSFetchRequest < Nota > = NSFetchRequest ( entityName : \"Nota\" ) //\"miContexto\" es el contexto de Core Data //FALTA el c\u00f3digo que obtiene \"miContexto\", como se ha hecho en ejemplos anteriores if let notas = try ? miContexto . fetch ( request ) as ! [ Nota ] { for nota in notas { print ( nota . texto ) } } N\u00f3tese que los fetch request usan tipos. Es decir, devuelven un conjunto de elementos de una clase determinada, en nuestro caso Nota . Si pruebas el proyecto, al navegar a la pantalla de lista, los textos de las notas deber\u00edan aparecer en la consola de Xcode (aunque no en la pantalla del simulador). Para que los datos de las notas aparezcan en la tabla , debes: Asignar el valor devuelto por miContexto.fetch a la propiedad self.listaNotas , que has creado antes Forzar el refresco de la tabla para que aparezcan los datos. Tras asignar el valor a listaNotas, haz self.tableView.reloadData() (En un UITableViewController la propiedad tableView referencia a la tabla, no hace falta crear el outlet ) Modificar los m\u00e9todos que ha creado Xcode: numberOfSections debe devolver 1 en vez de 0, ya que la tabla tiene 1 secci\u00f3n tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) debe devolver el tama\u00f1o del array listaNotas (propiedad count ) El siguiente m\u00e9todo, que est\u00e1 comentado, debes descomentarlo, y hacer un par de modificaciones: Donde hace el dequeReusableCell... , cambia el identificador de la celda por el que hayas elegido t\u00fa antes al crear esta pantalla (aqu\u00ed se suger\u00eda MiCelda ) Donde pone el comentario Configure the cell... hacer que como texto de la celda aparezca el texto de la nota correspondiente 1 cell . textLabel ?. text = self . listaNotas [ indexPath . row ]. texto as ? String","title":"Ejercicio parte II. recuperar los datos"},{"location":"cap3/3.4_recuperar_datos/#la-interfaz-de-usuario","text":"Sigue estos pasos: Crear el Tab Bar Controller : teniendo seleccionada la \u00fanica pantalla de la aplicaci\u00f3n, ve al men\u00fa y selecciona Editor > Embed In > Tab Bar Controller . Se crear\u00e1 el tab bar controller , por el momento con una \u00fanica \"solapa\" que ser\u00e1 la pantalla de creaci\u00f3n de notas En la pantalla de creaci\u00f3n de notas, pulsa sobre el item de la barra inferior para editarlo, y ponle como Title por ejemplo Nueva , para que se vea que es la pantalla de creaci\u00f3n de notas Crear la pantalla para listar notas: Arrastrar al storyboard un Table view controller . Recuerda que es una especie de tabla a \u201cpantalla completa\u201d. Vincular la nueva pantalla al tab bar controller : hacer Ctrl+Arrastrar desde la pantalla del tab bar hasta la de listado de notas. En el men\u00fa contextual elegir como tipo del segue el de, View Controllers (bajo Relationship Segue ). Cambia el t\u00edtulo del item de la barra inferior para que ponga \"Lista\" o algo similar. Vamos a configurar la interfaz de la nueva pantalla Cambia el aspecto del prototipo de la tabla: pulsa sobre la celda prototipo de la tabla, y en las propiedades cambia el Style a `Basic Pon un reuse identifier : pon alg\u00fan Identifier por ejemplo MiCelda (recuerda que este identificador se emplea luego en el c\u00f3digo para solicitar al sistema instancias reutilizables de celdas) Ahora vamos a configurar el controlador de la pantalla Primero tenemos que crear un controlador ( File>New>File... ). De las plantillas que aparecen usa Cocoa Touch Class , as\u00ed Xcode generar\u00e1 c\u00f3digo por nosotros. La clase se debe llamar ListaNotasController y heredar\u00e1 de UITableViewController . Ahora hacer que la nueva clase sea el controlador de la pantalla de listado de notas: en el storyboard tienes que seleccionar la pantalla de listado de notas (primero de los iconos de la barra superior, el de fondo amarillo) En el Identity Inspector (cuarto de los iconos del panel de la derecha de Xcode, ), como Class poner ListaNotasController` Pon un print(\"hola soy ListaNotasController\") en el viewDidLoad del ListaNotasController para comprobar que efectivamente se usa esta clase como controlador de la nueva pantalla. Prueba a ejecutar el proyecto para ver que funciona el cambio de pantallas en el tab bar controller y que efectivamente en la pantalla de lista aparece el print hecho por ListaNotasController .","title":"La interfaz de usuario"},{"location":"cap3/3.4_recuperar_datos/#el-codigo-de-la-pantalla-de-listado","text":"En la tabla vamos a mostrar un array de notas. Lo primero ser\u00e1 definir una propiedad para almacenarlas en la clase ListaNotasController 1 2 3 4 5 6 7 //RECUERDA que hace falta este import al principio del archivo import CoreData class ListaNotasController : UITableViewController { var listaNotas : [ Nota ] ! } Solo nos queda rellenar el array de notas. En ListaNotasController crea un m\u00e9todo 1 2 3 override func viewWillAppear ( _ animated : Bool ) { } Vamos a rellenarlo de c\u00f3digo. Para recuperar datos de Core Data se usa un fetch request , que ser\u00eda algo as\u00ed como una consulta. para crearlo, inicializamos una instancia pas\u00e1ndole el nombre de la entidad resultado de la consulta. Para ejecutarlo, llamamos al m\u00e9todo fetch del contexto. Veamos un ejemplo. Escribe el siguiente c\u00f3digo en el viewWillAppear (Recuerda que debes sacar de alg\u00fan lado el contexto de Core Data ( miContexto )). Este c\u00f3digo todav\u00eda no mostrar\u00e1 las notas en la tabla pero al menos s\u00ed por la consola. 1 2 3 4 5 6 7 8 let request : NSFetchRequest < Nota > = NSFetchRequest ( entityName : \"Nota\" ) //\"miContexto\" es el contexto de Core Data //FALTA el c\u00f3digo que obtiene \"miContexto\", como se ha hecho en ejemplos anteriores if let notas = try ? miContexto . fetch ( request ) as ! [ Nota ] { for nota in notas { print ( nota . texto ) } } N\u00f3tese que los fetch request usan tipos. Es decir, devuelven un conjunto de elementos de una clase determinada, en nuestro caso Nota . Si pruebas el proyecto, al navegar a la pantalla de lista, los textos de las notas deber\u00edan aparecer en la consola de Xcode (aunque no en la pantalla del simulador). Para que los datos de las notas aparezcan en la tabla , debes: Asignar el valor devuelto por miContexto.fetch a la propiedad self.listaNotas , que has creado antes Forzar el refresco de la tabla para que aparezcan los datos. Tras asignar el valor a listaNotas, haz self.tableView.reloadData() (En un UITableViewController la propiedad tableView referencia a la tabla, no hace falta crear el outlet ) Modificar los m\u00e9todos que ha creado Xcode: numberOfSections debe devolver 1 en vez de 0, ya que la tabla tiene 1 secci\u00f3n tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) debe devolver el tama\u00f1o del array listaNotas (propiedad count ) El siguiente m\u00e9todo, que est\u00e1 comentado, debes descomentarlo, y hacer un par de modificaciones: Donde hace el dequeReusableCell... , cambia el identificador de la celda por el que hayas elegido t\u00fa antes al crear esta pantalla (aqu\u00ed se suger\u00eda MiCelda ) Donde pone el comentario Configure the cell... hacer que como texto de la celda aparezca el texto de la nota correspondiente 1 cell . textLabel ?. text = self . listaNotas [ indexPath . row ]. texto as ? String","title":"El c\u00f3digo de la pantalla de listado"},{"location":"cap3/apendice_ver_almacenamiento/","text":"No es necesario que sigas estos pasos en el ejercicio, pero s\u00ed es interesante que los leas para poder entender mejor el funcionamiento interno de Core Data. Podemos examinar el almacenamiento persistente, que como ya hemos visto el c\u00f3digo Swift del delegate , se configura por defecto como una base de datos SQLite con el mismo nombre del proyecto. Podemos localizar el archivo tecleando desde la terminal: 1 find . -name MisNotas.sqlite -print o m\u00e1s sencillo, emplear alguna utilidad como SimSim , que ya hemos usado en otras sesiones para localizar el directorio con el sandbox de nuestra aplicaci\u00f3n. La base de datos se crea por defecto en el directorio Library/Application Support del sandbox . Si abrimos la base de datos usando alguna utilidad gr\u00e1fica o bien desde la terminal (movi\u00e9ndose al directorio donde est\u00e1 el MisNotas.sqlite y tecleando:) 1 sqlite3 MisNotas.sqlite Deber\u00eda aparecer el prompt de SQLite donde podemos por ejemplo ver la estructura de la BD, tecleando 1 sqlite> .schema Aparecer\u00e1 algo como 1 2 3 4 5 6 CREATE TABLE ZNOTA ( Z_PK INTEGER PRIMARY KEY , Z_ENT INTEGER , Z_OPT INTEGER , ZFECHA TIMESTAMP , ZTEXTO VARCHAR ); CREATE TABLE Z_PRIMARYKEY ( Z_ENT INTEGER PRIMARY KEY , Z_NAME VARCHAR , Z_SUPER INTEGER , Z_MAX INTEGER ); CREATE TABLE Z_METADATA ( Z_VERSION INTEGER PRIMARY KEY , Z_UUID VARCHAR ( 255 ), Z_PLIST BLOB ); Como se ve, Core Data crea autom\u00e1ticamente una tabla para la entidad Nota , con el mismo nombre (aunque precedida de una curiosa Z , como los nombres de los campos). Crea tambi\u00e9n una columna por cada propiedad, asign\u00e1ndoles el tipo apropiado. Adem\u00e1s autom\u00e1ticamente crea una clave primaria, aunque en la entidad no hemos definido ninguna. Podemos comprobar tambi\u00e9n si se ha guardado la nota ejecutando una sentencia SQL 1 sqlite > select * from ZNOTA ; Es posible que el select anterior no muestre los registros actualizados, ya que a partir de iOS7 se usa un modo de SQLite que se llama \"Write Ahead Logging\". En este modo, las transacciones para las que no se ha hecho commit se almacenan en un archivo .wal aparte.","title":"Ap\u00e9ndice. C\u00f3mo examinar el almacenamiento persistente"},{"location":"cap3/intro/","text":"Introducci\u00f3n \u00b6 En este tema nos introduciremos en el API iOS por excelencia para almacenar datos: Core Data. Este es uno de los APIs m\u00e1s complejos de la plataforma, y por eso le vamos a dedicar bastante tiempo. Empezaremos por implementar de manera guiada un ejemplo sencillo: una aplicaci\u00f3n para guardar notas de texto. Esta aplicaci\u00f3n nos servir\u00e1 para irnos familiarizando con los conceptos b\u00e1sicos que hay que conocer para trabajar con Core Data.","title":"Introducci\u00f3n"},{"location":"cap3/intro/#introduccion","text":"En este tema nos introduciremos en el API iOS por excelencia para almacenar datos: Core Data. Este es uno de los APIs m\u00e1s complejos de la plataforma, y por eso le vamos a dedicar bastante tiempo. Empezaremos por implementar de manera guiada un ejemplo sencillo: una aplicaci\u00f3n para guardar notas de texto. Esta aplicaci\u00f3n nos servir\u00e1 para irnos familiarizando con los conceptos b\u00e1sicos que hay que conocer para trabajar con Core Data.","title":"Introducci\u00f3n"},{"location":"cap4/4.1_crear_modelo/","text":"El modelo de datos ser\u00eda m\u00e1s o menos el equivalente al esquema entidad/relaci\u00f3n en una base de datos relacional. Con la diferencia de que en Core Data tenemos clases Swift y variables miembro en lugar de tablas y claves ajenas. Normalmente en una aplicaci\u00f3n hay un solo modelo de datos, que se almacena en un archivo .xcdatamodeld . En Xcode, al crear el proyecto con la casilla de \"Use Core Data\" marcada nos crea un modelo de datos vac\u00edo con el mismo nombre del proyecto. Lo m\u00e1s habitual es editar el modelo con el editor gr\u00e1fico de Xcode, aunque tambi\u00e9n hay un API Swift para crearlo/manipularlo. El editor tiene dos modos, el modo \"tabla\" donde vemos las entidades y atributos como listas de valores, y el modo \"gr\u00e1fico\" donde podemos ver un diagrama con las entidades y las relaciones entre ellas. Estos modos se cambian con los dos iconos de la esquina inferior derecha del editor ( Editor Style ). Entidades \u00b6 Las entidades comparten ciertas caracter\u00edsticas con las clases de la POO y otras con las tablas de una base de datos. Por ejemplo pueden ser abstractas y por tanto no directamente instanciables, como las clases de cualquier lenguaje OO. Por otro lado tienen relaciones con otras entidades (uno-a-uno, uno-a-muchos,...) y se puede especificar qu\u00e9 debe pasar cuando uno de los \"lados\" de la relaci\u00f3n se elimina, como es t\u00edpico de las bases de datos relacionales. Si seleccionamos una entidad podemos ver sus propiedades en el \"Data Model Inspector\", (Cmd+Alt+3 o clic en el tercer icono del panel de la derecha de la pantalla) Abstract entity es an\u00e1logo a las clases abstractas en POO, indica que la entidad no es directamente instanciable y se usa solo para que otras hereden de ella. Parent entity indicar\u00eda que esta instancia hereda las propiedades de otra Class : por defecto Xcode crear\u00e1 autom\u00e1ticamente una clase Swift para representar la entidad. Posteriormente veremos d\u00f3nde est\u00e1 este c\u00f3digo y qu\u00e9 estructura tiene. En versiones antiguas de Xcode el IDE no generaba por defecto las clases y hab\u00eda que generarlas manualmente. Todav\u00eda se puede hacer de este modo si queremos personalizar el c\u00f3digo Swift, como veremos posteriormente. Atributos de la clase \u00b6 La caracter\u00edstica m\u00e1s destacada de un atributo es el tipo de datos . Podemos elegir de entre una serie de tipos, que pueden verse en la siguiente imagen del editor. La mayor\u00eda son bastante autoexplicativos, salvo los dos \u00faltimos. El tipo binario se usa t\u00edpicamente para im\u00e1genes, audio, .... En cuanto a Transformable nos permite almacenar cualquier clase Swift/Obj-C. Se parece al binario en el sentido de que en el fondo, los datos se van a almacenar tambi\u00e9n en binario, pero con Transformable proporcionamos un medio de hacer la conversi\u00f3n y a partir de ah\u00ed nos \"olvidamos\" de que el dato se est\u00e1 convirtiendo, si trabajamos con clases propias solo veremos el tipo original. Cualquier clase (propia o del sistema) que sea conforme al protocolo NSCoding puede usarse como Transformable e iOS se encargar\u00e1 autom\u00e1ticamente de convertirla a/desde NSData . Veremos m\u00e1s detalles posteriormente. Adem\u00e1s del tipo, las propiedades tienen muchas otras caracter\u00edsticas. Podemos verlas en el \"Data Model Inspector\", haciendo clic sobre el atributo y luego con el atajo (Cmd+Alt+3) o con clic en el tercer icono del panel de la derecha de la pantalla. Veamos algunas de ellas: Transient significa que no queremos que la propiedad sea persistente. Es t\u00edpico de los valores que son calculados a partir de otros y que podemos volver a calcular f\u00e1cilmente (por ejemplo el total de un pedido). Aun no siendo persistentes, estas propiedades tambi\u00e9n pueden participar en operaciones de \u201cdeshacer y rehacer\u201d ( undo & redo ) Optional es el contrario del t\u00edpico \"not null\" de las bases de datos. Si un campo es opcional, puede ser nil . Indexed tambi\u00e9n es el mismo concepto que en BD. Un atributo indexado estar\u00e1 optimizado para las b\u00fasquedas que hagamos sobre \u00e9l pero ocupar\u00e1 m\u00e1s espacio de almacenamiento. Reglas de validaci\u00f3n: valor m\u00ednimo y m\u00e1ximo (si es num\u00e9rico), longitud m\u00ednima y m\u00e1xima (si es cadena), Reg Exp , la expresi\u00f3n regular con la que deben encajar los valores del atributo. Valor por defecto ( default ) que se asignar\u00e1 autom\u00e1ticamente si no le damos un valor expl\u00edcito. Fetch requests \u00b6 En el editor podemos crear fetch requests predefinidas. Estas requests son lo que en una base de datos llamar\u00edamos consultas o queries . Mantenemos pulsado el bot\u00f3n de Add Entity para que aparezca un men\u00fa contextual y en \u00e9l elegimos la opci\u00f3n Add fetch request . Podemos a\u00f1adir gr\u00e1ficamente las condiciones deseadas. Veremos la sintaxis de las condiciones cuando tratemos las consultas en Core Data. Relaciones \u00b6 Las relaciones en Core Data son muy similares al concepto equivalente en BD relacionales: vinculan una entidad con otra u otras, generalmente de otro tipo. Cuando creamos una relaci\u00f3n usando el estilo de \"tabla\" en el editor visual, las tres caracter\u00edsticas directamente editables son: Nombre : es arbitrario y la \u00fanica condici\u00f3n es que debe comenzar por min\u00fascula, al igual que las propiedades. No obstante, una pr\u00e1ctica com\u00fan es ponerle el mismo nombre que la entidad a la que vincula pero en min\u00fascula. Por ejemplo si tenemos un Mensaje y queremos establecer una relaci\u00f3n con el Usuario que lo ha enviado llamar\u00edamos a la relaci\u00f3n simplemente usuario . Si es una relaci\u00f3n uno a muchos se suele usar el plural. As\u00ed, si tenemos un `Usuario y queremos vincularlo con todos sus mensajes llamar\u00edamos mensajes a la relaci\u00f3n. Destino : la entidad vinculada Inversa : Se recomienda que todo v\u00ednculo entre entidades tenga su relaci\u00f3n inversa, que es la que nos permite \"volver al punto de partida\". En el ejemplo de mensajes/usuarios, la inversa de la relaci\u00f3n usuario ser\u00eda mensajes . Las relaciones que no tienen inversa generan warnings en Xcode, ya que Core Data usa la bidireccionalidad para poder mantener la consistencia del grafo de objetos cuando se eliminan entidades. Al igual que con las entidades y las propiedades, podemos cambiar los atributos de una relaci\u00f3n seleccion\u00e1ndola y yendo al \u201cData Model Inspector\u201d, (recuerda, Cmd+Alt+3 o clic en el tercer icono del panel de la derecha de la pantalla). Transient y optional son equivalentes a los atributos del mismo nombre usados en las propiedades. Delete rule es la t\u00edpica regla a aplicar cuando se borra la entidad \u201cfuente\u201d de la relaci\u00f3n: por ejemplo con cascade si se borra la entidad, las relacionadas tambi\u00e9n lo hacen autom\u00e1ticamente, con deny no se puede borrar la entidad si hay relacionadas, con nullify la relaci\u00f3n inversa se pone a nil y con no action la relaci\u00f3n inversa queda tal cual (aunque apuntar\u00e1 a un objeto que ya no existe (!)) con Type podemos indicar si es una relaci\u00f3n uno a uno o uno a muchos. Las relaciones muchos a muchos las conseguimos poniendo tanto la relaci\u00f3n como la inversa con el tipo \u201ca muchos\u201d. En el editor de data models de Xcode, si nos ponemos en modo Graph podemos ver gr\u00e1ficamente las relaciones entre objetos y crearlas con ctrl-click en la entidad \"origen\" y arrastrando hasta la entidad destino. Las relaciones \"uno a uno\" aparecen con una \u00fanica punta de flecha en el destino, y las \"uno a muchos\" con dos. En el caso de relaciones \u201ca muchos\u201d podemos especificar: Si queremos que sean ordenadas ( ordered ). Por ejemplo nos dar\u00e1 lo mismo el orden para un G\u00e9nero musical que tiene asociados muchos Disco s, pero no es indiferente en el caso de una Conversacion y los Mensaje s que la componen. La cardinalidad m\u00ednima y m\u00e1xima (podemos fijar un l\u00edmite num\u00e9rico o dejarlo vac\u00eda ( unbounded ) Fetched properties \u00b6 Son similares a las relaciones, pero no son bidireccionales. Cada fetched property est\u00e1 basada en una consulta ( fetch request ). Por ejemplo podr\u00edamos tener una propiedad mensajes_recientes que nos devolviera los mensajes que ha enviado recientemente un usuario. Para crear una fetched property mantenemos pulsado el bot\u00f3n de Add attribute hasta que aparezca el men\u00fa contextual, donde seleccionamos Add fetched property . Tenemos que especificar su nombre y el predicado (la condici\u00f3n de la \u201cconsulta asociada\u201d). Veremos alg\u00fan ejemplo cuando hablemos de consultas en Core Data. Cuidado, las fetched properties no son din\u00e1micas, sino lazy , su valor no se recalcula autom\u00e1ticamente cada vez que accedemos a ellas, hay que recalcularlas expl\u00edcitamente con refreshObject:mergeChanges: .","title":"Crear y editar modelos"},{"location":"cap4/4.1_crear_modelo/#entidades","text":"Las entidades comparten ciertas caracter\u00edsticas con las clases de la POO y otras con las tablas de una base de datos. Por ejemplo pueden ser abstractas y por tanto no directamente instanciables, como las clases de cualquier lenguaje OO. Por otro lado tienen relaciones con otras entidades (uno-a-uno, uno-a-muchos,...) y se puede especificar qu\u00e9 debe pasar cuando uno de los \"lados\" de la relaci\u00f3n se elimina, como es t\u00edpico de las bases de datos relacionales. Si seleccionamos una entidad podemos ver sus propiedades en el \"Data Model Inspector\", (Cmd+Alt+3 o clic en el tercer icono del panel de la derecha de la pantalla) Abstract entity es an\u00e1logo a las clases abstractas en POO, indica que la entidad no es directamente instanciable y se usa solo para que otras hereden de ella. Parent entity indicar\u00eda que esta instancia hereda las propiedades de otra Class : por defecto Xcode crear\u00e1 autom\u00e1ticamente una clase Swift para representar la entidad. Posteriormente veremos d\u00f3nde est\u00e1 este c\u00f3digo y qu\u00e9 estructura tiene. En versiones antiguas de Xcode el IDE no generaba por defecto las clases y hab\u00eda que generarlas manualmente. Todav\u00eda se puede hacer de este modo si queremos personalizar el c\u00f3digo Swift, como veremos posteriormente.","title":"Entidades"},{"location":"cap4/4.1_crear_modelo/#atributos-de-la-clase","text":"La caracter\u00edstica m\u00e1s destacada de un atributo es el tipo de datos . Podemos elegir de entre una serie de tipos, que pueden verse en la siguiente imagen del editor. La mayor\u00eda son bastante autoexplicativos, salvo los dos \u00faltimos. El tipo binario se usa t\u00edpicamente para im\u00e1genes, audio, .... En cuanto a Transformable nos permite almacenar cualquier clase Swift/Obj-C. Se parece al binario en el sentido de que en el fondo, los datos se van a almacenar tambi\u00e9n en binario, pero con Transformable proporcionamos un medio de hacer la conversi\u00f3n y a partir de ah\u00ed nos \"olvidamos\" de que el dato se est\u00e1 convirtiendo, si trabajamos con clases propias solo veremos el tipo original. Cualquier clase (propia o del sistema) que sea conforme al protocolo NSCoding puede usarse como Transformable e iOS se encargar\u00e1 autom\u00e1ticamente de convertirla a/desde NSData . Veremos m\u00e1s detalles posteriormente. Adem\u00e1s del tipo, las propiedades tienen muchas otras caracter\u00edsticas. Podemos verlas en el \"Data Model Inspector\", haciendo clic sobre el atributo y luego con el atajo (Cmd+Alt+3) o con clic en el tercer icono del panel de la derecha de la pantalla. Veamos algunas de ellas: Transient significa que no queremos que la propiedad sea persistente. Es t\u00edpico de los valores que son calculados a partir de otros y que podemos volver a calcular f\u00e1cilmente (por ejemplo el total de un pedido). Aun no siendo persistentes, estas propiedades tambi\u00e9n pueden participar en operaciones de \u201cdeshacer y rehacer\u201d ( undo & redo ) Optional es el contrario del t\u00edpico \"not null\" de las bases de datos. Si un campo es opcional, puede ser nil . Indexed tambi\u00e9n es el mismo concepto que en BD. Un atributo indexado estar\u00e1 optimizado para las b\u00fasquedas que hagamos sobre \u00e9l pero ocupar\u00e1 m\u00e1s espacio de almacenamiento. Reglas de validaci\u00f3n: valor m\u00ednimo y m\u00e1ximo (si es num\u00e9rico), longitud m\u00ednima y m\u00e1xima (si es cadena), Reg Exp , la expresi\u00f3n regular con la que deben encajar los valores del atributo. Valor por defecto ( default ) que se asignar\u00e1 autom\u00e1ticamente si no le damos un valor expl\u00edcito.","title":"Atributos de la clase"},{"location":"cap4/4.1_crear_modelo/#fetch-requests","text":"En el editor podemos crear fetch requests predefinidas. Estas requests son lo que en una base de datos llamar\u00edamos consultas o queries . Mantenemos pulsado el bot\u00f3n de Add Entity para que aparezca un men\u00fa contextual y en \u00e9l elegimos la opci\u00f3n Add fetch request . Podemos a\u00f1adir gr\u00e1ficamente las condiciones deseadas. Veremos la sintaxis de las condiciones cuando tratemos las consultas en Core Data.","title":"Fetch requests"},{"location":"cap4/4.1_crear_modelo/#relaciones","text":"Las relaciones en Core Data son muy similares al concepto equivalente en BD relacionales: vinculan una entidad con otra u otras, generalmente de otro tipo. Cuando creamos una relaci\u00f3n usando el estilo de \"tabla\" en el editor visual, las tres caracter\u00edsticas directamente editables son: Nombre : es arbitrario y la \u00fanica condici\u00f3n es que debe comenzar por min\u00fascula, al igual que las propiedades. No obstante, una pr\u00e1ctica com\u00fan es ponerle el mismo nombre que la entidad a la que vincula pero en min\u00fascula. Por ejemplo si tenemos un Mensaje y queremos establecer una relaci\u00f3n con el Usuario que lo ha enviado llamar\u00edamos a la relaci\u00f3n simplemente usuario . Si es una relaci\u00f3n uno a muchos se suele usar el plural. As\u00ed, si tenemos un `Usuario y queremos vincularlo con todos sus mensajes llamar\u00edamos mensajes a la relaci\u00f3n. Destino : la entidad vinculada Inversa : Se recomienda que todo v\u00ednculo entre entidades tenga su relaci\u00f3n inversa, que es la que nos permite \"volver al punto de partida\". En el ejemplo de mensajes/usuarios, la inversa de la relaci\u00f3n usuario ser\u00eda mensajes . Las relaciones que no tienen inversa generan warnings en Xcode, ya que Core Data usa la bidireccionalidad para poder mantener la consistencia del grafo de objetos cuando se eliminan entidades. Al igual que con las entidades y las propiedades, podemos cambiar los atributos de una relaci\u00f3n seleccion\u00e1ndola y yendo al \u201cData Model Inspector\u201d, (recuerda, Cmd+Alt+3 o clic en el tercer icono del panel de la derecha de la pantalla). Transient y optional son equivalentes a los atributos del mismo nombre usados en las propiedades. Delete rule es la t\u00edpica regla a aplicar cuando se borra la entidad \u201cfuente\u201d de la relaci\u00f3n: por ejemplo con cascade si se borra la entidad, las relacionadas tambi\u00e9n lo hacen autom\u00e1ticamente, con deny no se puede borrar la entidad si hay relacionadas, con nullify la relaci\u00f3n inversa se pone a nil y con no action la relaci\u00f3n inversa queda tal cual (aunque apuntar\u00e1 a un objeto que ya no existe (!)) con Type podemos indicar si es una relaci\u00f3n uno a uno o uno a muchos. Las relaciones muchos a muchos las conseguimos poniendo tanto la relaci\u00f3n como la inversa con el tipo \u201ca muchos\u201d. En el editor de data models de Xcode, si nos ponemos en modo Graph podemos ver gr\u00e1ficamente las relaciones entre objetos y crearlas con ctrl-click en la entidad \"origen\" y arrastrando hasta la entidad destino. Las relaciones \"uno a uno\" aparecen con una \u00fanica punta de flecha en el destino, y las \"uno a muchos\" con dos. En el caso de relaciones \u201ca muchos\u201d podemos especificar: Si queremos que sean ordenadas ( ordered ). Por ejemplo nos dar\u00e1 lo mismo el orden para un G\u00e9nero musical que tiene asociados muchos Disco s, pero no es indiferente en el caso de una Conversacion y los Mensaje s que la componen. La cardinalidad m\u00ednima y m\u00e1xima (podemos fijar un l\u00edmite num\u00e9rico o dejarlo vac\u00eda ( unbounded )","title":"Relaciones"},{"location":"cap4/4.1_crear_modelo/#fetched-properties","text":"Son similares a las relaciones, pero no son bidireccionales. Cada fetched property est\u00e1 basada en una consulta ( fetch request ). Por ejemplo podr\u00edamos tener una propiedad mensajes_recientes que nos devolviera los mensajes que ha enviado recientemente un usuario. Para crear una fetched property mantenemos pulsado el bot\u00f3n de Add attribute hasta que aparezca el men\u00fa contextual, donde seleccionamos Add fetched property . Tenemos que especificar su nombre y el predicado (la condici\u00f3n de la \u201cconsulta asociada\u201d). Veremos alg\u00fan ejemplo cuando hablemos de consultas en Core Data. Cuidado, las fetched properties no son din\u00e1micas, sino lazy , su valor no se recalcula autom\u00e1ticamente cada vez que accedemos a ellas, hay que recalcularlas expl\u00edcitamente con refreshObject:mergeChanges: .","title":"Fetched properties"},{"location":"cap4/4.2_clases_propias/","text":"Desde el punto de vista del c\u00f3digo Swift las entidades del modelo ser\u00e1n instancias de clases Swift. As\u00ed, dada la entidad Usuario con ciertos atributos lo que tendremos en Swift es una clase con el mismo nombre y las correspondientes propiedades. Generaci\u00f3n autom\u00e1tica de las clases \u00b6 Desde Xcode 8 las clases de nuestro modelo de datos se pueden generar autom\u00e1ticamente y de modo transparente para el desarrollador cada vez que guardemos el modelo de datos (el .xcdatamodeld ). En el editor del modelo de datos, si seleccionamos una entidad y accedemos a sus atributos en el panel de la derecha, veremos que hay una secci\u00f3n titulada Class que se ocupa del c\u00f3digo generado, podemos cambiar: El nombre de la clase generada (por defecto el de la entidad) El m\u00f3dulo de Swift donde se crea la clase (por defecto pone Global Namespace , lo que significa que no har\u00e1 falta ning\u00fan import para referenciar la clase) En codegen por defecto aparece seleccionada la opci\u00f3n Class definition , que indica que Xcode va a generar por defecto la clase asociada a la entidad. Con \"Manual\" habr\u00eda que hacer la generaci\u00f3n expl\u00edcitamente. Las clases se vuelven a generar si ha habido cambios cada vez que guardamos el modelo de datos ( File>Save o Cmd-S ). No se generan en el directorio del proyecto, de modo que no son visibles directamente, sino en un directorio aparte denominado Derived Data , donde Xcode coloca t\u00edpicamente el c\u00f3digo auxiliar generado por \u00e9l. Este directorio por defecto est\u00e1 en otro lugar totalmente distinto del proyecto, podemos ver d\u00f3nde est\u00e1 en la opci\u00f3n File>Project Settings , aunque no es necesario verlo ni recomendable modificar el contenido generado. Si queremos \"echarle un vistazo\" al fuente de las clases generadas sin tener que ir a la carpeta podemos usar el \"truco\" de hacer Cmd-Click sobre el nombre de una clase que tengamos en el c\u00f3digo. Xcode abre autom\u00e1ticamente el archivo en el que se define. Esto funciona con las clases de nuestro proyecto, con las autogeneradas y almacenadas en Derived Data e incluso con clases del sistema, como por ejemplo UIViewController . Cuando una entidad tiene relaciones a uno o a muchos podemos manipular estas relaciones a trav\u00e9s de propiedades y m\u00e9todos de la clase generada. Veremos esto en la secci\u00f3n dedicada a CRUD. Generaci\u00f3n \"semiautom\u00e1tica\" de las clases \u00b6 Desde la versi\u00f3n 8 de Xcode el modo \"autom\u00e1tico\" es el activo por defecto. No obstante en algunos casos nos interesar\u00e1 personalizar el c\u00f3digo generado por Xcode y para esto no podemos usar la generaci\u00f3n autom\u00e1tica, ya que Xcode sobreescribir\u00eda los cambios hechos manualmente. Xcode tiene un asistente que puede crear las clases que representan a las entidades. Teniendo seleccionada una entidad cualquiera en el editor del modelo de datos, elegimos la opci\u00f3n Editor > Create NSManagedObject Subclass... en el men\u00fa de Xcode. Se activar\u00e1 el asistente, que es bastante sencillo de usar. Solo tenemos que elegir el modelo de datos (si es que tenemos m\u00e1s de uno) y las entidades para las que vamos a generar clases. Por cada entidad Xcode generar\u00e1 dos archivos. Uno de ellos es una clase con el mismo nombre que la entidad (aunque el nombre se puede cambiar, en la secci\u00f3n Configuration del editor del modelo de datos). El otro es una extensi\u00f3n de esta clase. En esta extensi\u00f3n se definen las propiedades de la entidad y un conjunto de m\u00e9todos que nos facilitar\u00e1n el trabajo con las relaciones entre entidades. Si tras generar las clases modificamos las entidades tendremos que borrar manualmente las clases generadas y volver a generarlas. Esto se ha solucionado en Xcode 8, como veremos en la siguiente secci\u00f3n. Vamos a ver un ejemplo del tipo de c\u00f3digo que genera Xcode. Si tuvi\u00e9ramos el modelo de datos de la figura Tras generar clases para todas las entidades, acabaremos con 6 archivos fuente nuevos, dos por cada entidad. Para cada entidad, el primero de ellos tiene el mismo nombre que la entidad terminado en +CoreDataClass.swift . Si lo abrimos veremos que es la definici\u00f3n de una clase \"vac\u00eda\", marcada con algunas anotaciones especiales para que funcione correctamente la maquinaria interna de Core Data. Por ejemplo, para la entidad Usuario tendr\u00edamos algo como: 1 2 3 4 5 6 7 8 // Usuario+CoreDataClass.swift import Foundation import CoreData @objc ( Usuario ) public class Usuario : NSManagedObject { } El segundo de los archivos para cada entidad tiene un nombre terminado en +CoreDataProperties.swift . Este archivo contiene una extensi\u00f3n de la clase anterior. El c\u00f3digo generado tiene dos partes diferenciadas. En primer lugar tenemos la definici\u00f3n de las propiedades , que en el ejemplo ser\u00edan algo como 1 2 3 4 5 @NSManaged public var login : String ? @NSManaged public var creditos : Int16 @NSManaged public var password : String ? @NSManaged public var mensajes : NSSet ? @NSManaged public var conversaciones : NSOrderedSet ? N\u00f3tese que en la definici\u00f3n de la clase tenemos no solo las propiedades de la entidad en s\u00ed sino tambi\u00e9n propiedades que representan las relaciones . Por ejemplo en el diagrama puede verse una relaci\u00f3n uno a muchos entre Usuario y Mensaje llamada mensajes , que representar\u00eda los mensajes enviados por un usuario. Esta relaci\u00f3n se representa en c\u00f3digo con la propiedad del mismo nombre. Esto quiere decir que si tenemos un usuario y vamos imprimiendo los objetos contenidos en la propiedad mensajes en realidad estaremos accediendo a la entidad Mensaje . Esto es mucho m\u00e1s sencillo y \"limpio\" que andar haciendo JOINs en SQL para obtener los datos relacionados. Que las relaciones se vean en c\u00f3digo como propiedades es lo que explica la convenci\u00f3n de darle siempre a una relaci\u00f3n el nombre de la entidad destino en singular si es \"a uno\" y en plural si es \"a muchos\", ya que en c\u00f3digo queda bastante natural. Por ejemplo dado un usuario u sus mensajes ser\u00edan accesibles como u.mensajes , y dado un mensaje m la conversaci\u00f3n a la que pertenece estar\u00eda en m.conversacion . N\u00f3tese que las relaciones \"uno a muchos\" se modelan con NSSet si no son ordenadas. Con esta estructura de datos no se nos garantiza un orden determinado al ir iterando por ella. En el caso de ser una relaci\u00f3n marcada como ordenada Xcode habr\u00eda generado un NSOrderedSet . NSSet es el \"equivalente\" al tipo Set de Swift, pero NSSet est\u00e1 definido en la librer\u00eda Foundation y no en la librer\u00eda est\u00e1ndar de Swift, ya que se desarroll\u00f3 inicialmente para usarse en Objective C, que no tiene un tipo nativo para definir conjuntos. Hay que tener en cuenta que Core Data se desarroll\u00f3 originalmente para Objective C, por lo que la infraestructura para implementarlo se ha \"heredado\" de \u00e9ste. NSSet y NSOrderedSet complican un poco el trabajo cuando en lugar de simplemente leer datos queremos modificarlos (a\u00f1adir un nuevo mensaje a una conversaci\u00f3n, por ejemplo), ya que en Objective C se diferencia entre colecciones mutables e inmutables . En Swift lo que hace que una colecci\u00f3n sea mutable o no es si la declaramos con let o con var , como en el resto de tipos, pero en Foundation cada colecci\u00f3n tiene dos variantes, la \"versi\u00f3n\" mutable y la inmutable. As\u00ed , los NSSet son inmutables , de modo que no podr\u00edamos a\u00f1adir m\u00e1s elementos a la relaci\u00f3n usando directamente la variable. Tendr\u00edamos que obtener una copia mutable de la colecci\u00f3n y trabajar con ella. Una posibilidad para hacer esto es llamar al m\u00e9todo mutableSetValueForKey de NSManagedObject , que nos devolver\u00e1 un conjunto mutable para una propiedad determinada. Para facilitar el trabajo con las relaciones \"a muchos\" Xcode tambi\u00e9n genera m\u00e9todos de acceso para las colecciones, o *accesores *. Estos accesores nos permiten a\u00f1adir/eliminar elementos de la colecci\u00f3n. En el caso del Usuario , generar\u00e1 algo como: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // MARK: Generated accessors for mensajes extension Usuario { @objc ( addMensajesObject :) @NSManaged public func addToMensajes ( _ value : Mensaje ) @objc ( removeMensajesObject :) @NSManaged public func removeFromMensajes ( _ value : Mensaje ) @objc ( addMensajes :) @NSManaged public func addToMensajes ( _ values : NSSet ) @objc ( removeMensajes :) @NSManaged public func removeFromMensajes ( _ values : NSSet ) } De este modo en nuestro c\u00f3digo podemos establecer una relaci\u00f3n entre un determinado usuario y un determinado mensaje sin m\u00e1s que llamar al m\u00e9todo addToMensajes . Por ejemplo podr\u00edamos hacer algo como: 1 2 3 4 5 6 7 //omitimos la parte en la que obtenemos una referencia al contexto de Core Data let u = Usuario ( context : miContexto ) u . login = \"Pepe\" u . password = \"123456\" let m = Mensaje ( context : miContexto ) u . addToMensajes ( m ) try ! miContexto . save ()","title":"Modelar las entidades en c\u00f3digo Swift"},{"location":"cap4/4.2_clases_propias/#generacion-automatica-de-las-clases","text":"Desde Xcode 8 las clases de nuestro modelo de datos se pueden generar autom\u00e1ticamente y de modo transparente para el desarrollador cada vez que guardemos el modelo de datos (el .xcdatamodeld ). En el editor del modelo de datos, si seleccionamos una entidad y accedemos a sus atributos en el panel de la derecha, veremos que hay una secci\u00f3n titulada Class que se ocupa del c\u00f3digo generado, podemos cambiar: El nombre de la clase generada (por defecto el de la entidad) El m\u00f3dulo de Swift donde se crea la clase (por defecto pone Global Namespace , lo que significa que no har\u00e1 falta ning\u00fan import para referenciar la clase) En codegen por defecto aparece seleccionada la opci\u00f3n Class definition , que indica que Xcode va a generar por defecto la clase asociada a la entidad. Con \"Manual\" habr\u00eda que hacer la generaci\u00f3n expl\u00edcitamente. Las clases se vuelven a generar si ha habido cambios cada vez que guardamos el modelo de datos ( File>Save o Cmd-S ). No se generan en el directorio del proyecto, de modo que no son visibles directamente, sino en un directorio aparte denominado Derived Data , donde Xcode coloca t\u00edpicamente el c\u00f3digo auxiliar generado por \u00e9l. Este directorio por defecto est\u00e1 en otro lugar totalmente distinto del proyecto, podemos ver d\u00f3nde est\u00e1 en la opci\u00f3n File>Project Settings , aunque no es necesario verlo ni recomendable modificar el contenido generado. Si queremos \"echarle un vistazo\" al fuente de las clases generadas sin tener que ir a la carpeta podemos usar el \"truco\" de hacer Cmd-Click sobre el nombre de una clase que tengamos en el c\u00f3digo. Xcode abre autom\u00e1ticamente el archivo en el que se define. Esto funciona con las clases de nuestro proyecto, con las autogeneradas y almacenadas en Derived Data e incluso con clases del sistema, como por ejemplo UIViewController . Cuando una entidad tiene relaciones a uno o a muchos podemos manipular estas relaciones a trav\u00e9s de propiedades y m\u00e9todos de la clase generada. Veremos esto en la secci\u00f3n dedicada a CRUD.","title":"Generaci\u00f3n autom\u00e1tica de las clases"},{"location":"cap4/4.2_clases_propias/#generacion-semiautomatica-de-las-clases","text":"Desde la versi\u00f3n 8 de Xcode el modo \"autom\u00e1tico\" es el activo por defecto. No obstante en algunos casos nos interesar\u00e1 personalizar el c\u00f3digo generado por Xcode y para esto no podemos usar la generaci\u00f3n autom\u00e1tica, ya que Xcode sobreescribir\u00eda los cambios hechos manualmente. Xcode tiene un asistente que puede crear las clases que representan a las entidades. Teniendo seleccionada una entidad cualquiera en el editor del modelo de datos, elegimos la opci\u00f3n Editor > Create NSManagedObject Subclass... en el men\u00fa de Xcode. Se activar\u00e1 el asistente, que es bastante sencillo de usar. Solo tenemos que elegir el modelo de datos (si es que tenemos m\u00e1s de uno) y las entidades para las que vamos a generar clases. Por cada entidad Xcode generar\u00e1 dos archivos. Uno de ellos es una clase con el mismo nombre que la entidad (aunque el nombre se puede cambiar, en la secci\u00f3n Configuration del editor del modelo de datos). El otro es una extensi\u00f3n de esta clase. En esta extensi\u00f3n se definen las propiedades de la entidad y un conjunto de m\u00e9todos que nos facilitar\u00e1n el trabajo con las relaciones entre entidades. Si tras generar las clases modificamos las entidades tendremos que borrar manualmente las clases generadas y volver a generarlas. Esto se ha solucionado en Xcode 8, como veremos en la siguiente secci\u00f3n. Vamos a ver un ejemplo del tipo de c\u00f3digo que genera Xcode. Si tuvi\u00e9ramos el modelo de datos de la figura Tras generar clases para todas las entidades, acabaremos con 6 archivos fuente nuevos, dos por cada entidad. Para cada entidad, el primero de ellos tiene el mismo nombre que la entidad terminado en +CoreDataClass.swift . Si lo abrimos veremos que es la definici\u00f3n de una clase \"vac\u00eda\", marcada con algunas anotaciones especiales para que funcione correctamente la maquinaria interna de Core Data. Por ejemplo, para la entidad Usuario tendr\u00edamos algo como: 1 2 3 4 5 6 7 8 // Usuario+CoreDataClass.swift import Foundation import CoreData @objc ( Usuario ) public class Usuario : NSManagedObject { } El segundo de los archivos para cada entidad tiene un nombre terminado en +CoreDataProperties.swift . Este archivo contiene una extensi\u00f3n de la clase anterior. El c\u00f3digo generado tiene dos partes diferenciadas. En primer lugar tenemos la definici\u00f3n de las propiedades , que en el ejemplo ser\u00edan algo como 1 2 3 4 5 @NSManaged public var login : String ? @NSManaged public var creditos : Int16 @NSManaged public var password : String ? @NSManaged public var mensajes : NSSet ? @NSManaged public var conversaciones : NSOrderedSet ? N\u00f3tese que en la definici\u00f3n de la clase tenemos no solo las propiedades de la entidad en s\u00ed sino tambi\u00e9n propiedades que representan las relaciones . Por ejemplo en el diagrama puede verse una relaci\u00f3n uno a muchos entre Usuario y Mensaje llamada mensajes , que representar\u00eda los mensajes enviados por un usuario. Esta relaci\u00f3n se representa en c\u00f3digo con la propiedad del mismo nombre. Esto quiere decir que si tenemos un usuario y vamos imprimiendo los objetos contenidos en la propiedad mensajes en realidad estaremos accediendo a la entidad Mensaje . Esto es mucho m\u00e1s sencillo y \"limpio\" que andar haciendo JOINs en SQL para obtener los datos relacionados. Que las relaciones se vean en c\u00f3digo como propiedades es lo que explica la convenci\u00f3n de darle siempre a una relaci\u00f3n el nombre de la entidad destino en singular si es \"a uno\" y en plural si es \"a muchos\", ya que en c\u00f3digo queda bastante natural. Por ejemplo dado un usuario u sus mensajes ser\u00edan accesibles como u.mensajes , y dado un mensaje m la conversaci\u00f3n a la que pertenece estar\u00eda en m.conversacion . N\u00f3tese que las relaciones \"uno a muchos\" se modelan con NSSet si no son ordenadas. Con esta estructura de datos no se nos garantiza un orden determinado al ir iterando por ella. En el caso de ser una relaci\u00f3n marcada como ordenada Xcode habr\u00eda generado un NSOrderedSet . NSSet es el \"equivalente\" al tipo Set de Swift, pero NSSet est\u00e1 definido en la librer\u00eda Foundation y no en la librer\u00eda est\u00e1ndar de Swift, ya que se desarroll\u00f3 inicialmente para usarse en Objective C, que no tiene un tipo nativo para definir conjuntos. Hay que tener en cuenta que Core Data se desarroll\u00f3 originalmente para Objective C, por lo que la infraestructura para implementarlo se ha \"heredado\" de \u00e9ste. NSSet y NSOrderedSet complican un poco el trabajo cuando en lugar de simplemente leer datos queremos modificarlos (a\u00f1adir un nuevo mensaje a una conversaci\u00f3n, por ejemplo), ya que en Objective C se diferencia entre colecciones mutables e inmutables . En Swift lo que hace que una colecci\u00f3n sea mutable o no es si la declaramos con let o con var , como en el resto de tipos, pero en Foundation cada colecci\u00f3n tiene dos variantes, la \"versi\u00f3n\" mutable y la inmutable. As\u00ed , los NSSet son inmutables , de modo que no podr\u00edamos a\u00f1adir m\u00e1s elementos a la relaci\u00f3n usando directamente la variable. Tendr\u00edamos que obtener una copia mutable de la colecci\u00f3n y trabajar con ella. Una posibilidad para hacer esto es llamar al m\u00e9todo mutableSetValueForKey de NSManagedObject , que nos devolver\u00e1 un conjunto mutable para una propiedad determinada. Para facilitar el trabajo con las relaciones \"a muchos\" Xcode tambi\u00e9n genera m\u00e9todos de acceso para las colecciones, o *accesores *. Estos accesores nos permiten a\u00f1adir/eliminar elementos de la colecci\u00f3n. En el caso del Usuario , generar\u00e1 algo como: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // MARK: Generated accessors for mensajes extension Usuario { @objc ( addMensajesObject :) @NSManaged public func addToMensajes ( _ value : Mensaje ) @objc ( removeMensajesObject :) @NSManaged public func removeFromMensajes ( _ value : Mensaje ) @objc ( addMensajes :) @NSManaged public func addToMensajes ( _ values : NSSet ) @objc ( removeMensajes :) @NSManaged public func removeFromMensajes ( _ values : NSSet ) } De este modo en nuestro c\u00f3digo podemos establecer una relaci\u00f3n entre un determinado usuario y un determinado mensaje sin m\u00e1s que llamar al m\u00e9todo addToMensajes . Por ejemplo podr\u00edamos hacer algo como: 1 2 3 4 5 6 7 //omitimos la parte en la que obtenemos una referencia al contexto de Core Data let u = Usuario ( context : miContexto ) u . login = \"Pepe\" u . password = \"123456\" let m = Mensaje ( context : miContexto ) u . addToMensajes ( m ) try ! miContexto . save ()","title":"Generaci\u00f3n \"semiautom\u00e1tica\" de las clases"},{"location":"cap4/4.3_CRUD/","text":"Las operaciones m\u00e1s b\u00e1sicas con Core Data van a ser las de crear, obtener, actualizar y borrar objetos persistentes, es decir operaciones del tipo Create/Read/Update/Delete o CRUD. Aunque ya hemos explicado algo de esto, vamos a verlo aqu\u00ed de modo m\u00e1s sistem\u00e1tico. Creaci\u00f3n \u00b6 En nuestro c\u00f3digo Swift estamos acostumbrados a crear objetos llamando simplemente al inicializador correspondiente, y podr\u00edamos estar tentados de hacer algo parecido con los objetos de Core Data, por ejemplo 1 2 3 var u = Usuario () u . login = \"Pepe\" ... Pero esto no lo podemos hacer con los objetos persistentes, porque Core Data es quien debe gestionar su ciclo de vida y por tanto los debe \"tener controlados\" en todo momento, desde su creaci\u00f3n. Lo adecuado es pedirle a Core Data que cree el objeto para nosotros. Esto lo hacemos llamando al inicializador que recibe el contexto de persistencia como par\u00e1metro: init(context:) 1 2 3 4 5 //para insertar un objeto, recordar que necesitamos el contexto de Core Data let u = Usuario ( context : miContexto ) //tambi\u00e9n se podr\u00eda hacer con //let u = NSEntityDescription.insertNewObject(forEntityName: \"Usuario\", into: miContexto) as! Usuario u . login = \"Pepe\" Actualizaci\u00f3n \u00b6 Una vez tenemos un objeto gestionado (sea creado con init(context:) o ya existente y recuperado con una fetch request ) podemos cambiar sus propiedades y establecer relaciones con otros objetos. No obstante los cambios solo se har\u00e1n persistentes cuando guardemos el contexto de persistencia con save : 1 2 3 4 5 6 7 //suponemos \"usuario\" objeto gestionado por Core Data //es decir, se ha obtenido con `init(context:)` o una fetch request usuario . login = \"mastermoviles\" ; usuario . password = \"123456\" ; //AHORA es cuando se guardan las modificaciones de modo persistente try ! miContexto . save () Dicho de otro modo, los cambios que hacemos en los objetos son cambios \u00fanicamente dentro del contexto (o si se quiere decir as\u00ed, \u201cen la memoria\u201d). Cuando usamos save los cambios se hacen tambi\u00e9n en el almacenamiento ( store ). Relaciones \"a uno\" \u00b6 Las relaciones \"uno a uno\" se representan con propiedades que son objetos \"individuales\". Por ejemplo un Mensaje pertenece a un Usuario a trav\u00e9s de la relaci\u00f3n usuario . De este modo, podemos tratar la relaci\u00f3n simplemente como una propiedad m\u00e1s. 1 mensaje . usuario = nuevoUsuario Recordemos que normalmente las relaciones son bidireccionales. Si establecemos una relaci\u00f3n entre objetos, Core Data se encargar\u00e1 autom\u00e1ticamente de actualizar la inversa . 1 2 3 4 5 6 7 8 9 10 11 let m = Mensaje ( context : miContexto ) m . texto = \"hola amigos\" m . fecha = Date () //Supongamos \"u\" un objeto Usuario gestionado por Core Data //Establecemos una relaci\u00f3n Mensaje->Usuario m . usuario = u ; //Core Data hace lo propio con Usuario->>Mensaje (1 a N) print ( \"Mensajes del usuario \\( u . login ) \" ) for mensaje in u . mensajes { print ( \" \\( mensaje . fecha ) \\( mensaje . texto ) \" ) } En el ejemplo anterior decimos que un mensaje pertenece a un determinado usuario estableciendo la relaci\u00f3n que va de Mensaje->Usuario. Core Data hace lo propio con la inversa, que va de Usuario->>Mensaje, de modo que si accedemos al usuario e iteramos por los mensajes, veremos el nuevo mensaje que hemos a\u00f1adido. Relaciones \u201ca muchos\u201d \u00b6 Como ya vimos al crear el modelo de datos, si usamos clases propias en el modelo, por cada relaci\u00f3n del tipo \"a muchos\" se genera una propiedad del tipo NSSet ( NSOrderedSet si la relaci\u00f3n es ordenada). N\u00f3tese que son clases inmutables. Si queremos a\u00f1adir o eliminar elementos a la relaci\u00f3n tendremos que copiar la propiedad en un NSMutableSet o NSMutableOrderedSet , hacer la modificaci\u00f3n y luego asignar el nuevo conjunto a la propiedad. Afortunadamente hay una forma mucho m\u00e1s sencilla de a\u00f1adir/eliminar elementos, usar los m\u00e9todos addToXXX y removeFromXXX obtenidos al generar las clases del modelo. Por ejemplo: 1 2 3 4 5 6 7 8 9 10 11 //c1 y u son objetos gestionados por Core Data var c1 : Conversacion var u : Usuario //Supongamos que aqu\u00ed los creamos en el contexto de persistencia ... //c1 es un objeto gestionado por Core Data c1 . comienzo = Date (); //El usuario empieza a participar en una conversaci\u00f3n //Usamos el m\u00e9todo de acceso generado por Core Data u . addToConversaciones ( c1 ); ... Lectura \u00b6 Para recuperar un objeto gestionado por Core Data normalmente se usan fetch requests , que en un entorno de BD se corresponder\u00eda con las consultas. En la siguiente sesi\u00f3n veremos con m\u00e1s detalle la sintaxis, pero por ejemplo obtener todas las instancias de una determinada entidad es sencillo, ya que no hay que especificar condici\u00f3n alguna, solo crear y ejecutar una fetch request del tipo deseado: 1 2 3 4 5 6 7 8 //Creamos la fetch request y decimos que devuelve usuarios let request : NSFetchRequest < Usuario > = NSFetchRequest ( entityName : \"Usuario\" ) //La ejecutamos (deber\u00edamos detectar errores con do...catch, es para acortar el ejemplo) let usuarios = try ! miContexto . fetch ( request ) //recorremos los resultados for usuario in usuarios { print ( usuario . login !) } En las clases generadas por Xcode tenemos un m\u00e9todo de utilidad llamado fetchRequest que simplifica el trabajo de la primera l\u00ednea del ejemplo anterior. As\u00ed, podemos hacer simplemente let request = Usuario.fetchRequest() Borrado \u00b6 Podemos eliminar un objeto del contexto llamando a delete sobre el contexto y pas\u00e1ndole el objeto a eliminar 1 miContexto . delete ( usuario ) Cuidado, delete no elimina el objeto del almac\u00e9n persistente. Para eso tendremos que ejecutar save , como cuando modificamos el objeto y queremos guardar los cambios. Eliminar el objeto del contexto implica que se ejecuten las reglas de borrado. As\u00ed, si por ejemplo hubi\u00e9ramos usado la regla Cascade para la relaci\u00f3n que va desde Conversacion a Mensaje esto implicar\u00eda que al borrar una conversaci\u00f3n del contexto tambi\u00e9n se eliminar\u00edan todos sus mensajes. No obstante, es posible que tras ejecutar delete las actualizaciones no se propaguen de manera inmediata por el grafo de objetos del contexto. Para forzar esta propagaci\u00f3n simplemente hay que llamar al m\u00e9todo processPendingChanges() del contexto.","title":"CRUD en Core Data"},{"location":"cap4/4.3_CRUD/#creacion","text":"En nuestro c\u00f3digo Swift estamos acostumbrados a crear objetos llamando simplemente al inicializador correspondiente, y podr\u00edamos estar tentados de hacer algo parecido con los objetos de Core Data, por ejemplo 1 2 3 var u = Usuario () u . login = \"Pepe\" ... Pero esto no lo podemos hacer con los objetos persistentes, porque Core Data es quien debe gestionar su ciclo de vida y por tanto los debe \"tener controlados\" en todo momento, desde su creaci\u00f3n. Lo adecuado es pedirle a Core Data que cree el objeto para nosotros. Esto lo hacemos llamando al inicializador que recibe el contexto de persistencia como par\u00e1metro: init(context:) 1 2 3 4 5 //para insertar un objeto, recordar que necesitamos el contexto de Core Data let u = Usuario ( context : miContexto ) //tambi\u00e9n se podr\u00eda hacer con //let u = NSEntityDescription.insertNewObject(forEntityName: \"Usuario\", into: miContexto) as! Usuario u . login = \"Pepe\"","title":"Creaci\u00f3n"},{"location":"cap4/4.3_CRUD/#actualizacion","text":"Una vez tenemos un objeto gestionado (sea creado con init(context:) o ya existente y recuperado con una fetch request ) podemos cambiar sus propiedades y establecer relaciones con otros objetos. No obstante los cambios solo se har\u00e1n persistentes cuando guardemos el contexto de persistencia con save : 1 2 3 4 5 6 7 //suponemos \"usuario\" objeto gestionado por Core Data //es decir, se ha obtenido con `init(context:)` o una fetch request usuario . login = \"mastermoviles\" ; usuario . password = \"123456\" ; //AHORA es cuando se guardan las modificaciones de modo persistente try ! miContexto . save () Dicho de otro modo, los cambios que hacemos en los objetos son cambios \u00fanicamente dentro del contexto (o si se quiere decir as\u00ed, \u201cen la memoria\u201d). Cuando usamos save los cambios se hacen tambi\u00e9n en el almacenamiento ( store ).","title":"Actualizaci\u00f3n"},{"location":"cap4/4.3_CRUD/#relaciones-a-uno","text":"Las relaciones \"uno a uno\" se representan con propiedades que son objetos \"individuales\". Por ejemplo un Mensaje pertenece a un Usuario a trav\u00e9s de la relaci\u00f3n usuario . De este modo, podemos tratar la relaci\u00f3n simplemente como una propiedad m\u00e1s. 1 mensaje . usuario = nuevoUsuario Recordemos que normalmente las relaciones son bidireccionales. Si establecemos una relaci\u00f3n entre objetos, Core Data se encargar\u00e1 autom\u00e1ticamente de actualizar la inversa . 1 2 3 4 5 6 7 8 9 10 11 let m = Mensaje ( context : miContexto ) m . texto = \"hola amigos\" m . fecha = Date () //Supongamos \"u\" un objeto Usuario gestionado por Core Data //Establecemos una relaci\u00f3n Mensaje->Usuario m . usuario = u ; //Core Data hace lo propio con Usuario->>Mensaje (1 a N) print ( \"Mensajes del usuario \\( u . login ) \" ) for mensaje in u . mensajes { print ( \" \\( mensaje . fecha ) \\( mensaje . texto ) \" ) } En el ejemplo anterior decimos que un mensaje pertenece a un determinado usuario estableciendo la relaci\u00f3n que va de Mensaje->Usuario. Core Data hace lo propio con la inversa, que va de Usuario->>Mensaje, de modo que si accedemos al usuario e iteramos por los mensajes, veremos el nuevo mensaje que hemos a\u00f1adido.","title":"Relaciones \"a uno\""},{"location":"cap4/4.3_CRUD/#relaciones-a-muchos","text":"Como ya vimos al crear el modelo de datos, si usamos clases propias en el modelo, por cada relaci\u00f3n del tipo \"a muchos\" se genera una propiedad del tipo NSSet ( NSOrderedSet si la relaci\u00f3n es ordenada). N\u00f3tese que son clases inmutables. Si queremos a\u00f1adir o eliminar elementos a la relaci\u00f3n tendremos que copiar la propiedad en un NSMutableSet o NSMutableOrderedSet , hacer la modificaci\u00f3n y luego asignar el nuevo conjunto a la propiedad. Afortunadamente hay una forma mucho m\u00e1s sencilla de a\u00f1adir/eliminar elementos, usar los m\u00e9todos addToXXX y removeFromXXX obtenidos al generar las clases del modelo. Por ejemplo: 1 2 3 4 5 6 7 8 9 10 11 //c1 y u son objetos gestionados por Core Data var c1 : Conversacion var u : Usuario //Supongamos que aqu\u00ed los creamos en el contexto de persistencia ... //c1 es un objeto gestionado por Core Data c1 . comienzo = Date (); //El usuario empieza a participar en una conversaci\u00f3n //Usamos el m\u00e9todo de acceso generado por Core Data u . addToConversaciones ( c1 ); ...","title":"Relaciones \u201ca muchos\u201d"},{"location":"cap4/4.3_CRUD/#lectura","text":"Para recuperar un objeto gestionado por Core Data normalmente se usan fetch requests , que en un entorno de BD se corresponder\u00eda con las consultas. En la siguiente sesi\u00f3n veremos con m\u00e1s detalle la sintaxis, pero por ejemplo obtener todas las instancias de una determinada entidad es sencillo, ya que no hay que especificar condici\u00f3n alguna, solo crear y ejecutar una fetch request del tipo deseado: 1 2 3 4 5 6 7 8 //Creamos la fetch request y decimos que devuelve usuarios let request : NSFetchRequest < Usuario > = NSFetchRequest ( entityName : \"Usuario\" ) //La ejecutamos (deber\u00edamos detectar errores con do...catch, es para acortar el ejemplo) let usuarios = try ! miContexto . fetch ( request ) //recorremos los resultados for usuario in usuarios { print ( usuario . login !) } En las clases generadas por Xcode tenemos un m\u00e9todo de utilidad llamado fetchRequest que simplifica el trabajo de la primera l\u00ednea del ejemplo anterior. As\u00ed, podemos hacer simplemente let request = Usuario.fetchRequest()","title":"Lectura"},{"location":"cap4/4.3_CRUD/#borrado","text":"Podemos eliminar un objeto del contexto llamando a delete sobre el contexto y pas\u00e1ndole el objeto a eliminar 1 miContexto . delete ( usuario ) Cuidado, delete no elimina el objeto del almac\u00e9n persistente. Para eso tendremos que ejecutar save , como cuando modificamos el objeto y queremos guardar los cambios. Eliminar el objeto del contexto implica que se ejecuten las reglas de borrado. As\u00ed, si por ejemplo hubi\u00e9ramos usado la regla Cascade para la relaci\u00f3n que va desde Conversacion a Mensaje esto implicar\u00eda que al borrar una conversaci\u00f3n del contexto tambi\u00e9n se eliminar\u00edan todos sus mensajes. No obstante, es posible que tras ejecutar delete las actualizaciones no se propaguen de manera inmediata por el grafo de objetos del contexto. Para forzar esta propagaci\u00f3n simplemente hay que llamar al m\u00e9todo processPendingChanges() del contexto.","title":"Borrado"},{"location":"cap4/4.4_validaciones/","text":"Como ya hemos visto, cuando definimos el modelo de datos, para cada entidad podemos especificar una serie de reglas de validaci\u00f3n , que var\u00edan seg\u00fan el tipo de datos: por ejemplo para cadenas podemos indicar una longitud m\u00ednima y m\u00e1xima o una expresi\u00f3n regular, para fechas un rango de fechas v\u00e1lidas, para enteros tambi\u00e9n un rango, etc. Eso no quiere decir que no podamos tener un objeto gestionado por Core Data con valores inv\u00e1lidos, ya que de lo \u00fanico que se asegura el framework es que un objeto no v\u00e1lido no se puede guardar en el almacenamiento persistente. Es decir, los errores se disparan al hacer save del contexto. Por ejemplo supongamos que hemos especificado que un Usuario debe tener un \"nivel de usuario\" como m\u00ednimo de 0, y supongamos que intentamos guardar un usuario con \"nivel\" negativo. Al hacer save() se disparar\u00e1 el error. 1 2 3 4 5 6 7 8 9 10 11 let miDelegate = UIApplication . shared . delegate as ! AppDelegate let miContexto = miDelegate . persistentContainer . viewContext let usuario = NSEntityDescription . insertNewObject ( forEntityName : \"Usuario\" , into : miContexto ) as ! Usuario usuario . nivel = - 1 do { try miContexto . save () } catch let miError as NSError { if ( miError . code == NSValidationNumberTooSmallError ) { print ( \"El nivel de usuario no es v\u00e1lido\" ) } } El objeto error contiene bastante informaci\u00f3n sobre el error producido: un c\u00f3digo de error que en este caso ser\u00e1 el 1670 (indicando \"n\u00famero demasiado peque\u00f1o\") y adem\u00e1s un diccionario (propiedad userInfo ) con m\u00faltiples datos sobre el error. En lugar de usar los c\u00f3digos num\u00e9ricos de error podemos usar una serie de constantes que comienzan por NSValidation , en este caso NSValidationNumberTooSmallError indica que es un valor demasiado peque\u00f1o. Podemos escribir nuestros propios validadores a\u00f1adi\u00e9ndole a la clase de la entidad un m\u00e9todo validate<nombre_del_atributo> , o sea si el atributo se llama texto el m\u00e9todo ser\u00eda validateTexto . Este m\u00e9todo debe lanzar una excepci\u00f3n si el objeto no es v\u00e1lido. Pod\u00e9is ver un ejemplo de este tipo de validaci\u00f3n en este tutorial .","title":"Validaciones"},{"location":"cap4/4.5_transformables/","text":"Hasta el momento hemos visto que en una entidad de Core Data puede haber atributos de diversos tipos: enteros, reales, cadenas y fechas. \u00bfY si queremos almacenar un atributo de otro tipo, por ejemplo un array, un diccionario o una instancia de cualquier otra clase no contemplada en los casos anteriores?. Si es una clase propia siempre podemos convertirla en otra entidad, pero puede haber casos en los que no tenga mucho sentido complicar el modelo de este modo. Para estos casos tenemos el tipo transformable , en el que Core Data transformar\u00e1 a binario ( NSData ) el atributo para hacerlo persistente. Y a la inversa, cuando lo lea del almacenamiento lo decodificar\u00e1 de binario al tipo de datos correspondiente. Con los atributos transformables tenemos dos casos posibles: el \"f\u00e1cil\", en el que no tenemos que escribir c\u00f3digo ya que Core Data puede realizar la transformaci\u00f3n autom\u00e1ticamente, y el m\u00e1s complejo, en el que tendremos que implementar nosotros mismos la transformaci\u00f3n. Todo depende de si el dato a almacenar implementa el protocolo NSCoding . Esta es la \"versi\u00f3n antigua\" del Codable de Swift. Las clases que implementan este protocolo son archivables o serializables . As\u00ed que Core Data no hace directamente la transformaci\u00f3n sino que recurre a un mecanismo est\u00e1ndar en iOS para archivar/desarchivar objetos. Por ejemplo supongamos que en una entidad de Core Data quisi\u00e9ramos almacenar un array de String. No podemos crear un atributo de Core Data de este tipo directamente, pero afortunadamente los arrays implementan el protocolo NSCoding , as\u00ed que la transformaci\u00f3n va a ser autom\u00e1tica. Seguir\u00edamos estos pasos En la entidad, definir el tipo del atributo como Transformable . Generar la clase de la entidad con Xcode de manera manual (con Editor>Create NSManagedObject subclass... ) Modificar el archivo fuente generado por Xcode, que habr\u00e1 puesto la propiedad como NSObject y cambiarla por el tipo correspondiente. En este caso [String] . De este modo nos ahorraremos el cast hacia y desde NSObject . La contrapartida es que si volvemos a generar la clase nos tocar\u00e1 volver a editar el archivo. Ya no hay que hacer nada m\u00e1s. Nosotros trataremos con la propiedad como un array de String y autom\u00e1ticamente se har\u00e1 la transformaci\u00f3n hacia y desde binario, que es como se almacenan los datos. En caso de que el tipo de datos del atributo no sea conforme al protocolo NSCoding tendremos que escribir una clase propia que haga la transformaci\u00f3n a y desde binario. En Cocoa esto se hace implementando una clase que herede de NSValueTransformer . Para ver un ejemplo concreto pod\u00e9is consultar este tutorial .","title":"Transformables"},{"location":"cap4/4.6_ejercicios/","text":"En esta sesi\u00f3n vamos a continuar trabajando sobre la aplicaci\u00f3n de notas de la primera sesi\u00f3n de Core Data. Necesitar\u00e1s que la sesi\u00f3n anterior est\u00e9 terminada para poder continuar con esta. Vamos a ampliar el modelo de datos a\u00f1adiendo una nueva entidad, \"Libreta\", que tendr\u00e1 una relaci\u00f3n de uno a muchos con \"Nota\". Cada libreta contendr\u00e1 muchas notas, pero cada nota solo puede estar en una libreta. A\u00f1adir la entidad Libreta (0.25 puntos) \u00b6 A\u00f1adir la entidad Libreta, con un atributo llamado nombre de tipo String Crear una relaci\u00f3n \"a muchos\" de Libreta a Nota y \"a uno\" de Nota a Libreta (la inversa) Recuerda que seg\u00fan las convenciones de Core Data, la relaci\u00f3n de Libreta a Nota se deber\u00eda llamar \"notas\" y la de nota a libreta, \"libreta\". As\u00ed, por ejemplo luego podr\u00edamos acceder a las notas de una libreta miLibreta con miLibreta.notas , lo que resulta intuitivo en el c\u00f3digo. Crear libretas (0.25 puntos) \u00b6 Para simplificar ser\u00e1 un bot\u00f3n \"nueva libreta\" en la pantalla inicial, que al pulsarlo debe mostrar un alert con un campo de texto para escribir el nombre. Tendr\u00e1s que definirte el action correspondiente para detectar que se ha pulsado el bot\u00f3n. En el action puedes llamar al siguiente c\u00f3digo para mostrar el alert : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func nuevaLibreta () { let alert = UIAlertController ( title : \"Nueva libreta\" , message : \"Escribe el nombre para la nueva libreta\" , preferredStyle : . alert ) let crear = UIAlertAction ( title : \"Crear\" , style : . default ) { action in let nombre = alert . textFields ![ 0 ]. text ! //AQUI FALTA GUARDAR LA LIBRETA CON CORE DATA } let cancelar = UIAlertAction ( title : \"Cancelar\" , style : . cancel ) { action in } alert . addAction ( crear ) alert . addAction ( cancelar ) alert . addTextField () { $0 . placeholder = \"Nombre\" } self . present ( alert , animated : true ) } En el c\u00f3digo anterior falta guardar la libreta usando Core Data, implementa esta funcionalidad Listar libretas (0.5 puntos) \u00b6 Antes de empezar con esto aseg\u00farate de que las libretas se est\u00e1n creando correctamente en la base de datos. En el viewWillAppear de la pantalla de lista de notas puedes poner provisionalmente una consulta que las imprima en la consola (luego acu\u00e9rdate de quitarlo) 1 2 3 4 5 6 7 8 9 10 11 override func viewWillAppear ( _ animated : Bool ) { let queryLibretas = NSFetchRequest < Libreta >( entityName : \"Libreta\" ) guard let miDelegate = UIApplication . shared . delegate as ? AppDelegate else { return } let miContexto = miDelegate . persistentContainer . viewContext let libretas = try ! miContexto . fetch ( queryLibretas ) for libreta in libretas { print ( libreta . nombre ) } } Para que el usuario pueda seleccionar la libreta en la pantalla de creaci\u00f3n de notas vamos a usar un picker view , la t\u00edpica \"rueda\" para seleccionar valores de una lista. A\u00f1ade un componente picker view a la pantalla de creaci\u00f3n de notas. Crea un outlet para poder acceder a \u00e9l desde Swift. Dale el nombre que quieras. Desde el punto de vista del c\u00f3digo, un picker view requiere de un delegate y de un datasource (m\u00e1s o menos como las tablas). Crea una nueva clase GestorPicker en un archivo del mismo nombre, as\u00ed no llenamos de tanto c\u00f3digo el ViewController 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import Foundation import UIKit import CoreData class GestorPicker : NSObject , UIPickerViewDelegate , UIPickerViewDataSource { var libretas = [ Libreta ]() //devuelve el n\u00famero de columnas del picker. En nuestro caso solo 1 func numberOfComponents ( in pickerView : UIPickerView ) -> Int { return 1 } //devuelve el n\u00famero de filas del picker (== n\u00famero de libretas) func pickerView ( _ pickerView : UIPickerView , numberOfRowsInComponent component : Int ) -> Int { return self . libretas . count } //devuelve el t\u00edtulo de una fila determinada func pickerView ( _ pickerView : UIPickerView , titleForRow row : Int , forComponent component : Int ) -> String ? { return self . libretas [ row ]. nombre } //para cargar la lista de libretas desde Core Data func cargarLista () { let miDelegate = UIApplication . shared . delegate as ! AppDelegate let miContexto = miDelegate . persistentContainer . viewContext let request = NSFetchRequest < Libreta >( entityName : \"Libreta\" ) self . libretas = try ! miContexto . fetch ( request ) } } Ahora en el ViewController a\u00f1ade una nueva propiedad , una instancia de la clase anterior 1 2 //Esto es una propiedad del ViewController, va dentro de la clase y FUERA de los m\u00e9todos let miGestorPicker = GestorPicker () y en el viewDidLoad del ViewController conectamos el picker con su delegate/datasource y cargamos la lista de libretas con Core Data 1 2 3 4 5 6 //Aqu\u00ed, \"picker\" es el outlet que representa al \"picker view\" //CAMBIALO por el nombre que le hayas dado self . picker . delegate = self . miGestorPicker self . picker . dataSource = self . miGestorPicker //cargamos las libretas con Core Data self . miGestorPicker . cargarLista () Tal como est\u00e1 ahora la aplicaci\u00f3n la lista de libretas debe aparecer cuando se arranca, pero si se a\u00f1ade una nueva libreta no aparecer\u00e1 en el picker hasta que se pare la app y se vuelva a arrancar (que es cuando se llama a cargarLista() ). Puedes arreglarlo haciendo dos cosas justo despu\u00e9s de guardar la nueva libreta con core data (en la funci\u00f3n nuevaLibreta de antes): A\u00f1adir la nueva libreta a la lista que tiene dentro el miGestorPicker : 1 self . miGestorPicker . libretas . append ( libreta ) Decirle al componente picker view que se repinte recargando los datos 1 2 //de nuevo, \"picker\" es el outlet del \"picker view\". C\u00c1MBIALO POR EL TUYO self . picker . reloadAllComponents () Asociar una libreta a la nota actual (0.25 puntos) \u00b6 Falta que cuando se guarde la nota, se le asocie la libreta que aparece seleccionada en el picker view . Igual que asignas el \"texto\" y la \"fecha\" de la nota, as\u00edgnale tambi\u00e9n el objeto libreta usando la relaci\u00f3n \"a uno\" entre Nota y Libreta . Para saber qu\u00e9 n\u00famero de opci\u00f3n est\u00e1 seleccionado actualmente en un picker puedes usar su m\u00e9todo selectedRow : 1 2 //de nuevo, \"picker\" es el outlet del \"picker view\". C\u00c1MBIALO POR EL TUYO let numLibreta = self . picker . selectedRow ( inComponent : 0 ) El objeto Libreta en esa posici\u00f3n ser\u00e1 la misma posici\u00f3n del array libretas del self.miGestorPicker . Mostrar la libreta al listar las notas (0.25 puntos) \u00b6 Puedes mostrar el nombre de la libreta en la parte del texto de detalle de la celda (es la propiedad detailTextLabel de la celda).","title":"Ejercicios de modelos de datos"},{"location":"cap4/4.6_ejercicios/#anadir-la-entidad-libreta-025-puntos","text":"A\u00f1adir la entidad Libreta, con un atributo llamado nombre de tipo String Crear una relaci\u00f3n \"a muchos\" de Libreta a Nota y \"a uno\" de Nota a Libreta (la inversa) Recuerda que seg\u00fan las convenciones de Core Data, la relaci\u00f3n de Libreta a Nota se deber\u00eda llamar \"notas\" y la de nota a libreta, \"libreta\". As\u00ed, por ejemplo luego podr\u00edamos acceder a las notas de una libreta miLibreta con miLibreta.notas , lo que resulta intuitivo en el c\u00f3digo.","title":"A\u00f1adir la entidad Libreta (0.25 puntos)"},{"location":"cap4/4.6_ejercicios/#crear-libretas-025-puntos","text":"Para simplificar ser\u00e1 un bot\u00f3n \"nueva libreta\" en la pantalla inicial, que al pulsarlo debe mostrar un alert con un campo de texto para escribir el nombre. Tendr\u00e1s que definirte el action correspondiente para detectar que se ha pulsado el bot\u00f3n. En el action puedes llamar al siguiente c\u00f3digo para mostrar el alert : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func nuevaLibreta () { let alert = UIAlertController ( title : \"Nueva libreta\" , message : \"Escribe el nombre para la nueva libreta\" , preferredStyle : . alert ) let crear = UIAlertAction ( title : \"Crear\" , style : . default ) { action in let nombre = alert . textFields ![ 0 ]. text ! //AQUI FALTA GUARDAR LA LIBRETA CON CORE DATA } let cancelar = UIAlertAction ( title : \"Cancelar\" , style : . cancel ) { action in } alert . addAction ( crear ) alert . addAction ( cancelar ) alert . addTextField () { $0 . placeholder = \"Nombre\" } self . present ( alert , animated : true ) } En el c\u00f3digo anterior falta guardar la libreta usando Core Data, implementa esta funcionalidad","title":"Crear libretas (0.25 puntos)"},{"location":"cap4/4.6_ejercicios/#listar-libretas-05-puntos","text":"Antes de empezar con esto aseg\u00farate de que las libretas se est\u00e1n creando correctamente en la base de datos. En el viewWillAppear de la pantalla de lista de notas puedes poner provisionalmente una consulta que las imprima en la consola (luego acu\u00e9rdate de quitarlo) 1 2 3 4 5 6 7 8 9 10 11 override func viewWillAppear ( _ animated : Bool ) { let queryLibretas = NSFetchRequest < Libreta >( entityName : \"Libreta\" ) guard let miDelegate = UIApplication . shared . delegate as ? AppDelegate else { return } let miContexto = miDelegate . persistentContainer . viewContext let libretas = try ! miContexto . fetch ( queryLibretas ) for libreta in libretas { print ( libreta . nombre ) } } Para que el usuario pueda seleccionar la libreta en la pantalla de creaci\u00f3n de notas vamos a usar un picker view , la t\u00edpica \"rueda\" para seleccionar valores de una lista. A\u00f1ade un componente picker view a la pantalla de creaci\u00f3n de notas. Crea un outlet para poder acceder a \u00e9l desde Swift. Dale el nombre que quieras. Desde el punto de vista del c\u00f3digo, un picker view requiere de un delegate y de un datasource (m\u00e1s o menos como las tablas). Crea una nueva clase GestorPicker en un archivo del mismo nombre, as\u00ed no llenamos de tanto c\u00f3digo el ViewController 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import Foundation import UIKit import CoreData class GestorPicker : NSObject , UIPickerViewDelegate , UIPickerViewDataSource { var libretas = [ Libreta ]() //devuelve el n\u00famero de columnas del picker. En nuestro caso solo 1 func numberOfComponents ( in pickerView : UIPickerView ) -> Int { return 1 } //devuelve el n\u00famero de filas del picker (== n\u00famero de libretas) func pickerView ( _ pickerView : UIPickerView , numberOfRowsInComponent component : Int ) -> Int { return self . libretas . count } //devuelve el t\u00edtulo de una fila determinada func pickerView ( _ pickerView : UIPickerView , titleForRow row : Int , forComponent component : Int ) -> String ? { return self . libretas [ row ]. nombre } //para cargar la lista de libretas desde Core Data func cargarLista () { let miDelegate = UIApplication . shared . delegate as ! AppDelegate let miContexto = miDelegate . persistentContainer . viewContext let request = NSFetchRequest < Libreta >( entityName : \"Libreta\" ) self . libretas = try ! miContexto . fetch ( request ) } } Ahora en el ViewController a\u00f1ade una nueva propiedad , una instancia de la clase anterior 1 2 //Esto es una propiedad del ViewController, va dentro de la clase y FUERA de los m\u00e9todos let miGestorPicker = GestorPicker () y en el viewDidLoad del ViewController conectamos el picker con su delegate/datasource y cargamos la lista de libretas con Core Data 1 2 3 4 5 6 //Aqu\u00ed, \"picker\" es el outlet que representa al \"picker view\" //CAMBIALO por el nombre que le hayas dado self . picker . delegate = self . miGestorPicker self . picker . dataSource = self . miGestorPicker //cargamos las libretas con Core Data self . miGestorPicker . cargarLista () Tal como est\u00e1 ahora la aplicaci\u00f3n la lista de libretas debe aparecer cuando se arranca, pero si se a\u00f1ade una nueva libreta no aparecer\u00e1 en el picker hasta que se pare la app y se vuelva a arrancar (que es cuando se llama a cargarLista() ). Puedes arreglarlo haciendo dos cosas justo despu\u00e9s de guardar la nueva libreta con core data (en la funci\u00f3n nuevaLibreta de antes): A\u00f1adir la nueva libreta a la lista que tiene dentro el miGestorPicker : 1 self . miGestorPicker . libretas . append ( libreta ) Decirle al componente picker view que se repinte recargando los datos 1 2 //de nuevo, \"picker\" es el outlet del \"picker view\". C\u00c1MBIALO POR EL TUYO self . picker . reloadAllComponents ()","title":"Listar libretas (0.5 puntos)"},{"location":"cap4/4.6_ejercicios/#asociar-una-libreta-a-la-nota-actual-025-puntos","text":"Falta que cuando se guarde la nota, se le asocie la libreta que aparece seleccionada en el picker view . Igual que asignas el \"texto\" y la \"fecha\" de la nota, as\u00edgnale tambi\u00e9n el objeto libreta usando la relaci\u00f3n \"a uno\" entre Nota y Libreta . Para saber qu\u00e9 n\u00famero de opci\u00f3n est\u00e1 seleccionado actualmente en un picker puedes usar su m\u00e9todo selectedRow : 1 2 //de nuevo, \"picker\" es el outlet del \"picker view\". C\u00c1MBIALO POR EL TUYO let numLibreta = self . picker . selectedRow ( inComponent : 0 ) El objeto Libreta en esa posici\u00f3n ser\u00e1 la misma posici\u00f3n del array libretas del self.miGestorPicker .","title":"Asociar una libreta a la nota actual (0.25 puntos)"},{"location":"cap4/4.6_ejercicios/#mostrar-la-libreta-al-listar-las-notas-025-puntos","text":"Puedes mostrar el nombre de la libreta en la parte del texto de detalle de la celda (es la propiedad detailTextLabel de la celda).","title":"Mostrar la libreta al listar las notas (0.25 puntos)"},{"location":"cap4/intro/","text":"Introducci\u00f3n \u00b6 En este tema veremos la parte central de Core Data: el modelo de datos. El modelo de datos es el grafo de objetos (entidades) que implementan nuestra l\u00f3gica de negocio y que queremos que sean persistentes. Ya hemos visto c\u00f3mo definir estas entidades a nivel b\u00e1sico. Veremos c\u00f3mo personalizar las clases de las entidades, lo que simplificar\u00e1 nuestro c\u00f3digo y adem\u00e1s nos permitir\u00e1 a\u00f1adir m\u00e9todos propios a los objetos persistentes. Veremos tambi\u00e9n c\u00f3mo relacionar las entidades entre s\u00ed, ya que como hemos dicho formar\u00e1n un grafo de objetos. Una vez definido el modelo veremos que con Core Data podemos hacer operaciones de tipo CRUD (Create/Read/Update/Delete) de modo sencillo, con una entidad y con las entidades relacionadas. Finalmente veremos un par de funcionalidades que implementa Core Data y que van a ser muy \u00fatiles en nuestras aplicaciones: la validaci\u00f3n de datos y la posibilidad de deshacer/rehacer operaciones.","title":"Introducci\u00f3n"},{"location":"cap4/intro/#introduccion","text":"En este tema veremos la parte central de Core Data: el modelo de datos. El modelo de datos es el grafo de objetos (entidades) que implementan nuestra l\u00f3gica de negocio y que queremos que sean persistentes. Ya hemos visto c\u00f3mo definir estas entidades a nivel b\u00e1sico. Veremos c\u00f3mo personalizar las clases de las entidades, lo que simplificar\u00e1 nuestro c\u00f3digo y adem\u00e1s nos permitir\u00e1 a\u00f1adir m\u00e9todos propios a los objetos persistentes. Veremos tambi\u00e9n c\u00f3mo relacionar las entidades entre s\u00ed, ya que como hemos dicho formar\u00e1n un grafo de objetos. Una vez definido el modelo veremos que con Core Data podemos hacer operaciones de tipo CRUD (Create/Read/Update/Delete) de modo sencillo, con una entidad y con las entidades relacionadas. Finalmente veremos un par de funcionalidades que implementa Core Data y que van a ser muy \u00fatiles en nuestras aplicaciones: la validaci\u00f3n de datos y la posibilidad de deshacer/rehacer operaciones.","title":"Introducci\u00f3n"},{"location":"cap5/3_ciclo_de_vida/","text":"Notificaciones del ciclo de vida \u00b6 Los objetos gestionados van pasando por distintos cambios. Primero son creados u obtenidos de la base de datos con un fetch , luego se modifican sus valores y en alg\u00fan momento se guardan. En muchos casos nos interesar\u00e1 enterarnos de cu\u00e1ndo se realizan estas operaciones. Por ejemplo saber cu\u00e1ndo se crea un objeto puede ser \u00fatil para inicializar valores por defecto, o saber cu\u00e1ndo se modifica un atributo para actualizar la interfaz de usuario. Cuando se crea un nuevo objeto gestionado , Core Data llama a su m\u00e9todo awakeFromInsert . El uso t\u00edpico de este m\u00e9todo, como ya hemos comentado, es el de fijar valores por defecto que no se pueden fijar a trav\u00e9s de la interfaz gr\u00e1fica de Xcode, ya que esta solo permite especificar valores constantes. Por ejemplo, vamos a ver c\u00f3mo har\u00edamos para asignar la fecha actual a un Mensaje al crearlo. Para no tocar las clases de entidades generadas por Xcode, y que podr\u00eda ser necesario borrar y volver a crear, lo hacemos en una extensi\u00f3n propia a la clase Mensaje . El nombre del archivo es arbitrario. 1 2 3 4 5 6 7 8 9 //Archivo Mensaje+Custom.swift import Foundation import CoreData extension Mensaje { override public func awakeFromInsert () { self . fecha = Date () as NSDate } } El cast con as NSDate lo usamos porque al generar las clases para las entidades con Xcode es el tipo que usa por defecto para fechas. Podr\u00edamos modificar manualmente el archivo Mensaje+CoreDataProperties.swift y cambiar el NSDate por un Date para ahorrarnos el cast , pero tendr\u00edamos que hacer el cambio cada vez que gener\u00e1ramos la clase. Aunque suele ser menos \u00fatil que el anterior, tambi\u00e9n podemos enterarnos de cu\u00e1ndo se ha instanciado un objeto a trav\u00e9s de un *fetch * sobreescribiendo el m\u00e9todo awakeFromFetch() . Core Data propiamente dicho no incorpora ning\u00fan mecanismo para saber cu\u00e1ndo se ha modificado un atributo de un objeto gestionado, pero no lo necesita, porque iOS ya tiene un mecanismo gen\u00e9rico: el KVO o Key Value Observing . Con este mecanismo podemos detectar cambios en las propiedades de cualquier objeto que herede de NSObject . Adem\u00e1s las propiedades a observar deben estar marcadas como dynamic ( explicaci\u00f3n en la documentaci\u00f3n de Apple . Estos son requerimientos que limita su utilidad para trabajar con objetos gen\u00e9ricos Swift. Como NSManagedObject ya hereda de \u00e9ste y sus propiedades son dynamic , no tenemos que hacer ning\u00fan esfuerzo adicional para usar KVO con objetos gestionados. KVO es una implementaci\u00f3n del patr\u00f3n de dise\u00f1o Observer . Para usar KVO necesitamos un objeto que pueda ser observado (el objeto gestionado) y otro que act\u00fae como observador. El observador est\u00e1 \"suscrito\" a cambios en una propiedad del objeto observado. 1 2 //decimos que queremos observar al objeto gestionado usuario . addObserver ( self , forKeyPath : \"password\" , options : . new , context : nil ) Los par\u00e1metros indican lo siguiente: El primero es el objeto que va a actuar de observador. En el ejemplo anterior, self , o sea el objeto donde reside este c\u00f3digo que se estaba ejecutando. Aunque puede ser cualquiera El segundo indica la propiedad que queremos observar El tercero es un conjunto de flags que se pueden combinar con | y que indican qu\u00e9 valores quiere recibir el observador. En el ejemplo estamos diciendo que solo queremos conocer el nuevo password , pero ya no sabremos cu\u00e1l era el antiguo. Si por ejemplo quisi\u00e9ramos ambos podr\u00edamos pasar .old | .new El \u00faltimo par\u00e1metro se usa raras veces. Se recomienda consultar la documentaci\u00f3n de Apple. El objeto observador debe tambi\u00e9n heredar de NSObject . Los eventos observables los recibir\u00e1 como llamadas al m\u00e9todo observeValue(forKeyPath:of:change:context:) . El primer par\u00e1metro es la propiedad que ha cambiado El segundo el objeto para el que ha cambiado la propiedad. Estos datos son necesarios porque un mismo observador podr\u00eda estar observando varios objetos, y varias propiedades de cada uno El tercero es el m\u00e1s complejo, y es un diccionario con los valores del cambio. Las claves son constantes que indican el tipo de valor. Por ejemplo, NSKeyValueChangeKey.newKey indica el nuevo valor de la propiedad, y NSKeyValueChangeKey.oldKey indica el antiguo. Los valores que tengamos o no en el diccionario depender\u00e1n de lo que hab\u00edamos especificado en el par\u00e1metro options al suscribirnos. Por ejemplo: 1 2 3 4 5 6 override func observeValue ( forKeyPath keyPath : String ?, of object : Any ?, change : [ NSKeyValueChangeKey : Any ]?, context : UnsafeMutableRawPointer ?) { if keyPath == \"password\" { let nuevoPassword = change ?[. newKey ] print ( \"El nuevo password es \\( nuevoPassword ) \" ) } } Otra posibilidad para observar el ciclo de vida de los objetos gestionados es usar notificaciones . Por ejemplo, cada vez que un objeto se inserta, actualiza o borra en un contexto de persistencia, emite una notificaci\u00f3n de tipo NSManagedObjectContextObjectsDidChangeNotification . M\u00e1s sobre esto en este tutorial .","title":"3 ciclo de vida"},{"location":"cap5/3_ciclo_de_vida/#notificaciones-del-ciclo-de-vida","text":"Los objetos gestionados van pasando por distintos cambios. Primero son creados u obtenidos de la base de datos con un fetch , luego se modifican sus valores y en alg\u00fan momento se guardan. En muchos casos nos interesar\u00e1 enterarnos de cu\u00e1ndo se realizan estas operaciones. Por ejemplo saber cu\u00e1ndo se crea un objeto puede ser \u00fatil para inicializar valores por defecto, o saber cu\u00e1ndo se modifica un atributo para actualizar la interfaz de usuario. Cuando se crea un nuevo objeto gestionado , Core Data llama a su m\u00e9todo awakeFromInsert . El uso t\u00edpico de este m\u00e9todo, como ya hemos comentado, es el de fijar valores por defecto que no se pueden fijar a trav\u00e9s de la interfaz gr\u00e1fica de Xcode, ya que esta solo permite especificar valores constantes. Por ejemplo, vamos a ver c\u00f3mo har\u00edamos para asignar la fecha actual a un Mensaje al crearlo. Para no tocar las clases de entidades generadas por Xcode, y que podr\u00eda ser necesario borrar y volver a crear, lo hacemos en una extensi\u00f3n propia a la clase Mensaje . El nombre del archivo es arbitrario. 1 2 3 4 5 6 7 8 9 //Archivo Mensaje+Custom.swift import Foundation import CoreData extension Mensaje { override public func awakeFromInsert () { self . fecha = Date () as NSDate } } El cast con as NSDate lo usamos porque al generar las clases para las entidades con Xcode es el tipo que usa por defecto para fechas. Podr\u00edamos modificar manualmente el archivo Mensaje+CoreDataProperties.swift y cambiar el NSDate por un Date para ahorrarnos el cast , pero tendr\u00edamos que hacer el cambio cada vez que gener\u00e1ramos la clase. Aunque suele ser menos \u00fatil que el anterior, tambi\u00e9n podemos enterarnos de cu\u00e1ndo se ha instanciado un objeto a trav\u00e9s de un *fetch * sobreescribiendo el m\u00e9todo awakeFromFetch() . Core Data propiamente dicho no incorpora ning\u00fan mecanismo para saber cu\u00e1ndo se ha modificado un atributo de un objeto gestionado, pero no lo necesita, porque iOS ya tiene un mecanismo gen\u00e9rico: el KVO o Key Value Observing . Con este mecanismo podemos detectar cambios en las propiedades de cualquier objeto que herede de NSObject . Adem\u00e1s las propiedades a observar deben estar marcadas como dynamic ( explicaci\u00f3n en la documentaci\u00f3n de Apple . Estos son requerimientos que limita su utilidad para trabajar con objetos gen\u00e9ricos Swift. Como NSManagedObject ya hereda de \u00e9ste y sus propiedades son dynamic , no tenemos que hacer ning\u00fan esfuerzo adicional para usar KVO con objetos gestionados. KVO es una implementaci\u00f3n del patr\u00f3n de dise\u00f1o Observer . Para usar KVO necesitamos un objeto que pueda ser observado (el objeto gestionado) y otro que act\u00fae como observador. El observador est\u00e1 \"suscrito\" a cambios en una propiedad del objeto observado. 1 2 //decimos que queremos observar al objeto gestionado usuario . addObserver ( self , forKeyPath : \"password\" , options : . new , context : nil ) Los par\u00e1metros indican lo siguiente: El primero es el objeto que va a actuar de observador. En el ejemplo anterior, self , o sea el objeto donde reside este c\u00f3digo que se estaba ejecutando. Aunque puede ser cualquiera El segundo indica la propiedad que queremos observar El tercero es un conjunto de flags que se pueden combinar con | y que indican qu\u00e9 valores quiere recibir el observador. En el ejemplo estamos diciendo que solo queremos conocer el nuevo password , pero ya no sabremos cu\u00e1l era el antiguo. Si por ejemplo quisi\u00e9ramos ambos podr\u00edamos pasar .old | .new El \u00faltimo par\u00e1metro se usa raras veces. Se recomienda consultar la documentaci\u00f3n de Apple. El objeto observador debe tambi\u00e9n heredar de NSObject . Los eventos observables los recibir\u00e1 como llamadas al m\u00e9todo observeValue(forKeyPath:of:change:context:) . El primer par\u00e1metro es la propiedad que ha cambiado El segundo el objeto para el que ha cambiado la propiedad. Estos datos son necesarios porque un mismo observador podr\u00eda estar observando varios objetos, y varias propiedades de cada uno El tercero es el m\u00e1s complejo, y es un diccionario con los valores del cambio. Las claves son constantes que indican el tipo de valor. Por ejemplo, NSKeyValueChangeKey.newKey indica el nuevo valor de la propiedad, y NSKeyValueChangeKey.oldKey indica el antiguo. Los valores que tengamos o no en el diccionario depender\u00e1n de lo que hab\u00edamos especificado en el par\u00e1metro options al suscribirnos. Por ejemplo: 1 2 3 4 5 6 override func observeValue ( forKeyPath keyPath : String ?, of object : Any ?, change : [ NSKeyValueChangeKey : Any ]?, context : UnsafeMutableRawPointer ?) { if keyPath == \"password\" { let nuevoPassword = change ?[. newKey ] print ( \"El nuevo password es \\( nuevoPassword ) \" ) } } Otra posibilidad para observar el ciclo de vida de los objetos gestionados es usar notificaciones . Por ejemplo, cada vez que un objeto se inserta, actualiza o borra en un contexto de persistencia, emite una notificaci\u00f3n de tipo NSManagedObjectContextObjectsDidChangeNotification . M\u00e1s sobre esto en este tutorial .","title":"Notificaciones del ciclo de vida"},{"location":"cap5/4_undo/","text":"Deshacer y rehacer \u00b6 Core Data nos ofrece la posibilidad de deshacer y rehacer las operaciones con objetos gestionados. As\u00ed por ejemplo aunque hayamos borrado un objeto con delete , por ejemplo, podemos deshacer de modo muy sencillo el borrado. De esto se encarga el undo manager , un objeto de la clase UndoManager . En principio es algo tan simple como llamar a los m\u00e9todos undo y redo de este objeto. El undo manager es accesible a trav\u00e9s de la propiedad undoManager del contexto 1 2 3 4 //suponiendo que hayamos obtenido el contexto let miContexto = ... //deshacemos la \u00faltima operaci\u00f3n realizada miContexto . undoManager ?. undo () De hecho, podr\u00edamos simplificar todav\u00eda m\u00e1s el c\u00f3digo llamando a miContexto.undo() , que lo que hace en realidad es llamar al undo manager En iOS el undo manager no est\u00e1 activado por defecto, de modo que inicialmente es nil . De ah\u00ed que al acceder a la propiedad undoManager obtengamos un opcional. Justo desp\u00faes de crear el contexto podemos instanciar un UndoManager y pas\u00e1rselo a \u00e9ste. Si estamos usando el c\u00f3digo que genera Xcode 8 para iOS10 al marcar la casilla \"use core data\", el lugar apropiado es tras crear el persistent container , justo antes del return : 1 2 container . viewContext . undoManager = UndoManager () return container Si generamos c\u00f3digo para iOS<10, el lugar apropiado es donde se crea el contexto de persistencia. Una vez activado el undo manager , cuando llamamos a undo por defecto se deshacen las operaciones efectuadas en la \u00faltima ejecuci\u00f3n de c\u00f3digo por parte de la aplicaci\u00f3n (es decir, desde que el sistema \u201ccede el control\u201d a la aplicaci\u00f3n - por ejemplo en un manejador de evento - hasta que la aplicaci\u00f3n vuelve a \u201cpasarle el testigo\u201d al sistema). As\u00ed por ejemplo si al pulsar un bot\u00f3n del interfaz se ejecuta c\u00f3digo que borra una lista de objetos, al deshacer se podr\u00eda recuperar la lista entera, pero no cada objeto individual. No obstante, podemos llamar a beginUndoGrouping y endUndoGrouping para gestionar nosotros mismos la \u201catomicidad\u201d del undo . Por defecto con el undo manager podemos deshacer un n\u00famero ilimitado de operaciones, lo que puede ser problem\u00e1tico con la memoria, ya que hay que \u201cllevar la pista\u201d de todos los cambios que se van haciendo. Para fijar el n\u00famero m\u00e1ximo de operaciones que se puedan deshacer se puede cambiar el valor de la propiedad levelsOfUndo: .","title":"4 undo"},{"location":"cap5/4_undo/#deshacer-y-rehacer","text":"Core Data nos ofrece la posibilidad de deshacer y rehacer las operaciones con objetos gestionados. As\u00ed por ejemplo aunque hayamos borrado un objeto con delete , por ejemplo, podemos deshacer de modo muy sencillo el borrado. De esto se encarga el undo manager , un objeto de la clase UndoManager . En principio es algo tan simple como llamar a los m\u00e9todos undo y redo de este objeto. El undo manager es accesible a trav\u00e9s de la propiedad undoManager del contexto 1 2 3 4 //suponiendo que hayamos obtenido el contexto let miContexto = ... //deshacemos la \u00faltima operaci\u00f3n realizada miContexto . undoManager ?. undo () De hecho, podr\u00edamos simplificar todav\u00eda m\u00e1s el c\u00f3digo llamando a miContexto.undo() , que lo que hace en realidad es llamar al undo manager En iOS el undo manager no est\u00e1 activado por defecto, de modo que inicialmente es nil . De ah\u00ed que al acceder a la propiedad undoManager obtengamos un opcional. Justo desp\u00faes de crear el contexto podemos instanciar un UndoManager y pas\u00e1rselo a \u00e9ste. Si estamos usando el c\u00f3digo que genera Xcode 8 para iOS10 al marcar la casilla \"use core data\", el lugar apropiado es tras crear el persistent container , justo antes del return : 1 2 container . viewContext . undoManager = UndoManager () return container Si generamos c\u00f3digo para iOS<10, el lugar apropiado es donde se crea el contexto de persistencia. Una vez activado el undo manager , cuando llamamos a undo por defecto se deshacen las operaciones efectuadas en la \u00faltima ejecuci\u00f3n de c\u00f3digo por parte de la aplicaci\u00f3n (es decir, desde que el sistema \u201ccede el control\u201d a la aplicaci\u00f3n - por ejemplo en un manejador de evento - hasta que la aplicaci\u00f3n vuelve a \u201cpasarle el testigo\u201d al sistema). As\u00ed por ejemplo si al pulsar un bot\u00f3n del interfaz se ejecuta c\u00f3digo que borra una lista de objetos, al deshacer se podr\u00eda recuperar la lista entera, pero no cada objeto individual. No obstante, podemos llamar a beginUndoGrouping y endUndoGrouping para gestionar nosotros mismos la \u201catomicidad\u201d del undo . Por defecto con el undo manager podemos deshacer un n\u00famero ilimitado de operaciones, lo que puede ser problem\u00e1tico con la memoria, ya que hay que \u201cllevar la pista\u201d de todos los cambios que se van haciendo. Para fijar el n\u00famero m\u00e1ximo de operaciones que se puedan deshacer se puede cambiar el valor de la propiedad levelsOfUndo: .","title":"Deshacer y rehacer"},{"location":"cap5/ejercicios/","text":"","title":"Ejercicios"},{"location":"cap5/intro/","text":"Introducci\u00f3n \u00b6 En este tema seguiremos viendo algunas posibilidades adicionales que nos ofrece el modelo de datos. En primer lugar veremos c\u00f3mo solucionar el problema que se da cuando queremos almacenar datos que no se corresponden con ninguno de los tipos por defecto. Luego veremos c\u00f3mo se validan los datos en Core Data, cu\u00e1l es el ciclo de vida de los objetos gestionados, y finalmente c\u00f3mo deshacer operaciones, caracter\u00edstica muy necesaria para permitir al usuario corregir sus errores si por ejemplo ha borrado alg\u00fan dato sin querer.","title":"Intro"},{"location":"cap5/intro/#introduccion","text":"En este tema seguiremos viendo algunas posibilidades adicionales que nos ofrece el modelo de datos. En primer lugar veremos c\u00f3mo solucionar el problema que se da cuando queremos almacenar datos que no se corresponden con ninguno de los tipos por defecto. Luego veremos c\u00f3mo se validan los datos en Core Data, cu\u00e1l es el ciclo de vida de los objetos gestionados, y finalmente c\u00f3mo deshacer operaciones, caracter\u00edstica muy necesaria para permitir al usuario corregir sus errores si por ejemplo ha borrado alg\u00fan dato sin querer.","title":"Introducci\u00f3n"},{"location":"cap6/1_predicados/","text":"Hasta ahora hemos visto solo como crear fetch request que devuelvan todas las instancias de una entidad, lo que ser\u00eda el equivalente a un SELECT sin WHERE en SQL. Por supuesto podemos filtrar los resultados de una fetch request , y esto lo haremos con predicados , que en el API se representan con la clase NSPredicate . Los predicados son un mecanismo gen\u00e9rico de Cocoa para filtrar colecciones de datos y pueden usarse no solo en Core Data, sino tambi\u00e9n para filtrar arrays o para buscar en spotlight , el mecanismo de b\u00fasqueda est\u00e1ndar de aplicaciones/contactos/documentos dentro de los dispositivos iOS. Veamos un ejemplo de fetch request con predicado: 1 2 3 4 5 6 7 8 9 10 let miDelegate = UIApplication . shared . delegate as ! AppDelegate let miContexto = miDelegate . persistentContainer . viewContext let request = NSFetchRequest < Mensaje >( entityName : \"Mensaje\" ) let pred = NSPredicate ( format : \"texto CONTAINS 'iOS'\" ) request . predicate = pred let resultados = try ! miContexto . fetch ( request ) print ( \"Hay \\( resultados . count ) resultados\" ) for mensaje in resultados { print ( mensaje . texto !) } Como vemos, la \u00fanica diferencia es que instanciamos un NSPredicate con la condici\u00f3n a cumplir y lo asociamos a la propiedad predicate del fetch request . Podemos crear NSPredicate de tres formas distintas: Defini\u00e9ndolo como una cadena , que se parsear\u00e1 y ejecutar\u00e1 como hemos hecho en el ejemplo anterior. En el ejemplo la consulta era \"fija\" pero tambi\u00e9n podemos pasar argumentos. Con un template , que b\u00e1sicamente es un predicado en forma de cadena en el que se incluyen variables, algo as\u00ed como los par\u00e1metros de las queries en SQL. En Core Data podemos crear este tipo de predicados directamente desde el editor del modelo de datos, son las fetch request templates que ya comentamos. Directamente en c\u00f3digo . Tenemos una serie de clases que representan diversas partes del predicado. Por ejemplo un NSComparisonPredicate nos permite representar un operador de comparaci\u00f3n, un NSExpression una expresi\u00f3n (por ejemplo, como expresiones sencillas tendr\u00edamos una variable, un valor constante,\u2026). Con un operador de comparaci\u00f3n que una dos expresiones podemos conseguir algo como lo que hemos hecho en el ejemplo de la localidad. Esta forma de trabajar es engorrosa pero tiene su utilidad en algunos casos, por ejemplo cuando queremos generar din\u00e1micamente una consulta partiendo de cero. Predicados como cadenas \u00b6 Esta es la forma m\u00e1s habitual de definir predicados. El problema es que la cadena se interpreta en tiempo de ejecuci\u00f3n, as\u00ed que los errores de sintaxis no los vamos a detectar hasta entonces. Es algo muy similar a cuando ejecutamos sentencias SQL en nuestro c\u00f3digo. Operadores Los predicados aceptan diversos tipos de operadores y funciones: Los t\u00edpicos operadores de comparaci\u00f3n : = (o == ) < , > , <= , != \u2026 Operadores l\u00f3gicos : AND , OR , NOT (o tambi\u00e9n al estilo C, && , || , ! ). Operadores de comparaci\u00f3n de cadenas : BEGINSWITH , ENDSWITH , CONTAINS , LIKE (como CONTAINS pero admite comodines ? o * ), MATCHES (comprueba si la cadena encaja con una expresi\u00f3n regular en formato ICU ). Estos operadores por defecto distinguen entre may\u00fasculas/min\u00fasculas y s\u00edmbolos diacr\u00edticos (acentos, circunflejos, etc). Si despu\u00e9s del operador ponemos un s\u00edmbolo c entre corchetes indicamos que no queremos distinguir may\u00fasculas/min\u00fasculas, y d hace lo propio con los diacr\u00edticos. Por ejemplo 1 localidad CONTAINS [ c ] ' san ' Encajar\u00eda con \u201cSan vicente\u201d, \u201cFuensanta\u201d, \u201cMassanassa\u201d,\u2026 Pod\u00e9is consultar una referencia m\u00e1s completa en el apartado \u201c Predicate Format String Syntax \u201d de la \u201c Predicate Programming Guide \u201d de Apple. Caracteres de formato En la cadena de la fetch request podemos emplear caracteres de formato al estilo de los que se usan en el printf de C, lo que nos permite pasarle par\u00e1metros. Por ejemplo: 1 2 let cadena = \"iOS\" NSPredicate ( format : \"texto CONTAINS %@ AND fecha<%@\" , argumentArray : [ \"iOS\" , Date ()]) Los caracteres de formato son placeholders donde se van colocando los argumentos que se pasan en forma de array. Los caracteres %@ en concreto representan un objeto (en este caso un String ). Al igual que en el printf de C podemos usar %i para enteros, %f para n\u00fameros reales, etc. N\u00f3tese que, como hab\u00edamos visto en la secci\u00f3n anterior, las cadenas buscadas hay que ponerlas entre comillas (sean simples o dobles). El formateo tiene esto en cuenta y cuando un par\u00e1metro es de tipo String las inserta autom\u00e1ticamente. Esto, que es adecuado para los valores de las propiedades, no lo ser\u00eda si queremos especificar din\u00e1micamente la propiedad. Por ejemplo, el siguiente c\u00f3digo 1 2 3 let atributo = \"login\" ; let subcadena = \"pep\" ; let pred = NSPredicate ( format : \"%@ CONTAINS[c] %@\" , argumentArray :[ atributo , subcadena ]); generar\u00eda el predicado 1 ' login ' CONTAINS [ c ] ' usu ' que no es correcto porque los atributos no se ponen entre comillas. Para especificar que estamos poniendo un nombre de propiedad podemos usar el car\u00e1cter de formato %K , y as\u00ed el formateador no pondr\u00e1 las comillas alrededor. La versi\u00f3n correcta del ejemplo anterior ser\u00eda 1 let pred = NSPredicate ( format : \"%K CONTAINS[c] %@\" , argumentArray :[ atributo , subcadena ]); Templates \u00b6 Como comentamos en sesiones anteriores, en el editor del modelo de datos de Xcode se pueden crear \u201c fetch request templates\u201d o dicho de otro modo, consultas \u201cpredefinidas\u201d. Estas templates tambi\u00e9n se pueden crear por c\u00f3digo, y la diferencia fundamental con las cadenas de formato es que en lugar de usar caracteres gen\u00e9ricos de formato emplean variables, lo que oficialmente se denominan variable expressions (un poco como la diferencia entre los par\u00e1metros por posici\u00f3n y con nombre en SQL). En el editor del modelo podemos crear un fetch request template pulsando unos segundos (sin soltar) sobre el bot\u00f3n de Add entity para que aparezca el men\u00fa contextual, y elegir Add fetch request . El editor permite construir predicados m\u00e1s o menos de forma visual, o tecleando la expresi\u00f3n, que como hemos dicho puede contener variables. Las variables deben ir precedidas del s\u00edmbolo $ ( $cadena , $NOMBRE ,\u2026) El editor visual de templates introduce comillas de m\u00e1s en los nombres de las variables, quedando expresiones como nombre BEGINS WITH \"$cadena\" . En este caso la variable no se reconocer\u00eda como tal al estar entre comillas. Si vamos a usar variables es mejor usar el editor en modo texto. Podemos pasar a este modo pulsando el segundo de los botones que aparecen en la parte superior derecha del editor. Para ejecutar la template en nuestro c\u00f3digo tenemos que recuperarla por nombre a partir del modelo de datos (el NSManagedObjectModel ). Este modelo es accesible en la propiedad managedObjectModel del PersistentContainer . Adem\u00e1s necesitaremos un diccionario que especifique nombre y valor para cada variable. Para el ejemplo de la figura anterior: 1 2 3 4 5 6 7 8 9 10 let miDelegate = UIApplication . shared . delegate as ! AppDelegate let miModelo = miDelegate . persistentContainer . managedObjectModel let dictVars = [ \"cadena\" : \"iOS\" ] if let queryTmpl = miModelo . fetchRequestFromTemplate ( withName : \"textoContiene\" , substitutionVariables : dictVars ) { let results = try ! miContexto . fetch ( queryTmpl ) as ! [ Mensaje ] print ( \"Hay \\( results . count ) resultados en la template\" ) for mensaje in results { print ( mensaje . texto !) } } Predicados sobre relaciones \u00b6 En los predicados podemos incluir no solo los atributos \u201csimples\u201d, sino tambi\u00e9n los que representan relaciones entre objetos. As\u00ed, buscar en una relaci\u00f3n \u201ca uno\u201d es pr\u00e1cticamente igual que buscar en una propiedad convencional. Por ejemplo, vamos a buscar todos los mensajes enviados por un usuario cuyo login comience por m (relaci\u00f3n Mensaje -> Usuario ). Para ello usar\u00edamos un predicado como el que sigue: 1 let pred = NSPredicate ( format : \"usuario.login BEGINSWITH[c] 'm'\" ) Buscar en una relaci\u00f3n \u201ca muchos\u201d es ligeramente m\u00e1s complicado, ya que estamos buscando en una colecci\u00f3n. Podemos usar el operador ANY para verificar que alg\u00fan valor de la colecci\u00f3n cumple la condici\u00f3n. Por ejemplo podemos buscar todos los usuarios que han participado en alguna conversaci\u00f3n en la \u00faltima hora: 1 2 let haceUnaHora = Date ( timeIntervalSinceNow : - 60 * 60 ) let predicado = NSPredicate ( format : \"ANY conversaciones.comienzo>%@\" , argumentArray : [ haceUnaHora ])","title":"Predicados"},{"location":"cap6/1_predicados/#predicados-como-cadenas","text":"Esta es la forma m\u00e1s habitual de definir predicados. El problema es que la cadena se interpreta en tiempo de ejecuci\u00f3n, as\u00ed que los errores de sintaxis no los vamos a detectar hasta entonces. Es algo muy similar a cuando ejecutamos sentencias SQL en nuestro c\u00f3digo.","title":"Predicados como cadenas"},{"location":"cap6/1_predicados/#templates","text":"Como comentamos en sesiones anteriores, en el editor del modelo de datos de Xcode se pueden crear \u201c fetch request templates\u201d o dicho de otro modo, consultas \u201cpredefinidas\u201d. Estas templates tambi\u00e9n se pueden crear por c\u00f3digo, y la diferencia fundamental con las cadenas de formato es que en lugar de usar caracteres gen\u00e9ricos de formato emplean variables, lo que oficialmente se denominan variable expressions (un poco como la diferencia entre los par\u00e1metros por posici\u00f3n y con nombre en SQL). En el editor del modelo podemos crear un fetch request template pulsando unos segundos (sin soltar) sobre el bot\u00f3n de Add entity para que aparezca el men\u00fa contextual, y elegir Add fetch request . El editor permite construir predicados m\u00e1s o menos de forma visual, o tecleando la expresi\u00f3n, que como hemos dicho puede contener variables. Las variables deben ir precedidas del s\u00edmbolo $ ( $cadena , $NOMBRE ,\u2026) El editor visual de templates introduce comillas de m\u00e1s en los nombres de las variables, quedando expresiones como nombre BEGINS WITH \"$cadena\" . En este caso la variable no se reconocer\u00eda como tal al estar entre comillas. Si vamos a usar variables es mejor usar el editor en modo texto. Podemos pasar a este modo pulsando el segundo de los botones que aparecen en la parte superior derecha del editor. Para ejecutar la template en nuestro c\u00f3digo tenemos que recuperarla por nombre a partir del modelo de datos (el NSManagedObjectModel ). Este modelo es accesible en la propiedad managedObjectModel del PersistentContainer . Adem\u00e1s necesitaremos un diccionario que especifique nombre y valor para cada variable. Para el ejemplo de la figura anterior: 1 2 3 4 5 6 7 8 9 10 let miDelegate = UIApplication . shared . delegate as ! AppDelegate let miModelo = miDelegate . persistentContainer . managedObjectModel let dictVars = [ \"cadena\" : \"iOS\" ] if let queryTmpl = miModelo . fetchRequestFromTemplate ( withName : \"textoContiene\" , substitutionVariables : dictVars ) { let results = try ! miContexto . fetch ( queryTmpl ) as ! [ Mensaje ] print ( \"Hay \\( results . count ) resultados en la template\" ) for mensaje in results { print ( mensaje . texto !) } }","title":"Templates"},{"location":"cap6/1_predicados/#predicados-sobre-relaciones","text":"En los predicados podemos incluir no solo los atributos \u201csimples\u201d, sino tambi\u00e9n los que representan relaciones entre objetos. As\u00ed, buscar en una relaci\u00f3n \u201ca uno\u201d es pr\u00e1cticamente igual que buscar en una propiedad convencional. Por ejemplo, vamos a buscar todos los mensajes enviados por un usuario cuyo login comience por m (relaci\u00f3n Mensaje -> Usuario ). Para ello usar\u00edamos un predicado como el que sigue: 1 let pred = NSPredicate ( format : \"usuario.login BEGINSWITH[c] 'm'\" ) Buscar en una relaci\u00f3n \u201ca muchos\u201d es ligeramente m\u00e1s complicado, ya que estamos buscando en una colecci\u00f3n. Podemos usar el operador ANY para verificar que alg\u00fan valor de la colecci\u00f3n cumple la condici\u00f3n. Por ejemplo podemos buscar todos los usuarios que han participado en alguna conversaci\u00f3n en la \u00faltima hora: 1 2 let haceUnaHora = Date ( timeIntervalSinceNow : - 60 * 60 ) let predicado = NSPredicate ( format : \"ANY conversaciones.comienzo>%@\" , argumentArray : [ haceUnaHora ])","title":"Predicados sobre relaciones"},{"location":"cap6/2_ordenacion/","text":"Hasta el momento hemos obtenido los resultados en el orden en que nos los da Core Data, que salvo para las relaciones ordenadas no asegura ning\u00fan orden espec\u00edfico. Podemos especificar diversos criterios de ordenaci\u00f3n usando la clase NSSortDescriptor . Al igual que NSPredicate , esta clase no es propia de Core Data sino de oundation, as\u00ed que se puede usar tambi\u00e9n para ordenar colecciones en memoria. 1 2 3 let credSort = NSSortDescriptor ( key : \"creditos\" , ascending : false ) let loginSort = NSSortDescriptor ( key : \"login\" ascending : true ) miFetchRequest . sortDescriptors = [ credSort , loginSort ] Como se ve, cada NSSortDescriptor referencia la propiedad por la que ordenar y si debe o no ser un orden ascendente. Para usar el sort descriptor , asignamos un array de ellos a la propiedad sortDescriptors de la fetch request . El orden en el array especificar\u00e1 la prioridad en la ordenaci\u00f3n. En este caso se ordenar\u00e1 por orden descendente de cr\u00e9ditos y para los que tengan los mismos cr\u00e9ditos por orden ascendente de login .","title":"Ordenaci\u00f3n"},{"location":"cap6/3_ejercicios/","text":"Vamos a implementar una b\u00fasqueda por texto en la aplicaci\u00f3n de notas sobre la que est\u00e1is trabajando en estas sesiones. Antes de ponerte a hacer las modificaciones de esta sesi\u00f3n aseg\u00farate de que has hecho un commit con el mensaje terminada sesi\u00f3n 2 . Tambi\u00e9n puedes hacer un .zip con el proyecto, llamarlo notas_sesion_2.zip y adjuntarlo en las entregas de la asignatura. As\u00ed cuando se eval\u00fae el ejercicio el profesor podr\u00e1 consultar el estado que ten\u00eda la aplicaci\u00f3n antes de estos ejercicios. Preparaci\u00f3n de la interfaz (0.25 puntos) \u00b6 Necesitamos una barra de b\u00fasqueda para poder introducir la cadena de texto a buscar. Usaremos un UISearchController . Este componente incluye la search bar . En ListaNotasController : Define una propiedad que ser\u00e1 el UISearchController 1 2 //esto debe ser una variable miembro de ListaNotasController let searchController = UISearchController ( searchResultsController : nil ) En el viewDidLoad introduce el siguiente c\u00f3digo, que configura e inicializa el UISearchController 1 2 3 4 5 6 7 8 9 10 //iOS intentar\u00e1 pintar la tabla, hay que inicializarla aunque sea vac\u00eda self . listaNotas = [] //ListaNotasController recibir\u00e1 lo que se est\u00e1 escribiendo en la barra de b\u00fasqueda searchController . searchResultsUpdater = self //Configuramos el search controller searchController . obscuresBackgroundDuringPresentation = false searchController . searchBar . placeholder = \"Buscar texto\" //Lo a\u00f1adimos a la tabla searchController . searchBar . sizeToFit () self . tableView . tableHeaderView = searchController . searchBar La propiedad searchResultsUpdater indica qui\u00e9n es el delegate del UISearchController , en este caso ListaNotasViewController . El delegate debe ser conforme al protocolo UISearchResultsUpdating , que requiere que se implemente un m\u00e9todo llamado updateSearchResults(for:) . Cambia la cabecera de ListaNotasViewController para declarar que es conforme al protocolo UISearchResultsUpdating : 1 2 3 class ListaViewController : UITableViewController , UISearchResultsUpdating { ... } Define en la clase el m\u00e9todo updateSearchResults(for:) 1 2 3 4 func updateSearchResults ( for searchController : UISearchController ) { let texto = searchController . searchBar . text ! print ( \"Buscando \\( texto ) \" ) } Prueba la aplicaci\u00f3n para comprobar que todo est\u00e1 correcto, y deber\u00edas ver que cada vez que se escribe en la barra de b\u00fasqueda se llama a este m\u00e9todo y se imprime en la consola la cadena buscada. Implementaci\u00f3n del c\u00f3digo de b\u00fasqueda (0.5 puntos) \u00b6 updateSearchResults se llama por cada nuevo car\u00e1cter escrito en la barra de b\u00fasquedas, lo que permite actualizar los datos en \"tiempo real\" pero es muy ineficiente. Veremos c\u00f3mo solucionarlo en el siguiente apartado, de momento dispararemos una nueva b\u00fasqueda por cada pulsaci\u00f3n Hecha la preparaci\u00f3n de la interfaz, falta implementar la b\u00fasqueda en s\u00ed. En el m\u00e9todo updateSearchResults debes crear una fetch request que busque las notas cuyo texto contenga el texto escrito en la barra de b\u00fasqueda, sin distinguir may\u00fasculas/min\u00fasculas o caracteres diacr\u00edticos. Recuerda que para que se actualicen los datos visibles debes llamar a tableView.reloadData() Una vez comprobado que funciona, mejora la fetch request para que las notas aparezcan en orden inverso por fecha , de m\u00e1s reciente a m\u00e1s antigua. Throttling de las b\u00fasquedas (0.25 puntos) \u00b6 Lanzar una nueva fetch request por cada car\u00e1cter tecleado es muy ineficiente, sobre todo si el usuario teclea r\u00e1pido y ni siquiera da tiempo a ver los resultados intermedios. Una implementaci\u00f3n mejor har\u00eda throttling de la b\u00fasqueda, es decir, impedir\u00eda que se repita la operaci\u00f3n si todav\u00eda no ha pasado un m\u00ednimo de tiempo desde la anterior. La idea es que si se intenta repetir la operaci\u00f3n y todav\u00eda no ha pasado un tiempo prefijado por nosotros, la nueva operaci\u00f3n se retrase hasta que pase el intervalo de tiempo. Esto no est\u00e1 implementado en los APIs de iOS pero en Internet vpod\u00e9is encontrar diversas implementaciones. La siguiente clase, tomada de este tutorial , implementa esta funcionalidad. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import Foundation //De https://www.craftappco.com/blog/2018/5/30/simple-throttling-in-swift class Throttler { private var workItem : DispatchWorkItem = DispatchWorkItem ( block : {}) private var previousRun : Date = Date . distantPast private let queue : DispatchQueue private let minimumDelay : TimeInterval init ( minimumDelay : TimeInterval , queue : DispatchQueue = DispatchQueue . main ) { self . minimumDelay = minimumDelay self . queue = queue } func throttle ( _ block : @ escaping () -> Void ) { // Cancel any existing work item if it has not yet executed workItem . cancel () // Re-assign workItem with the new block task, resetting the previousRun time when it executes workItem = DispatchWorkItem () { [ weak self ] in self ?. previousRun = Date () block () } // If the time since the previous run is more than the required minimum delay // => execute the workItem immediately // else // => delay the workItem execution by the minimum delay time let delay = previousRun . timeIntervalSinceNow > minimumDelay ? 0 : minimumDelay queue . asyncAfter ( deadline : . now () + Double ( delay ), execute : workItem ) } } Crea un nuevo fichero Swift en tu proyecto con esta clase. Para usarlo en ListaNotasViewController : Define una variable miembro de tipo Throttler con el intervalo de tiempo deseado, por ejemplo 0.5 segundos (no queremos repetir b\u00fasquedas con m\u00e1s frecuencia) 1 let throttler = Throttler ( minimumDelay : 0.5 ) En el updateSearchResults \"envuelve\" tu c\u00f3digo de b\u00fasqueda en un throttle . Autom\u00e1ticamente la clase Throttler se encargar\u00e1 de que el c\u00f3digo no se ejecute m\u00e1s de 1 vez por cada 0.5 segundos (o el intervalo que hayas elegido) 1 2 3 4 5 6 func updateSearchResults ( for searchController : UISearchController ) { throttler . throttle { let texto = searchController . searchBar . text ! //Aqu\u00ed ir\u00eda tu c\u00f3digo de b\u00fasqueda } }","title":"Ejercicios"},{"location":"cap6/3_ejercicios/#preparacion-de-la-interfaz-025-puntos","text":"Necesitamos una barra de b\u00fasqueda para poder introducir la cadena de texto a buscar. Usaremos un UISearchController . Este componente incluye la search bar . En ListaNotasController : Define una propiedad que ser\u00e1 el UISearchController 1 2 //esto debe ser una variable miembro de ListaNotasController let searchController = UISearchController ( searchResultsController : nil ) En el viewDidLoad introduce el siguiente c\u00f3digo, que configura e inicializa el UISearchController 1 2 3 4 5 6 7 8 9 10 //iOS intentar\u00e1 pintar la tabla, hay que inicializarla aunque sea vac\u00eda self . listaNotas = [] //ListaNotasController recibir\u00e1 lo que se est\u00e1 escribiendo en la barra de b\u00fasqueda searchController . searchResultsUpdater = self //Configuramos el search controller searchController . obscuresBackgroundDuringPresentation = false searchController . searchBar . placeholder = \"Buscar texto\" //Lo a\u00f1adimos a la tabla searchController . searchBar . sizeToFit () self . tableView . tableHeaderView = searchController . searchBar La propiedad searchResultsUpdater indica qui\u00e9n es el delegate del UISearchController , en este caso ListaNotasViewController . El delegate debe ser conforme al protocolo UISearchResultsUpdating , que requiere que se implemente un m\u00e9todo llamado updateSearchResults(for:) . Cambia la cabecera de ListaNotasViewController para declarar que es conforme al protocolo UISearchResultsUpdating : 1 2 3 class ListaViewController : UITableViewController , UISearchResultsUpdating { ... } Define en la clase el m\u00e9todo updateSearchResults(for:) 1 2 3 4 func updateSearchResults ( for searchController : UISearchController ) { let texto = searchController . searchBar . text ! print ( \"Buscando \\( texto ) \" ) } Prueba la aplicaci\u00f3n para comprobar que todo est\u00e1 correcto, y deber\u00edas ver que cada vez que se escribe en la barra de b\u00fasqueda se llama a este m\u00e9todo y se imprime en la consola la cadena buscada.","title":"Preparaci\u00f3n de la interfaz (0.25 puntos)"},{"location":"cap6/3_ejercicios/#implementacion-del-codigo-de-busqueda-05-puntos","text":"updateSearchResults se llama por cada nuevo car\u00e1cter escrito en la barra de b\u00fasquedas, lo que permite actualizar los datos en \"tiempo real\" pero es muy ineficiente. Veremos c\u00f3mo solucionarlo en el siguiente apartado, de momento dispararemos una nueva b\u00fasqueda por cada pulsaci\u00f3n Hecha la preparaci\u00f3n de la interfaz, falta implementar la b\u00fasqueda en s\u00ed. En el m\u00e9todo updateSearchResults debes crear una fetch request que busque las notas cuyo texto contenga el texto escrito en la barra de b\u00fasqueda, sin distinguir may\u00fasculas/min\u00fasculas o caracteres diacr\u00edticos. Recuerda que para que se actualicen los datos visibles debes llamar a tableView.reloadData() Una vez comprobado que funciona, mejora la fetch request para que las notas aparezcan en orden inverso por fecha , de m\u00e1s reciente a m\u00e1s antigua.","title":"Implementaci\u00f3n del c\u00f3digo de b\u00fasqueda (0.5 puntos)"},{"location":"cap6/3_ejercicios/#throttling-de-las-busquedas-025-puntos","text":"Lanzar una nueva fetch request por cada car\u00e1cter tecleado es muy ineficiente, sobre todo si el usuario teclea r\u00e1pido y ni siquiera da tiempo a ver los resultados intermedios. Una implementaci\u00f3n mejor har\u00eda throttling de la b\u00fasqueda, es decir, impedir\u00eda que se repita la operaci\u00f3n si todav\u00eda no ha pasado un m\u00ednimo de tiempo desde la anterior. La idea es que si se intenta repetir la operaci\u00f3n y todav\u00eda no ha pasado un tiempo prefijado por nosotros, la nueva operaci\u00f3n se retrase hasta que pase el intervalo de tiempo. Esto no est\u00e1 implementado en los APIs de iOS pero en Internet vpod\u00e9is encontrar diversas implementaciones. La siguiente clase, tomada de este tutorial , implementa esta funcionalidad. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import Foundation //De https://www.craftappco.com/blog/2018/5/30/simple-throttling-in-swift class Throttler { private var workItem : DispatchWorkItem = DispatchWorkItem ( block : {}) private var previousRun : Date = Date . distantPast private let queue : DispatchQueue private let minimumDelay : TimeInterval init ( minimumDelay : TimeInterval , queue : DispatchQueue = DispatchQueue . main ) { self . minimumDelay = minimumDelay self . queue = queue } func throttle ( _ block : @ escaping () -> Void ) { // Cancel any existing work item if it has not yet executed workItem . cancel () // Re-assign workItem with the new block task, resetting the previousRun time when it executes workItem = DispatchWorkItem () { [ weak self ] in self ?. previousRun = Date () block () } // If the time since the previous run is more than the required minimum delay // => execute the workItem immediately // else // => delay the workItem execution by the minimum delay time let delay = previousRun . timeIntervalSinceNow > minimumDelay ? 0 : minimumDelay queue . asyncAfter ( deadline : . now () + Double ( delay ), execute : workItem ) } } Crea un nuevo fichero Swift en tu proyecto con esta clase. Para usarlo en ListaNotasViewController : Define una variable miembro de tipo Throttler con el intervalo de tiempo deseado, por ejemplo 0.5 segundos (no queremos repetir b\u00fasquedas con m\u00e1s frecuencia) 1 let throttler = Throttler ( minimumDelay : 0.5 ) En el updateSearchResults \"envuelve\" tu c\u00f3digo de b\u00fasqueda en un throttle . Autom\u00e1ticamente la clase Throttler se encargar\u00e1 de que el c\u00f3digo no se ejecute m\u00e1s de 1 vez por cada 0.5 segundos (o el intervalo que hayas elegido) 1 2 3 4 5 6 func updateSearchResults ( for searchController : UISearchController ) { throttler . throttle { let texto = searchController . searchBar . text ! //Aqu\u00ed ir\u00eda tu c\u00f3digo de b\u00fasqueda } }","title":"Throttling de las b\u00fasquedas (0.25 puntos)"},{"location":"cap6/intro/","text":"Introducci\u00f3n \u00b6 Hasta ahora solo hemos visto c\u00f3mo recuperar todas las instancias de una clase, pero en cualquier aplicaci\u00f3n medianamente compleja vamos a necesitar hacer b\u00fasquedas sobre el almacenamiento persistente. En esta sesi\u00f3n veremos m\u00e1s detalles sobre c\u00f3mo funcionan las fetch requests y c\u00f3mo filtrar y ordenar los datos para obtener solo los que queremos y en el orden que queremos.","title":"Intro"},{"location":"cap6/intro/#introduccion","text":"Hasta ahora solo hemos visto c\u00f3mo recuperar todas las instancias de una clase, pero en cualquier aplicaci\u00f3n medianamente compleja vamos a necesitar hacer b\u00fasquedas sobre el almacenamiento persistente. En esta sesi\u00f3n veremos m\u00e1s detalles sobre c\u00f3mo funcionan las fetch requests y c\u00f3mo filtrar y ordenar los datos para obtener solo los que queremos y en el orden que queremos.","title":"Introducci\u00f3n"},{"location":"cap7/1_el_frc/","text":"Hasta ahora hemos obtenido los datos de Core Data con fetch requests . En principio no es complicado mostrar estos datos en una tabla, ya que como ya hemos visto, al ejecutar una fetch request obtenemos un array. A lo largo del curso hemos usado m\u00faltiples veces arrays como fuentes de datos para vistas de tabla. Pero hacer esto presenta una serie de dificultades: En primer lugar, se pueden dar problemas de rendimiento . Si hay muchos datos, tenerlos todos en un array ocupar\u00e1 demasiada memoria. Una estrategia m\u00e1s inteligente es ir carg\u00e1ndolos a medida que los vamos necesitando (conforme nos vamos desplazando por la tabla), pero vamos a emplear mucho tiempo implementando esta funcionalidad, que no es trivial. Adem\u00e1s, hay que tener en cuenta que los datos pueden cambiar . Cada vez que cambie un dato tenemos que actualizar manualmente la tabla, lo que es tedioso. La clase FetchedResultsController viene a solucionar todos estos problemas. Por un lado, va a ir obteniendo los datos a medida que sean necesarios, por lotes, o batches . Adem\u00e1s los guardar\u00e1 autom\u00e1ticamente en una cache para aumentar la eficiencia. Y por otro se suscribe a los cambios en el contexto para que cuando cambie un objeto lo podamos reflejar de forma sencilla en la tabla. Trabajar con un fetched results controller no va a ser trivial, pero s\u00ed mucho m\u00e1s sencillo que si tuvi\u00e9ramos que implementar todas estas funcionalidades nosotros mismos.","title":"El \"fetched results controller\""},{"location":"cap7/2_configuracion_basica/","text":"Vamos a empezar con un fetched results controller \"m\u00ednimo\". Supondremos que estamos usando un view controller que hereda de UITableViewController (aunque no va a haber gran diferencia si no usamos esta clase). Lo primero es crear el NSFetchedResultsController . Para ello necesitamos como m\u00ednimo dos cosas: Asociarle una fetch request , que devuelva los datos que queramos mostrar en la tabla. Que dicha request est\u00e9 ordenada. Ya hemos visto que Core Data no asegura por defecto un orden determinado al obtener los resultados de una fetch request , pero las filas de la tabla s\u00ed tienen un orden definido, por lo que necesitamos que los resultados tambi\u00e9n lo tengan. O sea, necesitamos que la request use NSSortDescriptor . Adem\u00e1s podemos crear una cache para que sea m\u00e1s eficiente. Como veremos es muy sencillo y no requiere casi trabajo por nuestra parte. Continuaremos con el ejemplo de los usuarios, las conversaciones y los mensajes. Vamos a hacer por ejemplo una tabla que muestre los mensajes (entidad y clase Mensaje ). Para simplificar el c\u00f3digo, gestionaremos el NSFetchedResultsController en el controller de la pantalla con la tabla. Lo primero es definirnos una propiedad para almacenarlo, ya que lo usaremos en diversos m\u00e9todos: 1 2 3 4 5 6 7 8 import UIKit import CoreData class MiController : UITableViewController { var frc : NSFetchedResultsController < Mensaje > ! ... } En el ejemplo hemos usado un UITableViewController , pero nos servir\u00eda cualquier ViewController . Ahora podemos inicializar el fetched results controller en el viewDidLoad 1 2 3 4 5 6 7 8 9 10 11 12 13 14 override func viewDidLoad () { super . viewDidLoad () let miDelegate = UIApplication . shared . delegate ! as ! AppDelegate let miContexto = miDelegate . persistentContainer . viewContext let consulta = NSFetchRequest < Mensaje >( entityName : \"Mensaje\" ) let sortDescriptors = [ NSSortDescriptor ( key : \"fecha\" , ascending : false )] consulta . sortDescriptors = sortDescriptors self . frc = NSFetchedResultsController < Mensaje >( fetchRequest : consulta , managedObjectContext : miContexto , sectionNameKeyPath : nil , cacheName : \"miCache\" ) //ejecutamos el fetch try ! self . frc . performFetch () } N\u00f3tese que al inicializador debemos pasarle cuatro par\u00e1metros: La fetch request para filtrar los datos, que adem\u00e1s debe estar ordenada con sortDescriptors El contexto de persistencia Un sitio de donde sacar c\u00f3mo se divide la tabla en secciones. Por el momento generamos una \u00fanica secci\u00f3n por lo que ponemos esto a nil Una cache a usar. Aunque hablaremos luego de ella, es tan sencillo crearla que ya lo hemos hecho aqu\u00ed. Basta con elegir un nombre que no usemos para otro fetched results controller . Una vez inicializado el controller llamamos a performFetch para que se ejecute la consulta. Para comprobar que funciona podemos imprimir provisionalmente los datos en la consola: 1 2 3 4 5 6 7 //Esto vendr\u00eda tambi\u00e9n dentro del viewDidLoad, a continuaci\u00f3n de lo anterior if let resultados = frc . fetchedObjects { print ( \"Hay \\( resultados . count ) mensajes\" ) for mensaje in resultados { print ( mensaje . texto !) } } Como puede verse, para ejecutar la query hay que llamar a performFetch() . Los resultados estar\u00e1n accesibles en forma de array en fetchedObjects . No obstante esta no es la forma t\u00edpica de obtener los resultados, para eso hubi\u00e9ramos ejecutado el fetch directamente. En la siguiente secci\u00f3n vamos a \"comunicar\" el fetched results controller con la tabla para que sea ella la que le pida los datos conforme los vaya necesitando.","title":"Inicializar el \"fetched results controller\""},{"location":"cap7/3_tabla/","text":"Recordemos que las tablas toman los datos de su datasource , un objeto que debe implementar una serie de m\u00e9todos que sirven para devolver el contenido: devolver el n\u00famero de secciones, devolver el n\u00famero de filas en una secci\u00f3n y devolver una fila en concreto. El API de fetched results controller tiene m\u00e9todos para hacer precisamente esto, as\u00ed que en nuestro c\u00f3digo nos limitaremos m\u00e1s o menos a \"pasarle la pelota\". Para simplificar el ejemplo haremos que el datasource de la tabla sea el view controller . Vamos a implementar en \u00e9l los m\u00e9todos necesarios. Si usamos un UITableViewController , Xcode habr\u00e1 generado para nosotros el esqueleto de estos m\u00e9todos. Por otro lado, autom\u00e1ticamente el view controller es el datasource de la tabla, conexi\u00f3n que tendr\u00edamos que hacer de modo manual si usamos otro tipo de view controller . Primero vamos a ocuparnos del n\u00famero de secciones . La propiedad sections del fetched results controller , es un array con las secciones de la tabla, as\u00ed que basta con devolver el tama\u00f1o de este array. En realidad por el momento podr\u00edamos devolver simplemente 1 , ya que hemos dicho que no tenemos secciones en la tabla, pero vamos a dejar el c\u00f3digo preparado para no tener que modificarlo luego. 1 2 3 override func numberOfSections ( in tableView : UITableView ) -> Int { return self . frc . sections !. count } Recordemos que frc es una propiedad que hemos definido en el view controller y que referencia al fetched results controller . El m\u00e9todo que devuelve el n\u00famero de filas en la secci\u00f3n actual es solo un poco m\u00e1s complicado 1 2 3 override func tableView ( _ tableView : UITableView , numberOfRowsInSection section : Int ) -> Int { return self . frc . sections ![ section ]. numberOfObjects } Simplemente accedemos a la secci\u00f3n en cuesti\u00f3n y devolvemos su propiedad numberOfObjects , que es el n\u00famero de filas en la secci\u00f3n. Ya solo nos falta el m\u00e9todo m\u00e1s complicado, el que devuelve una fila dada su posici\u00f3n o index path . En realidad es sencillo de implementar, porque el m\u00e9todo object(at:) del fetched results controller nos devuelve un dato dado su index path . Solo tenemos que \"empaquetar\" la informaci\u00f3n en una celda. 1 2 3 4 5 6 7 8 9 override func tableView ( _ tableView : UITableView , cellForRowAt indexPath : IndexPath ) -> UITableViewCell { //recordar que el prototipo de celda tiene un \"reuse identifier\" //que hay que asignar en el storyboard let cell = tableView . dequeueReusableCell ( withIdentifier : \"miCelda\" , for : indexPath ) let mensaje = self . frc . object ( at : indexPath ) cell . textLabel ?. text = mensaje . texto ! return cell } N\u00f3tese que cuando inicializamos el fetched results controller lo hacemos con el tipo Mensaje (como NSFetchedResultsController<Mensaje> ). As\u00ed que cuando obtenemos un objeto con object(at:) Swift \"sabe\" que es un Mensaje y no es necesario hacer el cast . Con todo esto ya tenemos la misma funcionalidad que ten\u00edamos cuando us\u00e1bamos arrays para almacenar los datos de la tabla, a partir de ahora vamos a ver qu\u00e9 ventajas adicionales nos da el fetched results controller frente a la versi\u00f3n anterior.","title":"Mostrar los datos en la tabla"},{"location":"cap7/4_refrescar_tabla/","text":"Tal y como est\u00e1 ahora el c\u00f3digo si creamos un nuevo mensaje este no aparece en la tabla. Pero podemos resolverlo de forma sencilla con el fetched results controller , ya que este est\u00e1 \u201csuscrito\u201d a los cambios que se producen en el contexto de persistencia, siempre que afecten a los contenidos en su fetch request . El fetched results controller avisar\u00e1 a su vez de estos cambios a su delegate . Para simplificar, haremos que este sea el view controller , aunque podr\u00eda ser cualquier clase. 1 2 //En el viewDidLoad, tras crear el fetched results controller self . frc . delegate = self ; Lo anterior, en lugar de por c\u00f3digo, se puede hacer gr\u00e1ficamente en Xcode con el connections inspector . Por tanto tendremos que pasar a implementar el protocolo correspondiente, ya que el fetched results controller llamar\u00e1 a una serie de m\u00e9todos cuando se modifique el contexto. Lo primero es indicarlo en la cabecera de la clase: 1 2 3 4 5 6 import UIKit import CoreData class MiController : UITableViewController , NSFetchedResultsControllerDelegate { ... } El protocolo tiene cuatro m\u00e9todos que vamos a ver a continuaci\u00f3n. Cuando se van a modificar los datos y cuando ya se han modificado el fetched results controller avisar\u00e1 a su delegate llamando a controllerWillChangeContent y controllerDidChangeContent , respectivamente. Podemos aprovechar estos dos m\u00e9todos para llamar al beginUpdates() y endUpdates de la tabla. De este modo si se modifican varias filas \"de golpe\" la animaci\u00f3n se har\u00e1 de forma conjunta. 1 2 3 4 5 6 7 func controllerWillChangeContent ( _ controller : NSFetchedResultsController < NSFetchRequestResult >) { self . tableView . beginUpdates () } func controllerDidChangeContent ( _ controller : NSFetchedResultsController < NSFetchRequestResult >) { self . tableView . endUpdates () } Cuando se ha modificado alg\u00fan objeto del contexto y esta modificaci\u00f3n afecte a los resultados del fetched results controller se llamar\u00e1 al m\u00e9todo m\u00e1s complejo del protocolo: controller(_:didChange:at:for:newIndexPath:) . El c\u00f3digo del m\u00e9todo va a ser algo largo porque aqu\u00ed tenemos que tratar con los cuatro tipos de modificaciones posibles: .insert , .move , .delete y .update . 1 2 3 4 5 6 7 8 9 10 11 12 13 func controller ( _ controller : NSFetchedResultsController < NSFetchRequestResult >, didChange anObject : Any , at indexPath : IndexPath ?, for type : NSFetchedResultsChangeType , newIndexPath : IndexPath ?) { switch type { case . insert : self . tableView . insertRows ( at : [ newIndexPath !], with :. automatic ) case . update : self . tableView . reloadRows ( at : [ indexPath !], with : . automatic ) case . delete : self . tableView . deleteRows ( at : [ indexPath !], with : . automatic ) case . move : self . tableView . deleteRows ( at : [ indexPath !], with : . automatic ) self . tableView . insertRows ( at : [ newIndexPath !], with :. automatic ) } } Como vemos, el c\u00f3digo es bastante directo, simplemente hay que trasladar a la vista de tabla lo que nos est\u00e1 diciendo el fetched results controller : si se ha insertado un dato insertamos una fila, si se ha borrado la borramos, etc. El \u00faltimo de los m\u00e9todos del protocolo se usa cuando se modifican las secciones de la tabla. Todav\u00eda no hemos visto c\u00f3mo decirle al fetched results controller que cree una tabla con secciones, pero no lo necesitamos para ver ya c\u00f3mo se modifican. 1 2 3 4 5 6 7 8 9 func controller ( _ controller : NSFetchedResultsController < NSFetchRequestResult >, didChange sectionInfo : NSFetchedResultsSectionInfo , atSectionIndex sectionIndex : Int , for type : NSFetchedResultsChangeType ) { switch ( type ) { case . insert : self . tableView . insertSections ( IndexSet ( integer : sectionIndex ), with : . automatic ) case . delete : self . tableView . deleteSections ( IndexSet ( integer : sectionIndex ), with : . automatic ) default : break } }","title":"Refrescar la tabla"},{"location":"cap7/5_secciones/","text":"Podemos conseguir generar secciones de modo autom\u00e1tico bas\u00e1ndonos en alguna propiedad de la entidad sobre la que se hace la fetch request . Tiene que ser la misma propiedad que se usa para ordenar o alguna basada en ella, ya que elementos que siguen el orden del listado no pueden ir alternando de secci\u00f3n (las secciones no se repiten). Al crear el fetched results controller especificamos en el par\u00e1metro sectionNameKeyPath la propiedad a usar para generar secciones. Por ejemplo, podr\u00edamos agrupar los mensajes por el t\u00edtulo de la conversaci\u00f3n a la que pertenecen. 1 self . frc = NSFetchedResultsController < Mensaje >( fetchRequest : consulta , managedObjectContext : miContexto , sectionNameKeyPath : \"conversacion.titulo\" , cacheName : \"miCache\" ) En el datasource de la tabla tenemos tambi\u00e9n que implementar el m\u00e9todo que genera los t\u00edtulos de las secciones. El fetched results controller los generar\u00e1 por nosotros, de modo que simplemente podemos obtenerlos de \u00e9l. 1 2 3 override func tableView ( _ tableView : UITableView , titleForHeaderInSection section : Int ) -> String ? { return self . frc . sections ![ section ]. name }","title":"Secciones de tabla autom\u00e1ticas"},{"location":"cap7/6_ejercicios/","text":"Las modificaciones de estos ejercicios no afectan al c\u00f3digo de las sesiones anteriores, as\u00ed que no es necesario que hagas ninguna copia del estado del proyecto antes de empezar con esta sesi\u00f3n. Vamos a ampliar la dichosa aplicaci\u00f3n de notas para que use un fetched results controller . Para no afectar a lo ya hecho, haremos una tercera pantalla con un listado de todas las notas usando un FetchedResultsController (no es necesario implementar b\u00fasqueda como tienes en el otro listado) Interfaz gr\u00e1fico \u00b6 Crea una nueva pantalla de tipo Table View Controller . Conecta la primera pantalla a esta ( Ctrl+Arrastrar y elegir como tipo de segue View Controllers ). Al final en la aplicaci\u00f3n tendr\u00e1s un tab bar con tres opciones. Haz una tercera pantalla, no cambies la que ten\u00edas para que no se pierda el c\u00f3digo que hiciste en la sesi\u00f3n anterior. Evidentemente en una aplicaci\u00f3n \"normal\" no tendr\u00eda sentido tener dos pantallas con la lista de notas. Para esta pantalla, crea una nueva clase ListaNotasCDController (\"CD\" de \u201cCore Data\u201d) que herede de UITableViewController . Recuerda que para que tu clase herede de una de iOS lo m\u00e1s sencillo es usar la plantilla \"Cocoa Touch Class\". Recuerda hacer en el storyboard que esta clase sea el controller de esta pantalla. Para ello, selecciona la pantalla de listado de notas ( clic en el primero de los iconos de la barra superior, el de fondo amarillo) y en el Identity Inspector ( tercero de los iconos del \u00e1rea de la derecha), como \"Custom Class\" elige ListaNotasCDController . Listar notas (0.5 puntos) \u00b6 Listar provisionalmente en la consola \u00b6 Siguiendo el c\u00f3digo de los apuntes y las transparencias usa un fetched results controller para mostrar todas las notas en la tabla . De momento cuando se inserten notas nuevas la lista no se actualizar\u00e1. Primero simplemente haz que los datos aparezcan en la consola (consulta el apartado \"inicializar el fetched results...\" ). Listar notas en la tabla \u00b6 Una vez hecho esto, ya puedes listar las notas en la tabla. Consulta la secci\u00f3n mostrar los datos en la tabla . El problema es que cuando insertes una nueva nota esta no se reflejar\u00e1 en la tabla, solo ver\u00e1s las que hab\u00eda al arrancar la app . Refrescar las notas de la tabla (0.5 puntos) \u00b6 Para esto hay que implementar lo que aparece en la secci\u00f3n \"Refrescar la tabla\" de los apuntes. Una vez hecho, comprueba que cuando insertamos una nota nueva en la pantalla de notas se muestra en la lista del fetched results controller Eliminar filas (0.25 puntos) \u00b6 Para ver c\u00f3mo se modifican las filas \"en directo\", haz que se puedan borrar notas haciendo swipe to delete en la tabla. Para que funcione este gesto, hay que implementar el m\u00e9todo: 1 2 3 4 5 6 7 8 9 10 11 12 override func tableView ( _ tableView : UITableView , commit editingStyle : UITableViewCellEditingStyle , forRowAt indexPath : IndexPath ) { if editingStyle == . delete { let miDelegate = UIApplication . shared . delegate as ! AppDelegate let miContexto = miDelegate . persistentContainer . viewContext //FALTA: eliminar del contexto el objeto en la posici\u00f3n indexPath //Ten\u00e9is que obtenerlo del fetched results controller //parecido a como se hace para pintar la celda ... //guardamos el contexto try ! miContexto . save () } } Ahora puedes probar a borrar una celda haciendo sobre ella el gesto de swipe a la izquierda y ver que se actualiza la lista. Secciones de tabla (0.25 puntos) \u00b6 Finalmente, haz que la tabla tenga secciones autom\u00e1ticas seg\u00fan la primera letra del texto de cada nota. Para ello: Crea una extensi\u00f3n de la clase Nota y a\u00f1\u00e1dele una propiedad calculada llamada inicial que devuelva solo esta: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //Archivo Nota+Custom.swift import Foundation extension Nota { //Devuelve una subcadena solo con la primera letra del texto @objc var inicial : String ? { if let textoNoNil = self . texto { let pos2 = textoNoNil . index ( after : textoNoNil . startIndex ) return textoNoNil . substring ( to : pos2 ) } else { return nil } } } Cuando creas el fetched results controller hay que especificar en el par\u00e1metro sectionNameKeyPath la propiedad usada para dividir en secciones: \"inicial\". En el datasource de la tabla (en nuestro caso el controller ) tienes tambi\u00e9n que implementar el m\u00e9todo que genera los t\u00edtulos de las secciones ( tableView(_:,titleForHeaderInSection) ). Finalmente tendr\u00e1s que cambiar el NSSortDescriptor con el que se crea el fetched results controller para que asegure que las notas no se \"crucen\" de secci\u00f3n. Ten en cuenta que si las sigues ordenando por fecha podr\u00eda haber una que comience por \"a\", otra por \"b\" y luego otra por \"a\" otra vez, y eso no tendr\u00eda sentido de cara a las secciones. Puedes conseguir que no haya problema si ordenas por texto en vez de por fecha.","title":"Ejercicios"},{"location":"cap7/6_ejercicios/#interfaz-grafico","text":"Crea una nueva pantalla de tipo Table View Controller . Conecta la primera pantalla a esta ( Ctrl+Arrastrar y elegir como tipo de segue View Controllers ). Al final en la aplicaci\u00f3n tendr\u00e1s un tab bar con tres opciones. Haz una tercera pantalla, no cambies la que ten\u00edas para que no se pierda el c\u00f3digo que hiciste en la sesi\u00f3n anterior. Evidentemente en una aplicaci\u00f3n \"normal\" no tendr\u00eda sentido tener dos pantallas con la lista de notas. Para esta pantalla, crea una nueva clase ListaNotasCDController (\"CD\" de \u201cCore Data\u201d) que herede de UITableViewController . Recuerda que para que tu clase herede de una de iOS lo m\u00e1s sencillo es usar la plantilla \"Cocoa Touch Class\". Recuerda hacer en el storyboard que esta clase sea el controller de esta pantalla. Para ello, selecciona la pantalla de listado de notas ( clic en el primero de los iconos de la barra superior, el de fondo amarillo) y en el Identity Inspector ( tercero de los iconos del \u00e1rea de la derecha), como \"Custom Class\" elige ListaNotasCDController .","title":"Interfaz gr\u00e1fico"},{"location":"cap7/6_ejercicios/#listar-notas-05-puntos","text":"","title":"Listar notas (0.5 puntos)"},{"location":"cap7/6_ejercicios/#listar-provisionalmente-en-la-consola","text":"Siguiendo el c\u00f3digo de los apuntes y las transparencias usa un fetched results controller para mostrar todas las notas en la tabla . De momento cuando se inserten notas nuevas la lista no se actualizar\u00e1. Primero simplemente haz que los datos aparezcan en la consola (consulta el apartado \"inicializar el fetched results...\" ).","title":"Listar provisionalmente en la consola"},{"location":"cap7/6_ejercicios/#listar-notas-en-la-tabla","text":"Una vez hecho esto, ya puedes listar las notas en la tabla. Consulta la secci\u00f3n mostrar los datos en la tabla . El problema es que cuando insertes una nueva nota esta no se reflejar\u00e1 en la tabla, solo ver\u00e1s las que hab\u00eda al arrancar la app .","title":"Listar notas en la tabla"},{"location":"cap7/6_ejercicios/#refrescar-las-notas-de-la-tabla-05-puntos","text":"Para esto hay que implementar lo que aparece en la secci\u00f3n \"Refrescar la tabla\" de los apuntes. Una vez hecho, comprueba que cuando insertamos una nota nueva en la pantalla de notas se muestra en la lista del fetched results controller","title":"Refrescar las notas de la tabla (0.5 puntos)"},{"location":"cap7/6_ejercicios/#eliminar-filas-025-puntos","text":"Para ver c\u00f3mo se modifican las filas \"en directo\", haz que se puedan borrar notas haciendo swipe to delete en la tabla. Para que funcione este gesto, hay que implementar el m\u00e9todo: 1 2 3 4 5 6 7 8 9 10 11 12 override func tableView ( _ tableView : UITableView , commit editingStyle : UITableViewCellEditingStyle , forRowAt indexPath : IndexPath ) { if editingStyle == . delete { let miDelegate = UIApplication . shared . delegate as ! AppDelegate let miContexto = miDelegate . persistentContainer . viewContext //FALTA: eliminar del contexto el objeto en la posici\u00f3n indexPath //Ten\u00e9is que obtenerlo del fetched results controller //parecido a como se hace para pintar la celda ... //guardamos el contexto try ! miContexto . save () } } Ahora puedes probar a borrar una celda haciendo sobre ella el gesto de swipe a la izquierda y ver que se actualiza la lista.","title":"Eliminar filas (0.25 puntos)"},{"location":"cap7/6_ejercicios/#secciones-de-tabla-025-puntos","text":"Finalmente, haz que la tabla tenga secciones autom\u00e1ticas seg\u00fan la primera letra del texto de cada nota. Para ello: Crea una extensi\u00f3n de la clase Nota y a\u00f1\u00e1dele una propiedad calculada llamada inicial que devuelva solo esta: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //Archivo Nota+Custom.swift import Foundation extension Nota { //Devuelve una subcadena solo con la primera letra del texto @objc var inicial : String ? { if let textoNoNil = self . texto { let pos2 = textoNoNil . index ( after : textoNoNil . startIndex ) return textoNoNil . substring ( to : pos2 ) } else { return nil } } } Cuando creas el fetched results controller hay que especificar en el par\u00e1metro sectionNameKeyPath la propiedad usada para dividir en secciones: \"inicial\". En el datasource de la tabla (en nuestro caso el controller ) tienes tambi\u00e9n que implementar el m\u00e9todo que genera los t\u00edtulos de las secciones ( tableView(_:,titleForHeaderInSection) ). Finalmente tendr\u00e1s que cambiar el NSSortDescriptor con el que se crea el fetched results controller para que asegure que las notas no se \"crucen\" de secci\u00f3n. Ten en cuenta que si las sigues ordenando por fecha podr\u00eda haber una que comience por \"a\", otra por \"b\" y luego otra por \"a\" otra vez, y eso no tendr\u00eda sentido de cara a las secciones. Puedes conseguir que no haya problema si ordenas por texto en vez de por fecha.","title":"Secciones de tabla (0.25 puntos)"},{"location":"cap7/intro/","text":"Introducci\u00f3n \u00b6 Siendo las tablas la forma m\u00e1s t\u00edpica de mostrar listas de datos en pantalla, es natural que en una aplicaci\u00f3n con Core Data mostremos los datos de las entidades en tablas. Para ayudarnos a gestionar la conjunci\u00f3n de tablas y Core Data, iOS nos da el llamado fetched results controller , que simplificar\u00e1 algunos aspectos del desarrollo, asegur\u00e1ndose a la vez de que el rendimiento es lo mejor posible sin que tengamos que preocuparnos de estos aspectos de manera \"manual\".","title":"Intro"},{"location":"cap7/intro/#introduccion","text":"Siendo las tablas la forma m\u00e1s t\u00edpica de mostrar listas de datos en pantalla, es natural que en una aplicaci\u00f3n con Core Data mostremos los datos de las entidades en tablas. Para ayudarnos a gestionar la conjunci\u00f3n de tablas y Core Data, iOS nos da el llamado fetched results controller , que simplificar\u00e1 algunos aspectos del desarrollo, asegur\u00e1ndose a la vez de que el rendimiento es lo mejor posible sin que tengamos que preocuparnos de estos aspectos de manera \"manual\".","title":"Introducci\u00f3n"},{"location":"cap8/1_intro/","text":"si cambiamos un campo de nombre por el morro, sin versiones ni migraci\u00f3n expl\u00edcita, el campo no se renombra, se crea una columna nueva y se borra la antigua, as\u00ed que los datos antiguos pierden ese campo Qu\u00e9 son las migraciones de datos \u00b6 A lo largo del ciclo de desarrollo de una aplicaci\u00f3n, conforme le vayamos a\u00f1adiendo funcionalidades es habitual que el modelo de datos vaya creciendo: iremos a\u00f1adiendo entidades y/o relaciones, o atributos a entidades. En otros casos tendremos que refactorizar el modelo porque nos habremos dado cuenta de que hay ciertas cosas mejorables: quiz\u00e1 tenemos que eliminar atributos, o renombrarlos, o fusionar o dividir entidades, ... Es decir, el modelo de datos va a ir evolucionando en el proceso de desarrollo, incluso despu\u00e9s de lanzar la primera versi\u00f3n de la aplicaci\u00f3n en la App Store. El problema que se plantea al cambiar el modelo de datos existente es qu\u00e9 hacer con los datos que ya tenemos . Por ejemplo si decidimos a\u00f1adir un nuevo atributo debemos pensar qu\u00e9 hacer con los datos que ya existen y que no tienen valor asignado para \u00e9l. Una soluci\u00f3n dr\u00e1stica ser\u00eda comenzar de cero, borrar todos los datos y empezar de nuevo. En desarrollo basta con ir al directorio donde Core Data guarda la base de datos SQLite y eliminarla manualmente (en el directorio Library/Application Support donde reside la aplicaci\u00f3n). Pero evidentemente no podemos decirle a un usuario que al instalar la versi\u00f3n 2.0 de nuestra app va a perder todos sus datos. Hay que definir alg\u00fan procedimiento para transformar los datos ya existentes a la nueva versi\u00f3n del modelo. A este procedimiento de \"traslado\" se le llama migraci\u00f3n de datos . Por ejemplo en el caso del nuevo atributo el procedimiento podr\u00eda ser tan simple como dar un valor por defecto a los datos antiguos, o dejarlo vac\u00edo, dependiendo de los requerimientos de la aplicaci\u00f3n. En la documentaci\u00f3n de Apple se distinguen dos tipos de migraciones: las migraciones ligeras ( lightweight ) y las migraciones \"a secas\" o manuales (o en algunos sitios llamadas pesadas por contraposici\u00f3n a las ligeras). Las primeras son autom\u00e1ticas o semiautom\u00e1ticas, requiriendo en general poco trabajo por nuestra parte o ninguno. Para las segundas vamos a tener que realizar la transformaci\u00f3n de datos de forma manual, generalmente escribiendo c\u00f3digo que indique c\u00f3mo transformar los datos antiguos al nuevo \"formato\". En esta sesi\u00f3n vamos a ver c\u00f3mo hacer migraciones de los dos tipos, pero antes vamos a ver c\u00f3mo \"decirle\" a Core Data que queremos modificar el modelo.","title":"1 intro"},{"location":"cap8/1_intro/#que-son-las-migraciones-de-datos","text":"A lo largo del ciclo de desarrollo de una aplicaci\u00f3n, conforme le vayamos a\u00f1adiendo funcionalidades es habitual que el modelo de datos vaya creciendo: iremos a\u00f1adiendo entidades y/o relaciones, o atributos a entidades. En otros casos tendremos que refactorizar el modelo porque nos habremos dado cuenta de que hay ciertas cosas mejorables: quiz\u00e1 tenemos que eliminar atributos, o renombrarlos, o fusionar o dividir entidades, ... Es decir, el modelo de datos va a ir evolucionando en el proceso de desarrollo, incluso despu\u00e9s de lanzar la primera versi\u00f3n de la aplicaci\u00f3n en la App Store. El problema que se plantea al cambiar el modelo de datos existente es qu\u00e9 hacer con los datos que ya tenemos . Por ejemplo si decidimos a\u00f1adir un nuevo atributo debemos pensar qu\u00e9 hacer con los datos que ya existen y que no tienen valor asignado para \u00e9l. Una soluci\u00f3n dr\u00e1stica ser\u00eda comenzar de cero, borrar todos los datos y empezar de nuevo. En desarrollo basta con ir al directorio donde Core Data guarda la base de datos SQLite y eliminarla manualmente (en el directorio Library/Application Support donde reside la aplicaci\u00f3n). Pero evidentemente no podemos decirle a un usuario que al instalar la versi\u00f3n 2.0 de nuestra app va a perder todos sus datos. Hay que definir alg\u00fan procedimiento para transformar los datos ya existentes a la nueva versi\u00f3n del modelo. A este procedimiento de \"traslado\" se le llama migraci\u00f3n de datos . Por ejemplo en el caso del nuevo atributo el procedimiento podr\u00eda ser tan simple como dar un valor por defecto a los datos antiguos, o dejarlo vac\u00edo, dependiendo de los requerimientos de la aplicaci\u00f3n. En la documentaci\u00f3n de Apple se distinguen dos tipos de migraciones: las migraciones ligeras ( lightweight ) y las migraciones \"a secas\" o manuales (o en algunos sitios llamadas pesadas por contraposici\u00f3n a las ligeras). Las primeras son autom\u00e1ticas o semiautom\u00e1ticas, requiriendo en general poco trabajo por nuestra parte o ninguno. Para las segundas vamos a tener que realizar la transformaci\u00f3n de datos de forma manual, generalmente escribiendo c\u00f3digo que indique c\u00f3mo transformar los datos antiguos al nuevo \"formato\". En esta sesi\u00f3n vamos a ver c\u00f3mo hacer migraciones de los dos tipos, pero antes vamos a ver c\u00f3mo \"decirle\" a Core Data que queremos modificar el modelo.","title":"Qu\u00e9 son las migraciones de datos"},{"location":"cap8/2_versiones/","text":"Versiones del modelo de datos \u00b6 Siendo la evoluci\u00f3n progresiva del modelo de datos algo tan com\u00fan en cualquier desarrollo de aplicaci\u00f3n iOS es l\u00f3gico que Core Data tenga alg\u00fan mecanismo de control de versiones , para que sea accesible el historial de los sucesivos cambios. No estamos hablando del control de versiones general del proyecto, ( git o el que sea que usemos), ya que con el \"tradicional\" Core Data no tiene acceso m\u00e1s que a la \u00faltima versi\u00f3n del modelo. Hasta ahora cuando hemos hecho cualquier modificaci\u00f3n del modelo en nuestros proyectos simplemente la hemos hecho sin m\u00e1s y en su caso hemos guardado los cambios con Cmd-S . Pero esta no es la forma m\u00e1s adecuada de hacerlo. Lo que debemos hacer es especificar que queremos crear una nueva versi\u00f3n del modelo. En cualquier momento dado podemos crear una nueva versi\u00f3n del modelo de datos y tener varias almacenadas en nuestro proyecto (varios archivos xcdatamodeld ) aunque en cada momento solo una de ellas se tomar\u00e1 como la \u201cactual\u201d. Para crear una nueva versi\u00f3n, seleccionar el .xcdatamodeld y en el men\u00fa de Xcode elegir Editor > Add Model Version . Aparecer\u00e1 un cuadro de di\u00e1logo que nos pedir\u00e1 el nombre para la nueva versi\u00f3n y qu\u00e9 versi\u00f3n actual toma como base. A partir de este momento podremos ver en el \u00e1rbol de ficheros del proyecto una especie de sub\u00e1rbol con todas las versiones del .xcdatamodeld . La versi\u00f3n actual o activa en este momento aparece con una peque\u00f1a marca verde de verificaci\u00f3n. Para cambiar de versi\u00f3n activa, en el panel de la derecha, pulsar sobre el primer icono ( Identity and type ), y en la parte inferior del panel elegir la versi\u00f3n en el desplegable Model Version .","title":"2 versiones"},{"location":"cap8/2_versiones/#versiones-del-modelo-de-datos","text":"Siendo la evoluci\u00f3n progresiva del modelo de datos algo tan com\u00fan en cualquier desarrollo de aplicaci\u00f3n iOS es l\u00f3gico que Core Data tenga alg\u00fan mecanismo de control de versiones , para que sea accesible el historial de los sucesivos cambios. No estamos hablando del control de versiones general del proyecto, ( git o el que sea que usemos), ya que con el \"tradicional\" Core Data no tiene acceso m\u00e1s que a la \u00faltima versi\u00f3n del modelo. Hasta ahora cuando hemos hecho cualquier modificaci\u00f3n del modelo en nuestros proyectos simplemente la hemos hecho sin m\u00e1s y en su caso hemos guardado los cambios con Cmd-S . Pero esta no es la forma m\u00e1s adecuada de hacerlo. Lo que debemos hacer es especificar que queremos crear una nueva versi\u00f3n del modelo. En cualquier momento dado podemos crear una nueva versi\u00f3n del modelo de datos y tener varias almacenadas en nuestro proyecto (varios archivos xcdatamodeld ) aunque en cada momento solo una de ellas se tomar\u00e1 como la \u201cactual\u201d. Para crear una nueva versi\u00f3n, seleccionar el .xcdatamodeld y en el men\u00fa de Xcode elegir Editor > Add Model Version . Aparecer\u00e1 un cuadro de di\u00e1logo que nos pedir\u00e1 el nombre para la nueva versi\u00f3n y qu\u00e9 versi\u00f3n actual toma como base. A partir de este momento podremos ver en el \u00e1rbol de ficheros del proyecto una especie de sub\u00e1rbol con todas las versiones del .xcdatamodeld . La versi\u00f3n actual o activa en este momento aparece con una peque\u00f1a marca verde de verificaci\u00f3n. Para cambiar de versi\u00f3n activa, en el panel de la derecha, pulsar sobre el primer icono ( Identity and type ), y en la parte inferior del panel elegir la versi\u00f3n en el desplegable Model Version .","title":"Versiones del modelo de datos"},{"location":"cap8/3_migraciones_ligeras/","text":"Migraciones ligeras \u00b6 Se conocen como migraciones ligeras aquellas en las que Core Data se puede encargar de manera pr\u00e1cticamente autom\u00e1tica de migrar los datos a la nueva versi\u00f3n del modelo. T\u00edpicamente comprenden estas operaciones: A\u00f1adir o eliminar un atributo o relaci\u00f3n Convertir en opcional un atributo requerido Convertir en requerido un atributo opcional, siempre que se d\u00e9 un valor por defecto A\u00f1adir o eliminar una entidad Renombrar un atributo o relaci\u00f3n Renombrar una entidad Hasta iOS9 inclusive, el stack de Core Data que creaba Xcode marcando la casilla Use Core Data al crear un proyecto no ten\u00eda activadas las migraciones ligeras por defecto. As\u00ed, cualquier cambio en el modelo llevaba a que la aplicaci\u00f3n dejara de funcionar, generando un error, y tuvi\u00e9ramos que borrar la base de datos manualmente para que volviera a hacerlo. Para averiguar c\u00f3mo activar las migraciones ligeras en iOS<=9 se puede consultar el \u00faltimo punto de los apuntes de esta sesi\u00f3n. A partir de iOS10, si se usa la clase NSPersistentContainer para inicializar el stack de Core Data no hay que hacer nada especial para activar las migraciones ligeras . ya que vienen activadas por defecto. Recordemos que el c\u00f3digo de la plantilla de Xcode usa esta clase, as\u00ed que normalmente no tendremos que hacer nada. Esto quiere decir que podemos hacer cualquier modificaci\u00f3n de las listadas antes sin m\u00e1s, aunque se recomienda no modificar el modelo de datos directamente sino crear una nueva versi\u00f3n cada vez que cambiemos algo, como se explica en el apartado anterior. Para algunos tipos de modificaci\u00f3n la migraci\u00f3n autom\u00e1tica que hace por defecto Core Data es apropiada en la mayor\u00eda de casos, pero en otros tendremos que \"ayudarle\" algo, aunque siempre de modo sencillo. Por ejemplo, en caso de a\u00f1adir un atributo a una entidad existente, si especificamos un valor por defecto, Core Data lo fijar\u00e1 tambi\u00e9n para los datos que ya exist\u00edan, lo que es generalmente la mejor soluci\u00f3n. Sin embargo, al renombrar un atributo o entidad Core Data no detecta autom\u00e1ticamente que es un renombrado sino que lo interpreta por defecto como una eliminaci\u00f3n del antiguo y la creaci\u00f3n del nuevo, de modo que los antiguos valores se perder\u00e1n. Esto tiene sentido si pensamos que Core Data solo tiene acceso al estado actual del modelo, y no al proceso de edici\u00f3n en s\u00ed. Para indicarle a Core Data que no es un nuevo atributo sino el antiguo renombrado, vamos al panel de la derecha, y habiendo pulsado el tercero de los iconos ( `Data Model Inspector), en el cuadro de texto llamado Renaming ID` tecleamos el nombre antiguo. Si hacemos esto, al migrar los datos se renombrar\u00e1 la columna de la tabla en lugar de crear una. En todos los lugares donde antes se hiciera referencia al atributo con el nombre antiguo habr\u00e1 que cambiar el c\u00f3digo para que reflejen el nuevo nombre. Por desgracia Xcode no nos va a ayudar en esta tarea. La configuraci\u00f3n que hemos hecho en el editor del modelo indicando cu\u00e1l era el nombre antiguo es lo que en Core Data se llama un mapping model , es decir una asociaci\u00f3n de elementos que permite pasar del modelo antiguo al nuevo. Veremos otras formas de especificar mapping models , bien sea gr\u00e1ficamente o por c\u00f3digo.","title":"3 migraciones ligeras"},{"location":"cap8/3_migraciones_ligeras/#migraciones-ligeras","text":"Se conocen como migraciones ligeras aquellas en las que Core Data se puede encargar de manera pr\u00e1cticamente autom\u00e1tica de migrar los datos a la nueva versi\u00f3n del modelo. T\u00edpicamente comprenden estas operaciones: A\u00f1adir o eliminar un atributo o relaci\u00f3n Convertir en opcional un atributo requerido Convertir en requerido un atributo opcional, siempre que se d\u00e9 un valor por defecto A\u00f1adir o eliminar una entidad Renombrar un atributo o relaci\u00f3n Renombrar una entidad Hasta iOS9 inclusive, el stack de Core Data que creaba Xcode marcando la casilla Use Core Data al crear un proyecto no ten\u00eda activadas las migraciones ligeras por defecto. As\u00ed, cualquier cambio en el modelo llevaba a que la aplicaci\u00f3n dejara de funcionar, generando un error, y tuvi\u00e9ramos que borrar la base de datos manualmente para que volviera a hacerlo. Para averiguar c\u00f3mo activar las migraciones ligeras en iOS<=9 se puede consultar el \u00faltimo punto de los apuntes de esta sesi\u00f3n. A partir de iOS10, si se usa la clase NSPersistentContainer para inicializar el stack de Core Data no hay que hacer nada especial para activar las migraciones ligeras . ya que vienen activadas por defecto. Recordemos que el c\u00f3digo de la plantilla de Xcode usa esta clase, as\u00ed que normalmente no tendremos que hacer nada. Esto quiere decir que podemos hacer cualquier modificaci\u00f3n de las listadas antes sin m\u00e1s, aunque se recomienda no modificar el modelo de datos directamente sino crear una nueva versi\u00f3n cada vez que cambiemos algo, como se explica en el apartado anterior. Para algunos tipos de modificaci\u00f3n la migraci\u00f3n autom\u00e1tica que hace por defecto Core Data es apropiada en la mayor\u00eda de casos, pero en otros tendremos que \"ayudarle\" algo, aunque siempre de modo sencillo. Por ejemplo, en caso de a\u00f1adir un atributo a una entidad existente, si especificamos un valor por defecto, Core Data lo fijar\u00e1 tambi\u00e9n para los datos que ya exist\u00edan, lo que es generalmente la mejor soluci\u00f3n. Sin embargo, al renombrar un atributo o entidad Core Data no detecta autom\u00e1ticamente que es un renombrado sino que lo interpreta por defecto como una eliminaci\u00f3n del antiguo y la creaci\u00f3n del nuevo, de modo que los antiguos valores se perder\u00e1n. Esto tiene sentido si pensamos que Core Data solo tiene acceso al estado actual del modelo, y no al proceso de edici\u00f3n en s\u00ed. Para indicarle a Core Data que no es un nuevo atributo sino el antiguo renombrado, vamos al panel de la derecha, y habiendo pulsado el tercero de los iconos ( `Data Model Inspector), en el cuadro de texto llamado Renaming ID` tecleamos el nombre antiguo. Si hacemos esto, al migrar los datos se renombrar\u00e1 la columna de la tabla en lugar de crear una. En todos los lugares donde antes se hiciera referencia al atributo con el nombre antiguo habr\u00e1 que cambiar el c\u00f3digo para que reflejen el nuevo nombre. Por desgracia Xcode no nos va a ayudar en esta tarea. La configuraci\u00f3n que hemos hecho en el editor del modelo indicando cu\u00e1l era el nombre antiguo es lo que en Core Data se llama un mapping model , es decir una asociaci\u00f3n de elementos que permite pasar del modelo antiguo al nuevo. Veremos otras formas de especificar mapping models , bien sea gr\u00e1ficamente o por c\u00f3digo.","title":"Migraciones ligeras"},{"location":"cap8/4_migraciones_pesadas/","text":"Migraciones \u201cpesadas\u201d \u00b6 Hay muchos cambios que no encajan en las operaciones previstas en las migraciones \u201cligeras\u201d. Por ejemplo supongamos que tenemos el nombre y apellidos en un campo nombre_completo en el t\u00edpico formato de apellido_1 apellido_2, nombre y queremos dividirlo en dos campos: apellidos y nombre (o al contrario, partimos de dos y los queremos fusionar). En estos casos Core Data no puede inferir autom\u00e1ticamente la forma de transformar el modelo origen al modelo objetivo, y tenemos que especificar \u201cmanualmente\u201d c\u00f3mo hacer la transformaci\u00f3n. Como hemos dicho, la transformaci\u00f3n entre un modelo y otro se representa en iOS mediante un mapping model , y es lo que tenemos que darle a Core Data para que pueda actualizar los datos al nuevo modelo. Lo que har\u00e1 Core Data durante el proceso de migraci\u00f3n es cargar cada entidad en memoria, convertirla del modelo actual al nuevo ayud\u00e1ndose del mapping model y guardarla de nuevo en el almacenamiento persistente. Y hemos dicho Core Data, pero en realidad lo que tendremos que hacer ser\u00e1 escribir nosotros c\u00f3digo que haga esta tarea. Adem\u00e1s del trabajo para nosotros, las migraciones de este tipo son mucho m\u00e1s costosas en tiempo y capacidad de procesamiento que las ligeras. Normalmente la aplicaci\u00f3n necesitar\u00e1 mostrar al usuario un cuadro de di\u00e1logo o similar que le indique que se est\u00e1 realizando la operaci\u00f3n. Vamos a ver c\u00f3mo se implementar\u00eda una migraci\u00f3n \u201cpesada\u201d con un ejemplo concreto. Supongamos que en la aplicaci\u00f3n de notas nos hemos dado cuenta de que el campo \u201ccategoria\u201d no est\u00e1 del todo bien, ya que as\u00ed solo podemos hacer que una nota pertenezca a una \u00fanica categor\u00eda, y adem\u00e1s cuando varias notas tienen la misma categor\u00eda cada una debe repetir el valor. Ser\u00eda mejor tener una entidad \u201ccategor\u00eda\u201d aparte y establecer una relaci\u00f3n \u201cuno a muchos\u201d en ambas direcciones. Lo primero es crear una nueva versi\u00f3n del modelo de datos con este cambio. Crear el \u201cmapping model\u201d \u00b6 El nuevo modelo de datos tendr\u00e1 el aspecto de la siguiente figura: ahora tenemos que crear el mapping model que nos transforme el modelo actual en el nuevo modelo. En File > New seleccionamos la categor\u00eda Core Data y elegimos la plantilla Mapping Model . El asistente nos preguntar\u00e1 cu\u00e1l es el modelo origen, cu\u00e1l el destino, y nos pedir\u00e1 un nombre para el nuevo archivo .xcmappingmodel que crear\u00e1. Si abrimos el archivo creado, veremos que Xcode ha intentado deducir la correspondencia entre el modelo origen y el destino. A la izquierda veremos los Entity Mappings (c\u00f3mo pasar de una entidad antigua a una nueva). T\u00edpicamente a estos los llama con el nombre de la entidad antigua y la nueva, algo como NotaToNota . Para las entidades nuevas pone simplemente el nombre de la entidad. Para cada Entity Mapping tenemos los Attribute Mappings y los Relationship mappings correspondientes. Se usa un conjunto de variables predefinido para expresarlos. Por ejemplo, $source indica la entidad origen. De modo que si en un atributo vemos $source.texto indica que Xcode ha deducido que para generar este atributo tenemos que copiar el valor del atributo texto de la entidad original. Para una lista de variables se recomienda consultar la secci\u00f3n correspondiente de la \u201c Core Data Model Versioning and Data Migration Programming Guide \u201d. Crear la \u201cmigration policy\u201d \u00b6 De la migraci\u00f3n entre entidades del modelo \u201cantiguo\u201d y del \u201cnuevo\u201d se encarga la clase NSEntityMigrationPolicy . Si queremos personalizar la migraci\u00f3n, como es nuestro caso para generar la nueva entidad Categoria a partir de los valores del antiguo atributo categoria , tendremos que crear una clase propia que herede de ella: Tendremos tambi\u00e9n que especificar en el Mapping Model que vamos a usar esta clase para hacer una migraci\u00f3n de entidad determinada. Seleccionamos la migraci\u00f3n NotaToNota y en las propiedades escribimos el nombre de la nueva clase en el campo Custom Policy . En la clase hay una serie de m\u00e9todos que podemos sobreescribir para adaptar la migraci\u00f3n a nuestras necesidades, pero el \u00fanico que suele ser necesario es createDestinationInstances(forSource:in:manager:) , que se debe encargar de crear a partir de una instancia de la antigua entidad, la nueva entidad (o nuevas, si debe haber m\u00e1s de una). Este m\u00e9todo se ir\u00e1 llamando para cada una de las entidades actualmente en el almac\u00e9n persistente, para irlas migrando una a una. Para nuestro problema particular, lo que debemos hacer en este m\u00e9todo es obtener la categor\u00eda a la que pertenece la nota y crear una nueva entidad Categoria basada en ella. Despu\u00e9s establecemos la relaci\u00f3n entre la nota y su por ahora \u00fanica categor\u00eda. Hay un peque\u00f1o problema a tener en cuenta: como habr\u00e1 varias notas de la misma categor\u00eda no podemos crear directamente la entidad Categoria , solo la crearemos si no existe ya. Vamos a guardar las Categoria que creamos en un diccionario para poder saber las que ya hemos creado 1 var categorias : [ String : NSManagedObject ] = [:] Aqu\u00ed tenemos el c\u00f3digo de la clase que hace la migraci\u00f3n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import UIKit import CoreData class CrearCategoriasMigrationPolicy : NSEntityMigrationPolicy { //instancias de categor\u00edas que existen ya var categorias : [ String : NSManagedObject ] = [:] override func createDestinationInstances ( forSource sInstance : NSManagedObject , in mapping : NSEntityMapping , manager : NSMigrationManager ) throws { let notaOrigen = sInstance as ! Nota let notaDestino = NSEntityDescription . insertNewObject ( forEntityName : \"Nota\" , into : manager . destinationContext ) as ! Nota //copiar propiedades b\u00e1sicas notaDestino . contenido = notaOrigen . contenido notaDestino . fecha = notaOrigen . fecha notaDestino . etiquetas = notaOrigen . etiquetas //si la nota tiene una categor\u00eda if let nombreCategoria = notaOrigen . categoria { //miramos si la categor\u00eda ya existe como entidad var categoria = categorias [ nombreCategoria ] //si no existe, creamos la instancia de la entidad if categoria == nil { categoria = NSEntityDescription . insertNewObject ( forEntityName : \"Categoria\" , into : manager . destinationContext ) categoria ?. setValue ( nombreCategoria , forKey : \"nombre\" ) categorias [ nombreCategoria ] = categoria } //asociamos la entidad nota con la entidad categor\u00eda //como es una relaci\u00f3n 1->N es un conjunto por ahora de un \u00fanico elemento var catsDeNota = Set < NSManagedObject >() catsDeNota . insert ( categoria !) notaDestino . setValue ( catsDeNota , forKey : \"categorias\" ) } //Al final siempre hay que llamar a este m\u00e9todo para establecer una correspondencia //entre entidad en el modelo actual y entidad en el nuevo manager . associate ( sourceInstance : notaOrigen , withDestinationInstance : notaDestino , for : mapping ) } } Lo \u00fanico que nos falta es configurar el persistent store coordinator para especificar que necesitamos una migraci\u00f3n \u201cpesada\u201d. Tendremos que modificar el c\u00f3digo de inicializaci\u00f3n del stack de Core Data que se crea en la plantilla de Xcode al marcar Use Core Data : en el caso de estar usando la plantilla para iOS10 tendremos que modificar el c\u00f3digo como sigue: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //En el AppDelegate //Esta l\u00ednea queda tal cual, las modificaciones vienen a partir de ella //CUIDADO: el name cambia, seg\u00fan el nombre del proyecto let container = NSPersistentContainer ( name : \"PruebaMigraciones\" ) let urls = FileManager . default . urls ( for : . applicationSupportDirectory , in : . userDomainMask ) //CUIDADO: la cadena cambia, seg\u00fan el nombre del proyecto let urlBD = urls [ 0 ]. appendingPathComponent ( \"PruebaMigraciones.sqlite\" ) let psd = NSPersistentStoreDescription ( url : urlBD ) //que no se intente automatizar la migraci\u00f3n psd . shouldInferMappingModelAutomatically = false psd . type = NSSQLiteStoreType container . persistentStoreDescriptions = [ psd ] Y ya est\u00e1. Solo nos falta en el editor del modelo de datos establecer como versi\u00f3n actual del modelo de datos la nueva versi\u00f3n Cuando arranque la aplicaci\u00f3n iOS detectar\u00e1 que el modelo de datos actual es incompatible con el almac\u00e9n persistente y ver\u00e1 que en las opciones se especifica que no se debe inferir autom\u00e1ticamente el \u201cmapping model\u201d. Por tanto buscar\u00e1 un \u201cmapping model\u201d compatible con la versi\u00f3n origen y destino del modelo de datos y lo aplicar\u00e1.","title":"4 migraciones pesadas"},{"location":"cap8/4_migraciones_pesadas/#migraciones-pesadas","text":"Hay muchos cambios que no encajan en las operaciones previstas en las migraciones \u201cligeras\u201d. Por ejemplo supongamos que tenemos el nombre y apellidos en un campo nombre_completo en el t\u00edpico formato de apellido_1 apellido_2, nombre y queremos dividirlo en dos campos: apellidos y nombre (o al contrario, partimos de dos y los queremos fusionar). En estos casos Core Data no puede inferir autom\u00e1ticamente la forma de transformar el modelo origen al modelo objetivo, y tenemos que especificar \u201cmanualmente\u201d c\u00f3mo hacer la transformaci\u00f3n. Como hemos dicho, la transformaci\u00f3n entre un modelo y otro se representa en iOS mediante un mapping model , y es lo que tenemos que darle a Core Data para que pueda actualizar los datos al nuevo modelo. Lo que har\u00e1 Core Data durante el proceso de migraci\u00f3n es cargar cada entidad en memoria, convertirla del modelo actual al nuevo ayud\u00e1ndose del mapping model y guardarla de nuevo en el almacenamiento persistente. Y hemos dicho Core Data, pero en realidad lo que tendremos que hacer ser\u00e1 escribir nosotros c\u00f3digo que haga esta tarea. Adem\u00e1s del trabajo para nosotros, las migraciones de este tipo son mucho m\u00e1s costosas en tiempo y capacidad de procesamiento que las ligeras. Normalmente la aplicaci\u00f3n necesitar\u00e1 mostrar al usuario un cuadro de di\u00e1logo o similar que le indique que se est\u00e1 realizando la operaci\u00f3n. Vamos a ver c\u00f3mo se implementar\u00eda una migraci\u00f3n \u201cpesada\u201d con un ejemplo concreto. Supongamos que en la aplicaci\u00f3n de notas nos hemos dado cuenta de que el campo \u201ccategoria\u201d no est\u00e1 del todo bien, ya que as\u00ed solo podemos hacer que una nota pertenezca a una \u00fanica categor\u00eda, y adem\u00e1s cuando varias notas tienen la misma categor\u00eda cada una debe repetir el valor. Ser\u00eda mejor tener una entidad \u201ccategor\u00eda\u201d aparte y establecer una relaci\u00f3n \u201cuno a muchos\u201d en ambas direcciones. Lo primero es crear una nueva versi\u00f3n del modelo de datos con este cambio.","title":"Migraciones \u201cpesadas\u201d"},{"location":"cap8/4_migraciones_pesadas/#crear-el-mapping-model","text":"El nuevo modelo de datos tendr\u00e1 el aspecto de la siguiente figura: ahora tenemos que crear el mapping model que nos transforme el modelo actual en el nuevo modelo. En File > New seleccionamos la categor\u00eda Core Data y elegimos la plantilla Mapping Model . El asistente nos preguntar\u00e1 cu\u00e1l es el modelo origen, cu\u00e1l el destino, y nos pedir\u00e1 un nombre para el nuevo archivo .xcmappingmodel que crear\u00e1. Si abrimos el archivo creado, veremos que Xcode ha intentado deducir la correspondencia entre el modelo origen y el destino. A la izquierda veremos los Entity Mappings (c\u00f3mo pasar de una entidad antigua a una nueva). T\u00edpicamente a estos los llama con el nombre de la entidad antigua y la nueva, algo como NotaToNota . Para las entidades nuevas pone simplemente el nombre de la entidad. Para cada Entity Mapping tenemos los Attribute Mappings y los Relationship mappings correspondientes. Se usa un conjunto de variables predefinido para expresarlos. Por ejemplo, $source indica la entidad origen. De modo que si en un atributo vemos $source.texto indica que Xcode ha deducido que para generar este atributo tenemos que copiar el valor del atributo texto de la entidad original. Para una lista de variables se recomienda consultar la secci\u00f3n correspondiente de la \u201c Core Data Model Versioning and Data Migration Programming Guide \u201d.","title":"Crear el \u201cmapping model\u201d"},{"location":"cap8/4_migraciones_pesadas/#crear-la-migration-policy","text":"De la migraci\u00f3n entre entidades del modelo \u201cantiguo\u201d y del \u201cnuevo\u201d se encarga la clase NSEntityMigrationPolicy . Si queremos personalizar la migraci\u00f3n, como es nuestro caso para generar la nueva entidad Categoria a partir de los valores del antiguo atributo categoria , tendremos que crear una clase propia que herede de ella: Tendremos tambi\u00e9n que especificar en el Mapping Model que vamos a usar esta clase para hacer una migraci\u00f3n de entidad determinada. Seleccionamos la migraci\u00f3n NotaToNota y en las propiedades escribimos el nombre de la nueva clase en el campo Custom Policy . En la clase hay una serie de m\u00e9todos que podemos sobreescribir para adaptar la migraci\u00f3n a nuestras necesidades, pero el \u00fanico que suele ser necesario es createDestinationInstances(forSource:in:manager:) , que se debe encargar de crear a partir de una instancia de la antigua entidad, la nueva entidad (o nuevas, si debe haber m\u00e1s de una). Este m\u00e9todo se ir\u00e1 llamando para cada una de las entidades actualmente en el almac\u00e9n persistente, para irlas migrando una a una. Para nuestro problema particular, lo que debemos hacer en este m\u00e9todo es obtener la categor\u00eda a la que pertenece la nota y crear una nueva entidad Categoria basada en ella. Despu\u00e9s establecemos la relaci\u00f3n entre la nota y su por ahora \u00fanica categor\u00eda. Hay un peque\u00f1o problema a tener en cuenta: como habr\u00e1 varias notas de la misma categor\u00eda no podemos crear directamente la entidad Categoria , solo la crearemos si no existe ya. Vamos a guardar las Categoria que creamos en un diccionario para poder saber las que ya hemos creado 1 var categorias : [ String : NSManagedObject ] = [:] Aqu\u00ed tenemos el c\u00f3digo de la clase que hace la migraci\u00f3n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import UIKit import CoreData class CrearCategoriasMigrationPolicy : NSEntityMigrationPolicy { //instancias de categor\u00edas que existen ya var categorias : [ String : NSManagedObject ] = [:] override func createDestinationInstances ( forSource sInstance : NSManagedObject , in mapping : NSEntityMapping , manager : NSMigrationManager ) throws { let notaOrigen = sInstance as ! Nota let notaDestino = NSEntityDescription . insertNewObject ( forEntityName : \"Nota\" , into : manager . destinationContext ) as ! Nota //copiar propiedades b\u00e1sicas notaDestino . contenido = notaOrigen . contenido notaDestino . fecha = notaOrigen . fecha notaDestino . etiquetas = notaOrigen . etiquetas //si la nota tiene una categor\u00eda if let nombreCategoria = notaOrigen . categoria { //miramos si la categor\u00eda ya existe como entidad var categoria = categorias [ nombreCategoria ] //si no existe, creamos la instancia de la entidad if categoria == nil { categoria = NSEntityDescription . insertNewObject ( forEntityName : \"Categoria\" , into : manager . destinationContext ) categoria ?. setValue ( nombreCategoria , forKey : \"nombre\" ) categorias [ nombreCategoria ] = categoria } //asociamos la entidad nota con la entidad categor\u00eda //como es una relaci\u00f3n 1->N es un conjunto por ahora de un \u00fanico elemento var catsDeNota = Set < NSManagedObject >() catsDeNota . insert ( categoria !) notaDestino . setValue ( catsDeNota , forKey : \"categorias\" ) } //Al final siempre hay que llamar a este m\u00e9todo para establecer una correspondencia //entre entidad en el modelo actual y entidad en el nuevo manager . associate ( sourceInstance : notaOrigen , withDestinationInstance : notaDestino , for : mapping ) } } Lo \u00fanico que nos falta es configurar el persistent store coordinator para especificar que necesitamos una migraci\u00f3n \u201cpesada\u201d. Tendremos que modificar el c\u00f3digo de inicializaci\u00f3n del stack de Core Data que se crea en la plantilla de Xcode al marcar Use Core Data : en el caso de estar usando la plantilla para iOS10 tendremos que modificar el c\u00f3digo como sigue: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //En el AppDelegate //Esta l\u00ednea queda tal cual, las modificaciones vienen a partir de ella //CUIDADO: el name cambia, seg\u00fan el nombre del proyecto let container = NSPersistentContainer ( name : \"PruebaMigraciones\" ) let urls = FileManager . default . urls ( for : . applicationSupportDirectory , in : . userDomainMask ) //CUIDADO: la cadena cambia, seg\u00fan el nombre del proyecto let urlBD = urls [ 0 ]. appendingPathComponent ( \"PruebaMigraciones.sqlite\" ) let psd = NSPersistentStoreDescription ( url : urlBD ) //que no se intente automatizar la migraci\u00f3n psd . shouldInferMappingModelAutomatically = false psd . type = NSSQLiteStoreType container . persistentStoreDescriptions = [ psd ] Y ya est\u00e1. Solo nos falta en el editor del modelo de datos establecer como versi\u00f3n actual del modelo de datos la nueva versi\u00f3n Cuando arranque la aplicaci\u00f3n iOS detectar\u00e1 que el modelo de datos actual es incompatible con el almac\u00e9n persistente y ver\u00e1 que en las opciones se especifica que no se debe inferir autom\u00e1ticamente el \u201cmapping model\u201d. Por tanto buscar\u00e1 un \u201cmapping model\u201d compatible con la versi\u00f3n origen y destino del modelo de datos y lo aplicar\u00e1.","title":"Crear la \u201cmigration policy\u201d"},{"location":"cap8/5_ejercicios/","text":"Ejercicio de migraciones de datos \u00b6 Vamos a hacer un par de modificaciones sobre el modelo de datos de (\u00a1c\u00f3mo no!) la aplicaci\u00f3n de notas Antes de ponerte a hacer las modificaciones de esta sesi\u00f3n aseg\u00farate de que has hecho un commit con el mensaje terminada sesi\u00f3n 7 . Tambi\u00e9n puedes hacer un .zip con el proyecto, llamarlo notas_sesion_7.zip y adjuntarlo en las entregas de la asignatura. As\u00ed cuando se eval\u00fae el ejercicio el profesor podr\u00e1 consultar el estado que ten\u00eda la aplicaci\u00f3n antes de estos ejercicios. Migraciones \u201cligeras\u201d (1 punto) \u00b6 Ve al modelo de datos y crea una nueva versi\u00f3n con Editor > Add model version... Edita esta nueva versi\u00f3n y en ella cambia de nombre el campo \u201ctexto\u201d por \u201ccontenido\u201d. Tendr\u00e1s que indicar que esto es un cambio de nombre y no un campo nuevo. Selecciona el atributo y en sus propiedades pon como renaming ID el nombre antiguo(el campo est\u00e1 al final del todo del panel, quiz\u00e1 tengas que hacer scroll para verlo). Tendr\u00e1s que modificar manualmente el c\u00f3digo fuente. Donde salga alguna referencia a la propiedad texto , tendr\u00e1s que cambiarla por contenido Fija la nueva versi\u00f3n del modelo como la versi\u00f3n actual (primero de los iconos del panel de la derecha, campo Current en Model Version ) Ejecuta la aplicaci\u00f3n y comprueba que todo sigue funcionando. Si accedes a la carpeta con la base de datos podr\u00e1s comprobar que en la tabla ZNOTA se ha cambiado la columna texto por contenido","title":"Ejercicio de migraciones de datos"},{"location":"cap8/5_ejercicios/#ejercicio-de-migraciones-de-datos","text":"Vamos a hacer un par de modificaciones sobre el modelo de datos de (\u00a1c\u00f3mo no!) la aplicaci\u00f3n de notas Antes de ponerte a hacer las modificaciones de esta sesi\u00f3n aseg\u00farate de que has hecho un commit con el mensaje terminada sesi\u00f3n 7 . Tambi\u00e9n puedes hacer un .zip con el proyecto, llamarlo notas_sesion_7.zip y adjuntarlo en las entregas de la asignatura. As\u00ed cuando se eval\u00fae el ejercicio el profesor podr\u00e1 consultar el estado que ten\u00eda la aplicaci\u00f3n antes de estos ejercicios.","title":"Ejercicio de migraciones de datos"},{"location":"cap8/5_ejercicios/#migraciones-ligeras-1-punto","text":"Ve al modelo de datos y crea una nueva versi\u00f3n con Editor > Add model version... Edita esta nueva versi\u00f3n y en ella cambia de nombre el campo \u201ctexto\u201d por \u201ccontenido\u201d. Tendr\u00e1s que indicar que esto es un cambio de nombre y no un campo nuevo. Selecciona el atributo y en sus propiedades pon como renaming ID el nombre antiguo(el campo est\u00e1 al final del todo del panel, quiz\u00e1 tengas que hacer scroll para verlo). Tendr\u00e1s que modificar manualmente el c\u00f3digo fuente. Donde salga alguna referencia a la propiedad texto , tendr\u00e1s que cambiarla por contenido Fija la nueva versi\u00f3n del modelo como la versi\u00f3n actual (primero de los iconos del panel de la derecha, campo Current en Model Version ) Ejecuta la aplicaci\u00f3n y comprueba que todo sigue funcionando. Si accedes a la carpeta con la base de datos podr\u00e1s comprobar que en la tabla ZNOTA se ha cambiado la columna texto por contenido","title":"Migraciones \u201cligeras\u201d (1 punto)"},{"location":"cap8/apendice_migraciones_ios9/","text":"Ap\u00e9ndice: migraciones en versiones de iOS<10 \u00b6 Como vimos en la primera sesi\u00f3n de Core Data, el stack se gestiona con la clase NSPersistentContainer . Esta clase tiene activadas por defecto las migraciones autom\u00e1ticas, y por eso en iOS10 podemos hacer modificaciones al modelo de datos sin causar errores en tiempo de ejecuci\u00f3n. No obstante esta clase es nueva de la versi\u00f3n 10. \u00bfQu\u00e9 ocurre si necesitamos generar c\u00f3digo compatible con versiones anteriores, o tenemos un proyecto \"heredado\" de esas versiones?. Las clases que gestionan el stack de Core Data en iOS9 y versiones anteriores no tienen activadas las migraciones por defecto, y si en el proceso de desarrollo modificamos el modelo de datos nos encontraremos con que al ejecutar la aplicaci\u00f3n se genera un mensaje de error: 1 The model used to open the store is incompatible with the one used to create the store Para activar las migraciones autom\u00e1ticas en iOS<=9 tenemos que pasarle un par\u00e1metro adicional al persistent store coordinator cuando vamos a\u00f1adiendo almacenamientos persistentes. Las opciones que indican si hay que intentar la migraci\u00f3n autom\u00e1tica van asociadas a la configuraci\u00f3n del almacenamiento persistente. En concreto, en la plantilla que generan las versiones de Xcode anteriores a la 8 hay que hacer el siguiente cambio: 1 2 3 4 5 6 7 8 9 //ESTO SE A\u00d1ADE let opciones = [ NSInferMappingModelAutomaticallyOption : true , NSMigratePersistentStoresAutomaticallyOption : true ] //ESTO YA ESTABA, pero antes con el options a nil do { try coordinator . addPersistentStore ( ofType : NSSQLiteStoreType , configurationName : nil , at : url , options : opciones ) } catch { NSInferMappingModelAutomaticallyOption indica que Core Data intente inferir el mapping model autom\u00e1ticamente. Esto es necesario para las migraciones ligeras, pero para las \"pesadas\" habr\u00e1 que ponerlo a false , para que tome el modelo que nosotros le damos. NSMigratePersistentStoresAutomaticallyOption indica que se debe intentar hacer la migraci\u00f3n. Cuando este valor est\u00e1 a false es cuando al detectar un cambio en el modelo de datos se genera un error en tiempo de ejecuci\u00f3n.","title":"Apendice migraciones ios9"},{"location":"cap8/apendice_migraciones_ios9/#apendice-migraciones-en-versiones-de-ios10","text":"Como vimos en la primera sesi\u00f3n de Core Data, el stack se gestiona con la clase NSPersistentContainer . Esta clase tiene activadas por defecto las migraciones autom\u00e1ticas, y por eso en iOS10 podemos hacer modificaciones al modelo de datos sin causar errores en tiempo de ejecuci\u00f3n. No obstante esta clase es nueva de la versi\u00f3n 10. \u00bfQu\u00e9 ocurre si necesitamos generar c\u00f3digo compatible con versiones anteriores, o tenemos un proyecto \"heredado\" de esas versiones?. Las clases que gestionan el stack de Core Data en iOS9 y versiones anteriores no tienen activadas las migraciones por defecto, y si en el proceso de desarrollo modificamos el modelo de datos nos encontraremos con que al ejecutar la aplicaci\u00f3n se genera un mensaje de error: 1 The model used to open the store is incompatible with the one used to create the store Para activar las migraciones autom\u00e1ticas en iOS<=9 tenemos que pasarle un par\u00e1metro adicional al persistent store coordinator cuando vamos a\u00f1adiendo almacenamientos persistentes. Las opciones que indican si hay que intentar la migraci\u00f3n autom\u00e1tica van asociadas a la configuraci\u00f3n del almacenamiento persistente. En concreto, en la plantilla que generan las versiones de Xcode anteriores a la 8 hay que hacer el siguiente cambio: 1 2 3 4 5 6 7 8 9 //ESTO SE A\u00d1ADE let opciones = [ NSInferMappingModelAutomaticallyOption : true , NSMigratePersistentStoresAutomaticallyOption : true ] //ESTO YA ESTABA, pero antes con el options a nil do { try coordinator . addPersistentStore ( ofType : NSSQLiteStoreType , configurationName : nil , at : url , options : opciones ) } catch { NSInferMappingModelAutomaticallyOption indica que Core Data intente inferir el mapping model autom\u00e1ticamente. Esto es necesario para las migraciones ligeras, pero para las \"pesadas\" habr\u00e1 que ponerlo a false , para que tome el modelo que nosotros le damos. NSMigratePersistentStoresAutomaticallyOption indica que se debe intentar hacer la migraci\u00f3n. Cuando este valor est\u00e1 a false es cuando al detectar un cambio en el modelo de datos se genera un error en tiempo de ejecuci\u00f3n.","title":"Ap\u00e9ndice: migraciones en versiones de iOS&lt;10"},{"location":"cap8/intro/","text":"Introducci\u00f3n \u00b6 En esta sesi\u00f3n veremos c\u00f3mo podemos ir cambiando el modelo de datos sin perder los datos que ya tenemos almacenados. Para esto habr\u00e1 que \"exportarlos\" al nuevo formato. Veremos que en la mayor\u00eda de los casos Core Data puede hacer este cambio de formato de modo autom\u00e1tico pero en ciertos casos m\u00e1s complicados vamos a tener que escribir nosotros c\u00f3digo para hacer la transformaci\u00f3n.","title":"Intro"},{"location":"cap8/intro/#introduccion","text":"En esta sesi\u00f3n veremos c\u00f3mo podemos ir cambiando el modelo de datos sin perder los datos que ya tenemos almacenados. Para esto habr\u00e1 que \"exportarlos\" al nuevo formato. Veremos que en la mayor\u00eda de los casos Core Data puede hacer este cambio de formato de modo autom\u00e1tico pero en ciertos casos m\u00e1s complicados vamos a tener que escribir nosotros c\u00f3digo para hacer la transformaci\u00f3n.","title":"Introducci\u00f3n"},{"location":"cap8/restos/","text":"Ap\u00e9ndice: migraciones ligeras en iOS<10 \u00b6 Hay una serie de migraciones que Core Data puede hacer de forma m\u00e1s o menos autom\u00e1tica. Por ejemplo al a\u00f1adir un atributo se a\u00f1adir\u00e1 la nueva columna y simplemente los datos antiguos tendr\u00e1n valor nil para la propiedad. O al cambiar una entidad de nombre se cambiar\u00e1 autom\u00e1ticamente el nombre de la tabla en la base de datos. The model used to open the store is incompatible with the one used to create the store. Este error es f\u00e1cilmente subsanable yendo al directorio Documents de la aplicaci\u00f3n y eliminando los ficheros del almacenamiento persistente (si es una BD SQLite, desde iOS7 hay 3 ficheros, un .sqlite , un .sqlite-wal y un .sqlite-shm ). Si volvemos a arrancar la aplicaci\u00f3n ya no habr\u00e1 problema ya que no hay almacenamiento persistente y Core Data lo puede generar partiendo de cero. Pero evidentemente esto implica perder todos los datos que ten\u00edamos guardados . En desarrollo perder los datos no tiene la menor importancia si tenemos el t\u00edpico c\u00f3digo de prueba que podemos volver a ejecutar para rellenar la BD. Pero si ya hemos distribuido la aplicaci\u00f3n en la App Store y sacamos una nueva versi\u00f3n con el modelo de datos modificado, en principio todos los usuarios tendr\u00edan que borrar todos los datos para que les funcionara la nueva versi\u00f3n (!). Evidentemente esto no tiene sentido, tiene que haber alguna forma de que el modelo de datos pueda ir cambiando y los datos se vayan traspasando de una versi\u00f3n a otra. Este \u201ctraspaso\u201d de los datos es lo que se conoce como una migraci\u00f3n . Versiones del modelo de datos \u00b6 Migraciones \u201cligeras\u201d \u00b6 Las buenas noticias son que si los cambios en el modelo de datos no son demasiados, el propio Core Data puede hacer una migraci\u00f3n autom\u00e1tica, o como la llama Apple, \u201cligera\u201d ( lightweight migration ). Este tipo de migraci\u00f3n se corresponde con estas operaciones: A\u00f1adir o eliminar un atributo o relaci\u00f3n Convertir en opcional un atributo requerido Convertir en requerido un atributo opcional, siempre que se d\u00e9 un valor por defecto A\u00f1adir o eliminar una entidad Renombrar un atributo o relaci\u00f3n Renombrar una entidad Si hemos hecho alguno/s de los cambios anteriores que no implican renombrado , la migraci\u00f3n ligera es especialmente sencilla. Lo \u00fanico que tenemos que hacer es modificar el c\u00f3digo de inicializaci\u00f3n del NSPersistentStoreCoordinator . En el addPersistentStoreWithType , hay que pasar un par de opciones en el par\u00e1metro options que indican que queremos una migraci\u00f3n totalmente autom\u00e1tica: 1 2 3 4 5 6 7 NSDictionary * opts = @{ NSMigratePersistentStoresAutomaticallyOption : @YES , NSInferMappingModelAutomaticallyOption : @YES } ; [ persistentStoreCoordinator addPersistentStoreWithType : NSSQLiteStoreType configuration : nil URL : storeURL options : opts error : & error ] Ahora cuando ejecutemos la aplicaci\u00f3n se detectar\u00e1 que la versi\u00f3n actual del modelo de datos es posterior a la que se us\u00f3 para generar la base de datos . En consecuencia, tal y como acabamos de configurar en el c\u00f3digo, los datos se migrar\u00e1n autom\u00e1ticamente a la nueva versi\u00f3n de la BD. Si renombramos algo el proceso es solo un poco m\u00e1s laborioso. Por ejemplo supongamos que en la aplicaci\u00f3n de notas cambiamos el atributo fecha por momento . Habiendo cambiado el nombre, mantenemos seleccionado el atributo y en el panel de la derecha, tercer icono (Data Model Inspector), en el cuadro de texto llamado Renaming ID tecleamos el nombre antiguo. Con esto estamos especificando lo que en Core Data se llama un mapping model , es decir una asociaci\u00f3n de elementos que permite pasar del modelo antiguo al nuevo. Por supuesto, todos los lugares del c\u00f3digo donde antes se hiciera referencia al atributo fecha ahora habr\u00e1 que cambiarlos para que reflejen el nuevo nombre. Core Data no va a ayudarnos en esto. Migraciones \u201cpesadas\u201d \u00b6 Puede haber cambios que no encajen en las operaciones previstas en las migraciones \u201cligeras\u201d. Por ejemplo supongamos que queremos dividir un campo apellidos en apellido1 y apellido2 (o al contrario, partimos de dos y los queremos fusionar). En estos casos Core Data no puede inferir autom\u00e1ticamente la forma de transformar el modelo origen al modelo objetivo, y tenemos que especificar \u201cmanualmente\u201d c\u00f3mo hacer la transformaci\u00f3n. La transformaci\u00f3n entre un modelo y otro se representa en iOS mediante un mapping model , y es lo que tenemos que proporcionarle a Core Data para que pueda actualizar los datos al nuevo modelo. Lo que har\u00e1 Core Data durante el proceso de migraci\u00f3n es cargar cada entidad en memoria, convertirla del modelo actual al nuevo ayud\u00e1ndose del mapping model y guardarla de nuevo en el almacenamiento persistente. Y hemos dicho Core Data, pero en realidad lo que tendremos que hacer ser\u00e1 escribir nosotros c\u00f3digo que haga esta tarea. Adem\u00e1s del trabajo para nosotros, las migraciones de este tipo son mucho m\u00e1s costosas en tiempo y capacidad de procesamiento que las ligeras. Normalmente la aplicaci\u00f3n necesitar\u00e1 mostrar al usuario un cuadro de di\u00e1logo que le indique que se est\u00e1 realizando la operaci\u00f3n. Vamos a ver c\u00f3mo se implementar\u00eda una migraci\u00f3n \u201cpesada\u201d con un ejemplo concreto. Supongamos que en la aplicaci\u00f3n de notas nos hemos dado cuenta de que el campo \u201ccategoria\u201d no est\u00e1 del todo bien, ya que as\u00ed solo podemos hacer que una nota pertenezca a una \u00fanica categor\u00eda, y adem\u00e1s cuando varias notas tienen la misma categor\u00eda cada una debe repetir el valor. Ser\u00eda mejor tener una entidad \u201ccategor\u00eda\u201d aparte y establecer una relaci\u00f3n \u201cuno a muchos\u201d en ambas direcciones. Lo primero es crear una nueva versi\u00f3n del modelo de datos con este cambio. Crear el \u201cmapping model\u201d \u00b6 El nuevo modelo de datos tendr\u00e1 el aspecto de la siguiente figura: ahora tenemos que crear el mapping model que nos transforme el modelo actual en el nuevo modelo. En File > New seleccionamos la categor\u00eda Core Data y elegimos la plantilla Mapping Model . El asistente nos preguntar\u00e1 cu\u00e1l es el modelo origen, cu\u00e1l el destino, y nos pedir\u00e1 un nombre para el nuevo archivo .xcmappingmodel que crear\u00e1. Si abrimos el archivo creado, veremos que Xcode ha intentado deducir la correspondencia entre el modelo origen y el destino. A la izquierda veremos los Entity Mappings (c\u00f3mo pasar de una entidad antigua a una nueva). T\u00edpicamente a estos los llama con el nombre de la entidad antigua y la nueva, algo como NotaToNota . Para las entidades nuevas pone simplemente el nombre de la entidad. Para cada Entity Mapping tenemos los Attribute Mappings y los Relationship mappings correspondientes. Se usa un conjunto de variables predefinido para expresarlos. Por ejemplo, $source indica la entidad origen. De modo que si en un atributo vemos $source.texto indica que Xcode ha deducido que para generar este atributo tenemos que copiar el valor del atributo texto de la entidad original. Para una lista de variables se recomienda consultar la secci\u00f3n correspondiente de la \u201c Core Data Model Versioning and Data Migration Programming Guide \u201d. Crear la \u201cmigration policy\u201d \u00b6 De la migraci\u00f3n entre entidades del modelo \u201cantiguo\u201d y del \u201cnuevo\u201d se encarga la clase NSEntityMigrationPolicy . Si queremos personalizar la migraci\u00f3n, como es nuestro caso para generar la nueva entidad Categoria a partir de los valores del antiguo atributo categoria , tendremos que crear una clase propia que herede de ella: Tendremos tambi\u00e9n que especificar en el Mapping Model que vamos a usar esta clase para hacer una migraci\u00f3n de entidad determinada. Seleccionamos la migraci\u00f3n NotaToNota y en las propiedades escribimos el nombre de la nueva clase en el campo Custom Policy . En la clase hay una serie de m\u00e9todos que podemos sobreescribir para adaptar la migraci\u00f3n a nuestras necesidades, pero el \u00fanico que suele ser necesario es createDestinationInstancesForSourceInstance:entityMapping:manager:error: , que se encargar\u00eda de crear a partir de una instancia de la antigua entidad, la nueva entidad (o nuevas, si debe haber m\u00e1s de una). Este m\u00e9todo se ir\u00e1 llamando para cada una de las entidades actualmente en el almac\u00e9n persistente, para irlas migrando una a una. Para nuestro problema particular, lo que debemos hacer en este m\u00e9todo es obtener la categor\u00eda a la que pertenece la nota y crear una nueva entidad Categoria basada en ella. Despu\u00e9s establecemos la relaci\u00f3n entre la nota y su por ahora \u00fanica categor\u00eda. Hay un peque\u00f1o problema a tener en cuenta: como habr\u00e1 varias notas de la misma categor\u00eda no podemos crear directamente la entidad Categoria , solo la crearemos si no existe ya. Vamos a guardar las Categoria que creamos en un NSMutableDictionary para poder saber las que ya hemos creado. En nuestra clase definir\u00edamos una variable static : 1 static NSMutableDictionary *categorias; y para inicializarla usaremos el m\u00e9todo initialize , que se llama cuando se inicializa la clase propiamente dicha, antes de que exista todav\u00eda ninguna instancia de ella, momento apropiado para inicializar variables static : 1 2 3 + ( void ) initialize { categorias = [[ NSMutableDictionary alloc ] init ]; } Finalmente aqu\u00ed tenemos el c\u00f3digo que hace la migraci\u00f3n en s\u00ed 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 - ( BOOL ) createDestinationInstancesForSourceInstance: ( NSManagedObject * ) sInstance entityMapping: ( NSEntityMapping * ) mapping manager: ( NSMigrationManager * ) manager error: ( NSError * __autoreleasing * ) error { //Crea una nueva nota en el \"nuevo modelo\" con las mismas propiedades que la nota actual NSManagedObject * notaDestino = [ NSEntityDescription insertNewObjectForEntityForName : @\"Nota\" inManagedObjectContext : manager . destinationContext ]; [ notaDestino setValue :[ sInstance valueForKey : @\"texto\" ] forKey : @\"texto\" ]; [ notaDestino setValue :[ sInstance valueForKey : @\"momento\" ] forKey : @\"momento\" ]; //Miramos si ya hemos creado una entidad Categoria para la categoria de la nota NSString * nombreCategoria = [ sInstance valueForKey : @\"categoria\" ]; NSManagedObject * categoria = [ categorias objectForKey : nombreCategoria ]; //Si no la hemos encontrado, la creamos if ( ! categoria ) { categoria = [ NSEntityDescription insertNewObjectForEntityForName : @\"Categoria\" inManagedObjectContext : manager . destinationContext ]; [ categoria setValue : nombreCategoria forKey : @\"nombre\" ]; [ categorias setObject : categoria forKey : nombreCategoria ]; } //Asociamos la nota con su por ahora \u00fanica categor\u00eda //Como es una relaci\u00f3n 1->N es un NSSet que por ahora tendr\u00e1 un \u00fanico elemento NSSet * categoriasDeNota = [[ NSSet alloc ] initWithObjects : categoria , nil ]; [ notaDestino setValue : categoriasDeNota forKey : @\"categorias\" ]; //Al final siempre hay que llamar a este m\u00e9todo para establecer correspondencia //entre entidad en el modelo actual y entidad en el nuevo [ manager associateSourceInstance : sInstance withDestinationInstance : notaDestino forEntityMapping : mapping ]; return YES ; } Lo \u00fanico que nos falta es configurar el persistent store coordinator para especificar que necesitamos una migraci\u00f3n \u201cpesada\u201d. Al igual que en el caso de las migraciones \u201cligeras\u201d, esto se hace con un diccionario de opciones. La diferencia es que en este caso indicamos que no se intente inferir autom\u00e1ticamente el \u201cmapping model\u201d 1 2 3 4 NSDictionary *opts = @{ NSMigratePersistentStoresAutomaticallyOption: @YES, NSInferMappingModelAutomaticallyOption: @NO }; Y ya est\u00e1. Solo nos falta en el editor del modelo de datos establecer como versi\u00f3n actual del modelo de datos la nueva versi\u00f3n Cuando arranque la aplicaci\u00f3n iOS detectar\u00e1 que el modelo de datos actual es incompatible con el almac\u00e9n persistente y ver\u00e1 que en las opciones se especifica que no se debe inferir autom\u00e1ticamente el \u201cmapping model\u201d. Por tanto buscar\u00e1 un \u201cmapping model\u201d compatible con la versi\u00f3n origen y destino del modelo de datos y lo aplicar\u00e1.","title":"Restos"},{"location":"cap8/restos/#apendice-migraciones-ligeras-en-ios10","text":"Hay una serie de migraciones que Core Data puede hacer de forma m\u00e1s o menos autom\u00e1tica. Por ejemplo al a\u00f1adir un atributo se a\u00f1adir\u00e1 la nueva columna y simplemente los datos antiguos tendr\u00e1n valor nil para la propiedad. O al cambiar una entidad de nombre se cambiar\u00e1 autom\u00e1ticamente el nombre de la tabla en la base de datos. The model used to open the store is incompatible with the one used to create the store. Este error es f\u00e1cilmente subsanable yendo al directorio Documents de la aplicaci\u00f3n y eliminando los ficheros del almacenamiento persistente (si es una BD SQLite, desde iOS7 hay 3 ficheros, un .sqlite , un .sqlite-wal y un .sqlite-shm ). Si volvemos a arrancar la aplicaci\u00f3n ya no habr\u00e1 problema ya que no hay almacenamiento persistente y Core Data lo puede generar partiendo de cero. Pero evidentemente esto implica perder todos los datos que ten\u00edamos guardados . En desarrollo perder los datos no tiene la menor importancia si tenemos el t\u00edpico c\u00f3digo de prueba que podemos volver a ejecutar para rellenar la BD. Pero si ya hemos distribuido la aplicaci\u00f3n en la App Store y sacamos una nueva versi\u00f3n con el modelo de datos modificado, en principio todos los usuarios tendr\u00edan que borrar todos los datos para que les funcionara la nueva versi\u00f3n (!). Evidentemente esto no tiene sentido, tiene que haber alguna forma de que el modelo de datos pueda ir cambiando y los datos se vayan traspasando de una versi\u00f3n a otra. Este \u201ctraspaso\u201d de los datos es lo que se conoce como una migraci\u00f3n .","title":"Ap\u00e9ndice: migraciones ligeras en iOS&lt;10"},{"location":"cap8/restos/#versiones-del-modelo-de-datos","text":"","title":"Versiones del modelo de datos"},{"location":"cap8/restos/#migraciones-ligeras","text":"Las buenas noticias son que si los cambios en el modelo de datos no son demasiados, el propio Core Data puede hacer una migraci\u00f3n autom\u00e1tica, o como la llama Apple, \u201cligera\u201d ( lightweight migration ). Este tipo de migraci\u00f3n se corresponde con estas operaciones: A\u00f1adir o eliminar un atributo o relaci\u00f3n Convertir en opcional un atributo requerido Convertir en requerido un atributo opcional, siempre que se d\u00e9 un valor por defecto A\u00f1adir o eliminar una entidad Renombrar un atributo o relaci\u00f3n Renombrar una entidad Si hemos hecho alguno/s de los cambios anteriores que no implican renombrado , la migraci\u00f3n ligera es especialmente sencilla. Lo \u00fanico que tenemos que hacer es modificar el c\u00f3digo de inicializaci\u00f3n del NSPersistentStoreCoordinator . En el addPersistentStoreWithType , hay que pasar un par de opciones en el par\u00e1metro options que indican que queremos una migraci\u00f3n totalmente autom\u00e1tica: 1 2 3 4 5 6 7 NSDictionary * opts = @{ NSMigratePersistentStoresAutomaticallyOption : @YES , NSInferMappingModelAutomaticallyOption : @YES } ; [ persistentStoreCoordinator addPersistentStoreWithType : NSSQLiteStoreType configuration : nil URL : storeURL options : opts error : & error ] Ahora cuando ejecutemos la aplicaci\u00f3n se detectar\u00e1 que la versi\u00f3n actual del modelo de datos es posterior a la que se us\u00f3 para generar la base de datos . En consecuencia, tal y como acabamos de configurar en el c\u00f3digo, los datos se migrar\u00e1n autom\u00e1ticamente a la nueva versi\u00f3n de la BD. Si renombramos algo el proceso es solo un poco m\u00e1s laborioso. Por ejemplo supongamos que en la aplicaci\u00f3n de notas cambiamos el atributo fecha por momento . Habiendo cambiado el nombre, mantenemos seleccionado el atributo y en el panel de la derecha, tercer icono (Data Model Inspector), en el cuadro de texto llamado Renaming ID tecleamos el nombre antiguo. Con esto estamos especificando lo que en Core Data se llama un mapping model , es decir una asociaci\u00f3n de elementos que permite pasar del modelo antiguo al nuevo. Por supuesto, todos los lugares del c\u00f3digo donde antes se hiciera referencia al atributo fecha ahora habr\u00e1 que cambiarlos para que reflejen el nuevo nombre. Core Data no va a ayudarnos en esto.","title":"Migraciones \u201cligeras\u201d"},{"location":"cap8/restos/#migraciones-pesadas","text":"Puede haber cambios que no encajen en las operaciones previstas en las migraciones \u201cligeras\u201d. Por ejemplo supongamos que queremos dividir un campo apellidos en apellido1 y apellido2 (o al contrario, partimos de dos y los queremos fusionar). En estos casos Core Data no puede inferir autom\u00e1ticamente la forma de transformar el modelo origen al modelo objetivo, y tenemos que especificar \u201cmanualmente\u201d c\u00f3mo hacer la transformaci\u00f3n. La transformaci\u00f3n entre un modelo y otro se representa en iOS mediante un mapping model , y es lo que tenemos que proporcionarle a Core Data para que pueda actualizar los datos al nuevo modelo. Lo que har\u00e1 Core Data durante el proceso de migraci\u00f3n es cargar cada entidad en memoria, convertirla del modelo actual al nuevo ayud\u00e1ndose del mapping model y guardarla de nuevo en el almacenamiento persistente. Y hemos dicho Core Data, pero en realidad lo que tendremos que hacer ser\u00e1 escribir nosotros c\u00f3digo que haga esta tarea. Adem\u00e1s del trabajo para nosotros, las migraciones de este tipo son mucho m\u00e1s costosas en tiempo y capacidad de procesamiento que las ligeras. Normalmente la aplicaci\u00f3n necesitar\u00e1 mostrar al usuario un cuadro de di\u00e1logo que le indique que se est\u00e1 realizando la operaci\u00f3n. Vamos a ver c\u00f3mo se implementar\u00eda una migraci\u00f3n \u201cpesada\u201d con un ejemplo concreto. Supongamos que en la aplicaci\u00f3n de notas nos hemos dado cuenta de que el campo \u201ccategoria\u201d no est\u00e1 del todo bien, ya que as\u00ed solo podemos hacer que una nota pertenezca a una \u00fanica categor\u00eda, y adem\u00e1s cuando varias notas tienen la misma categor\u00eda cada una debe repetir el valor. Ser\u00eda mejor tener una entidad \u201ccategor\u00eda\u201d aparte y establecer una relaci\u00f3n \u201cuno a muchos\u201d en ambas direcciones. Lo primero es crear una nueva versi\u00f3n del modelo de datos con este cambio.","title":"Migraciones \u201cpesadas\u201d"},{"location":"cap8/restos/#crear-el-mapping-model","text":"El nuevo modelo de datos tendr\u00e1 el aspecto de la siguiente figura: ahora tenemos que crear el mapping model que nos transforme el modelo actual en el nuevo modelo. En File > New seleccionamos la categor\u00eda Core Data y elegimos la plantilla Mapping Model . El asistente nos preguntar\u00e1 cu\u00e1l es el modelo origen, cu\u00e1l el destino, y nos pedir\u00e1 un nombre para el nuevo archivo .xcmappingmodel que crear\u00e1. Si abrimos el archivo creado, veremos que Xcode ha intentado deducir la correspondencia entre el modelo origen y el destino. A la izquierda veremos los Entity Mappings (c\u00f3mo pasar de una entidad antigua a una nueva). T\u00edpicamente a estos los llama con el nombre de la entidad antigua y la nueva, algo como NotaToNota . Para las entidades nuevas pone simplemente el nombre de la entidad. Para cada Entity Mapping tenemos los Attribute Mappings y los Relationship mappings correspondientes. Se usa un conjunto de variables predefinido para expresarlos. Por ejemplo, $source indica la entidad origen. De modo que si en un atributo vemos $source.texto indica que Xcode ha deducido que para generar este atributo tenemos que copiar el valor del atributo texto de la entidad original. Para una lista de variables se recomienda consultar la secci\u00f3n correspondiente de la \u201c Core Data Model Versioning and Data Migration Programming Guide \u201d.","title":"Crear el \u201cmapping model\u201d"},{"location":"cap8/restos/#crear-la-migration-policy","text":"De la migraci\u00f3n entre entidades del modelo \u201cantiguo\u201d y del \u201cnuevo\u201d se encarga la clase NSEntityMigrationPolicy . Si queremos personalizar la migraci\u00f3n, como es nuestro caso para generar la nueva entidad Categoria a partir de los valores del antiguo atributo categoria , tendremos que crear una clase propia que herede de ella: Tendremos tambi\u00e9n que especificar en el Mapping Model que vamos a usar esta clase para hacer una migraci\u00f3n de entidad determinada. Seleccionamos la migraci\u00f3n NotaToNota y en las propiedades escribimos el nombre de la nueva clase en el campo Custom Policy . En la clase hay una serie de m\u00e9todos que podemos sobreescribir para adaptar la migraci\u00f3n a nuestras necesidades, pero el \u00fanico que suele ser necesario es createDestinationInstancesForSourceInstance:entityMapping:manager:error: , que se encargar\u00eda de crear a partir de una instancia de la antigua entidad, la nueva entidad (o nuevas, si debe haber m\u00e1s de una). Este m\u00e9todo se ir\u00e1 llamando para cada una de las entidades actualmente en el almac\u00e9n persistente, para irlas migrando una a una. Para nuestro problema particular, lo que debemos hacer en este m\u00e9todo es obtener la categor\u00eda a la que pertenece la nota y crear una nueva entidad Categoria basada en ella. Despu\u00e9s establecemos la relaci\u00f3n entre la nota y su por ahora \u00fanica categor\u00eda. Hay un peque\u00f1o problema a tener en cuenta: como habr\u00e1 varias notas de la misma categor\u00eda no podemos crear directamente la entidad Categoria , solo la crearemos si no existe ya. Vamos a guardar las Categoria que creamos en un NSMutableDictionary para poder saber las que ya hemos creado. En nuestra clase definir\u00edamos una variable static : 1 static NSMutableDictionary *categorias; y para inicializarla usaremos el m\u00e9todo initialize , que se llama cuando se inicializa la clase propiamente dicha, antes de que exista todav\u00eda ninguna instancia de ella, momento apropiado para inicializar variables static : 1 2 3 + ( void ) initialize { categorias = [[ NSMutableDictionary alloc ] init ]; } Finalmente aqu\u00ed tenemos el c\u00f3digo que hace la migraci\u00f3n en s\u00ed 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 - ( BOOL ) createDestinationInstancesForSourceInstance: ( NSManagedObject * ) sInstance entityMapping: ( NSEntityMapping * ) mapping manager: ( NSMigrationManager * ) manager error: ( NSError * __autoreleasing * ) error { //Crea una nueva nota en el \"nuevo modelo\" con las mismas propiedades que la nota actual NSManagedObject * notaDestino = [ NSEntityDescription insertNewObjectForEntityForName : @\"Nota\" inManagedObjectContext : manager . destinationContext ]; [ notaDestino setValue :[ sInstance valueForKey : @\"texto\" ] forKey : @\"texto\" ]; [ notaDestino setValue :[ sInstance valueForKey : @\"momento\" ] forKey : @\"momento\" ]; //Miramos si ya hemos creado una entidad Categoria para la categoria de la nota NSString * nombreCategoria = [ sInstance valueForKey : @\"categoria\" ]; NSManagedObject * categoria = [ categorias objectForKey : nombreCategoria ]; //Si no la hemos encontrado, la creamos if ( ! categoria ) { categoria = [ NSEntityDescription insertNewObjectForEntityForName : @\"Categoria\" inManagedObjectContext : manager . destinationContext ]; [ categoria setValue : nombreCategoria forKey : @\"nombre\" ]; [ categorias setObject : categoria forKey : nombreCategoria ]; } //Asociamos la nota con su por ahora \u00fanica categor\u00eda //Como es una relaci\u00f3n 1->N es un NSSet que por ahora tendr\u00e1 un \u00fanico elemento NSSet * categoriasDeNota = [[ NSSet alloc ] initWithObjects : categoria , nil ]; [ notaDestino setValue : categoriasDeNota forKey : @\"categorias\" ]; //Al final siempre hay que llamar a este m\u00e9todo para establecer correspondencia //entre entidad en el modelo actual y entidad en el nuevo [ manager associateSourceInstance : sInstance withDestinationInstance : notaDestino forEntityMapping : mapping ]; return YES ; } Lo \u00fanico que nos falta es configurar el persistent store coordinator para especificar que necesitamos una migraci\u00f3n \u201cpesada\u201d. Al igual que en el caso de las migraciones \u201cligeras\u201d, esto se hace con un diccionario de opciones. La diferencia es que en este caso indicamos que no se intente inferir autom\u00e1ticamente el \u201cmapping model\u201d 1 2 3 4 NSDictionary *opts = @{ NSMigratePersistentStoresAutomaticallyOption: @YES, NSInferMappingModelAutomaticallyOption: @NO }; Y ya est\u00e1. Solo nos falta en el editor del modelo de datos establecer como versi\u00f3n actual del modelo de datos la nueva versi\u00f3n Cuando arranque la aplicaci\u00f3n iOS detectar\u00e1 que el modelo de datos actual es incompatible con el almac\u00e9n persistente y ver\u00e1 que en las opciones se especifica que no se debe inferir autom\u00e1ticamente el \u201cmapping model\u201d. Por tanto buscar\u00e1 un \u201cmapping model\u201d compatible con la versi\u00f3n origen y destino del modelo de datos y lo aplicar\u00e1.","title":"Crear la \u201cmigration policy\u201d"},{"location":"cap9/1_background/","text":"M\u00faltiples contextos para trabajos en background \u00b6 Algunas operaciones con Core Data pueden ser bastante costosas en tiempo: por ejemplo una b\u00fasqueda en una base de datos con muchos registros, o la sincronizaci\u00f3n de los datos con un servicio web. Si efectuamos la operaci\u00f3n en el hilo principal de la aplicaci\u00f3n, donde trabajamos normalmente, la interfaz de usuario se quedar\u00e1 paralizada durante ese tiempo y la aplicaci\u00f3n no responder\u00e1 a los eventos, ya que la interfaz corre en ese hilo. En la asignatura de introducci\u00f3n a iOS y a Swift ya vimos una soluci\u00f3n a ese problema: las colas de operaciones , que b\u00e1sicamente son una forma de crear y gestionar operaciones concurrentes mucho m\u00e1s sencilla para el desarrollador que trabajar directamente con el API de threads . Por desgracia, los NSManagedObjects no son thread-safe , es decir, no se asegura que no se vayan a dar inconsistencias y problemas al acceder a un NSManagedObject desde distintos hilos. As\u00ed que en principio esta soluci\u00f3n no es directamente aplicable. Sin embargo, hay otra posibilidad que s\u00ed nos permitir\u00eda usar varios hilos: tener varios contextos de persistencia, cada uno en un hilo distinto . Un NSManagedObject pertenece solo a un contexto de persistencia, as\u00ed que no habr\u00e1 ning\u00fan problema si siempre para acceder a \u00e9l usamos el thread asociado a su contexto. Lo \u00fanico que necesitamos para solucionar el problema de las operaciones que bloquean la interfaz es un contexto adicional que funcione en un hilo secundario, y realizar la operaci\u00f3n costosa con Core Data en este hilo. El contexto que crea el stack de Core Data por defecto est\u00e1 asociado al hilo principal de la aplicaci\u00f3n, as\u00ed que ese no nos sirve. En iOS el API para crear un nuevo contexto asociado a otro hilo es bastante sencillo, pero con la introducci\u00f3n del NSPersistentContainer en iOS10 ni siquiera es necesario que creemos nosotros mismos el contexto, el container lo hace por nosotros. Todo lo que tenemos que hacer es pasarle al m\u00e9todo performBackgroundTask() el c\u00f3digo a ejecutar en background en forma de clausura: 1 2 3 4 5 6 7 8 9 10 let miDelegate = UIApplication . shared . delegate as ! AppDelegate miDelegate . persistentContainer . performBackgroundTask () { contextoBG in let request = NSFetchRequest < Nota >( entityName : \"Nota\" ) let lista = try ! contextoBG . fetch ( request ) for nota in lista { //Aqu\u00ed hacemos una operaci\u00f3n costosa, como exportar cada nota a PDF //o subirlas a un servidor } } La clausura que se le pasa a performBackgroundTask tiene como par\u00e1metro el contexto de persistencia \"secundario\", creado por el persistentContainer . Este contexto se nos asegura que est\u00e1 asociado a una cola de operaciones distinta a la principal. Es decir, se estar\u00eda creando el stack que se muestra en parte en la siguiente figura. En lugar de ejecutar directamente la operaci\u00f3n tambi\u00e9n podemos pedirle al container que cree el contexto \"secundario\", para hacer luego lo que queramos (ejecutar varias operaciones en distintos momentos, por ejemplo) 1 2 let miDelegate = UIApplication . shared . delegate as ! AppDelegate let contextoBG = miDelegate . persistentContainer . newBackgroundContext () En versiones anteriores de iOS era necesario crear el contexto directamente (un objeto de la clase NSManagedObjectContext ) y en el inicializador indicar que quer\u00edamos asociarlo a una cola de operaciones que no fuera la principal. Una vez creado el contexto, con los m\u00e9todos perform o performAndWait podemos ejecutar una operaci\u00f3n en su cola asociada. El primero es as\u00edncrono y el segundo s\u00edncrono, como su propio nombre indica. 1 2 3 4 5 6 let nuevoContexto = NSManagedObjectContext ( concurrencyType :. privateQueueConcurrencyType ) ... nuevoContexto . perform () { //Aqu\u00ed vendr\u00eda la operaci\u00f3n costosa ... } Crear el contexto tal cual se ha visto en este \u00faltimo ejemplo no tiene sentido de manera aislada. Para que funcione, el contexto de persistencia tiene que estar conectado a otras \"piezas\" del stack de Core Data, t\u00edpicamente a un NSPersistentStoreCoordinator . Omitiremos esa parte para simplificar, pero para ello podr\u00edas adaptar el c\u00f3digo generado por Xcode en versiones anteriores a la 8 que se vio en la primera sesi\u00f3n de Core Data.","title":"1 background"},{"location":"cap9/1_background/#multiples-contextos-para-trabajos-en-background","text":"Algunas operaciones con Core Data pueden ser bastante costosas en tiempo: por ejemplo una b\u00fasqueda en una base de datos con muchos registros, o la sincronizaci\u00f3n de los datos con un servicio web. Si efectuamos la operaci\u00f3n en el hilo principal de la aplicaci\u00f3n, donde trabajamos normalmente, la interfaz de usuario se quedar\u00e1 paralizada durante ese tiempo y la aplicaci\u00f3n no responder\u00e1 a los eventos, ya que la interfaz corre en ese hilo. En la asignatura de introducci\u00f3n a iOS y a Swift ya vimos una soluci\u00f3n a ese problema: las colas de operaciones , que b\u00e1sicamente son una forma de crear y gestionar operaciones concurrentes mucho m\u00e1s sencilla para el desarrollador que trabajar directamente con el API de threads . Por desgracia, los NSManagedObjects no son thread-safe , es decir, no se asegura que no se vayan a dar inconsistencias y problemas al acceder a un NSManagedObject desde distintos hilos. As\u00ed que en principio esta soluci\u00f3n no es directamente aplicable. Sin embargo, hay otra posibilidad que s\u00ed nos permitir\u00eda usar varios hilos: tener varios contextos de persistencia, cada uno en un hilo distinto . Un NSManagedObject pertenece solo a un contexto de persistencia, as\u00ed que no habr\u00e1 ning\u00fan problema si siempre para acceder a \u00e9l usamos el thread asociado a su contexto. Lo \u00fanico que necesitamos para solucionar el problema de las operaciones que bloquean la interfaz es un contexto adicional que funcione en un hilo secundario, y realizar la operaci\u00f3n costosa con Core Data en este hilo. El contexto que crea el stack de Core Data por defecto est\u00e1 asociado al hilo principal de la aplicaci\u00f3n, as\u00ed que ese no nos sirve. En iOS el API para crear un nuevo contexto asociado a otro hilo es bastante sencillo, pero con la introducci\u00f3n del NSPersistentContainer en iOS10 ni siquiera es necesario que creemos nosotros mismos el contexto, el container lo hace por nosotros. Todo lo que tenemos que hacer es pasarle al m\u00e9todo performBackgroundTask() el c\u00f3digo a ejecutar en background en forma de clausura: 1 2 3 4 5 6 7 8 9 10 let miDelegate = UIApplication . shared . delegate as ! AppDelegate miDelegate . persistentContainer . performBackgroundTask () { contextoBG in let request = NSFetchRequest < Nota >( entityName : \"Nota\" ) let lista = try ! contextoBG . fetch ( request ) for nota in lista { //Aqu\u00ed hacemos una operaci\u00f3n costosa, como exportar cada nota a PDF //o subirlas a un servidor } } La clausura que se le pasa a performBackgroundTask tiene como par\u00e1metro el contexto de persistencia \"secundario\", creado por el persistentContainer . Este contexto se nos asegura que est\u00e1 asociado a una cola de operaciones distinta a la principal. Es decir, se estar\u00eda creando el stack que se muestra en parte en la siguiente figura. En lugar de ejecutar directamente la operaci\u00f3n tambi\u00e9n podemos pedirle al container que cree el contexto \"secundario\", para hacer luego lo que queramos (ejecutar varias operaciones en distintos momentos, por ejemplo) 1 2 let miDelegate = UIApplication . shared . delegate as ! AppDelegate let contextoBG = miDelegate . persistentContainer . newBackgroundContext () En versiones anteriores de iOS era necesario crear el contexto directamente (un objeto de la clase NSManagedObjectContext ) y en el inicializador indicar que quer\u00edamos asociarlo a una cola de operaciones que no fuera la principal. Una vez creado el contexto, con los m\u00e9todos perform o performAndWait podemos ejecutar una operaci\u00f3n en su cola asociada. El primero es as\u00edncrono y el segundo s\u00edncrono, como su propio nombre indica. 1 2 3 4 5 6 let nuevoContexto = NSManagedObjectContext ( concurrencyType :. privateQueueConcurrencyType ) ... nuevoContexto . perform () { //Aqu\u00ed vendr\u00eda la operaci\u00f3n costosa ... } Crear el contexto tal cual se ha visto en este \u00faltimo ejemplo no tiene sentido de manera aislada. Para que funcione, el contexto de persistencia tiene que estar conectado a otras \"piezas\" del stack de Core Data, t\u00edpicamente a un NSPersistentStoreCoordinator . Omitiremos esa parte para simplificar, pero para ello podr\u00edas adaptar el c\u00f3digo generado por Xcode en versiones anteriores a la 8 que se vio en la primera sesi\u00f3n de Core Data.","title":"M\u00faltiples contextos para trabajos en background"},{"location":"cap9/2_background/","text":"M\u00faltiples contextos para trabajos en background \u00b6 Algunas operaciones con Core Data pueden ser bastante costosas en tiempo: por ejemplo una b\u00fasqueda en una base de datos con muchos registros, o la sincronizaci\u00f3n de los datos con un servicio web. Si efectuamos la operaci\u00f3n en el hilo principal de la aplicaci\u00f3n, donde trabajamos normalmente, la interfaz de usuario se quedar\u00e1 paralizada durante ese tiempo y la aplicaci\u00f3n no responder\u00e1 a los eventos, ya que la interfaz corre en ese hilo. En la asignatura de introducci\u00f3n a iOS y a Swift ya vimos una soluci\u00f3n a ese problema: las colas de operaciones , que b\u00e1sicamente son una forma de crear y gestionar operaciones concurrentes mucho m\u00e1s sencilla para el desarrollador que trabajar directamente con el API de threads . Por desgracia, los NSManagedObjects no son thread-safe , es decir, no se asegura que no se vayan a dar inconsistencias y problemas al acceder a un NSManagedObject desde distintos hilos. As\u00ed que en principio esta soluci\u00f3n no es directamente aplicable. Sin embargo, hay otra posibilidad que s\u00ed nos permitir\u00eda usar varios hilos: tener varios contextos de persistencia, cada uno en un hilo distinto . Un NSManagedObject pertenece solo a un contexto de persistencia, as\u00ed que no habr\u00e1 ning\u00fan problema si siempre para acceder a \u00e9l usamos el thread asociado a su contexto. Lo \u00fanico que necesitamos para solucionar el problema de las operaciones que bloquean la interfaz es un contexto adicional que funcione en un hilo secundario, y realizar la operaci\u00f3n costosa con Core Data en este hilo. El contexto que crea el stack de Core Data por defecto est\u00e1 asociado al hilo principal de la aplicaci\u00f3n, as\u00ed que ese no nos sirve. En iOS el API para crear un nuevo contexto asociado a otro hilo es bastante sencillo, pero con la introducci\u00f3n del NSPersistentContainer en iOS10 ni siquiera es necesario que creemos nosotros mismos el contexto, el container lo hace por nosotros. Todo lo que tenemos que hacer es pasarle al m\u00e9todo performBackgroundTask() el c\u00f3digo a ejecutar en background en forma de clausura: 1 2 3 4 5 6 7 8 9 10 let miDelegate = UIApplication . shared . delegate as ! AppDelegate miDelegate . persistentContainer . performBackgroundTask () { contextoBG in let request = NSFetchRequest < Nota >( entityName : \"Nota\" ) let lista = try ! contextoBG . fetch ( request ) for nota in lista { //Aqu\u00ed hacemos una operaci\u00f3n costosa, como exportar cada nota a PDF //o subirlas a un servidor } } La clausura que se le pasa a performBackgroundTask tiene como par\u00e1metro el contexto de persistencia \"secundario\", creado por el persistentContainer . Este contexto se nos asegura que est\u00e1 asociado a una cola de operaciones distinta a la principal. En lugar de ejecutar directamente la operaci\u00f3n tambi\u00e9n podemos pedirle directamente al container que cree un nuevo contexto asociado a una cola en background . En iOS10 es sencillo: 1 2 let miDelegate = UIApplication . shared . delegate as ! AppDelegate let contextoBG = miDelegate . persistentContainer . newBackgroundContext () En versiones anteriores de iOS era necesario crear el contexto directamente (un objeto de la clase NSManagedObjectContext ) y en el inicializador indicar que quer\u00edamos asociarlo a una cola de operaciones que no fuera la principal. Una vez creado el contexto, con el m\u00e9todo perform (antes performBlock ) podemos ejecutar una operaci\u00f3n en su cola asociada. Dicho m\u00e9todo admite como par\u00e1metro una funci\u00f3n o clausura con el c\u00f3digo a ejecutar. 1 2 3 4 5 6 let nuevoContexto = NSManagedObjectContext ( concurrencyType :. privateQueueConcurrencyType ) ... nuevoContexto . perform () { //Aqu\u00ed vendr\u00eda la operaci\u00f3n costosa ... } perform es as\u00edncrono. La versi\u00f3n as\u00edncrona es performAndWait Crear el contexto tal cual se ha visto en este \u00faltimo ejemplo no tiene sentido de manera aislada. Para que funcione, el contexto de persistencia tiene que estar conectado a otras \"piezas\" del stack de Core Data, t\u00edpicamente a un NSPersistentStoreCoordinator . Omitiremos esa parte para simplificar, pero para ello podr\u00edas adaptar el c\u00f3digo generado por Xcode en versiones anteriores a la 8 que se vio en la primera sesi\u00f3n de Core Data.","title":"2 background"},{"location":"cap9/2_background/#multiples-contextos-para-trabajos-en-background","text":"Algunas operaciones con Core Data pueden ser bastante costosas en tiempo: por ejemplo una b\u00fasqueda en una base de datos con muchos registros, o la sincronizaci\u00f3n de los datos con un servicio web. Si efectuamos la operaci\u00f3n en el hilo principal de la aplicaci\u00f3n, donde trabajamos normalmente, la interfaz de usuario se quedar\u00e1 paralizada durante ese tiempo y la aplicaci\u00f3n no responder\u00e1 a los eventos, ya que la interfaz corre en ese hilo. En la asignatura de introducci\u00f3n a iOS y a Swift ya vimos una soluci\u00f3n a ese problema: las colas de operaciones , que b\u00e1sicamente son una forma de crear y gestionar operaciones concurrentes mucho m\u00e1s sencilla para el desarrollador que trabajar directamente con el API de threads . Por desgracia, los NSManagedObjects no son thread-safe , es decir, no se asegura que no se vayan a dar inconsistencias y problemas al acceder a un NSManagedObject desde distintos hilos. As\u00ed que en principio esta soluci\u00f3n no es directamente aplicable. Sin embargo, hay otra posibilidad que s\u00ed nos permitir\u00eda usar varios hilos: tener varios contextos de persistencia, cada uno en un hilo distinto . Un NSManagedObject pertenece solo a un contexto de persistencia, as\u00ed que no habr\u00e1 ning\u00fan problema si siempre para acceder a \u00e9l usamos el thread asociado a su contexto. Lo \u00fanico que necesitamos para solucionar el problema de las operaciones que bloquean la interfaz es un contexto adicional que funcione en un hilo secundario, y realizar la operaci\u00f3n costosa con Core Data en este hilo. El contexto que crea el stack de Core Data por defecto est\u00e1 asociado al hilo principal de la aplicaci\u00f3n, as\u00ed que ese no nos sirve. En iOS el API para crear un nuevo contexto asociado a otro hilo es bastante sencillo, pero con la introducci\u00f3n del NSPersistentContainer en iOS10 ni siquiera es necesario que creemos nosotros mismos el contexto, el container lo hace por nosotros. Todo lo que tenemos que hacer es pasarle al m\u00e9todo performBackgroundTask() el c\u00f3digo a ejecutar en background en forma de clausura: 1 2 3 4 5 6 7 8 9 10 let miDelegate = UIApplication . shared . delegate as ! AppDelegate miDelegate . persistentContainer . performBackgroundTask () { contextoBG in let request = NSFetchRequest < Nota >( entityName : \"Nota\" ) let lista = try ! contextoBG . fetch ( request ) for nota in lista { //Aqu\u00ed hacemos una operaci\u00f3n costosa, como exportar cada nota a PDF //o subirlas a un servidor } } La clausura que se le pasa a performBackgroundTask tiene como par\u00e1metro el contexto de persistencia \"secundario\", creado por el persistentContainer . Este contexto se nos asegura que est\u00e1 asociado a una cola de operaciones distinta a la principal. En lugar de ejecutar directamente la operaci\u00f3n tambi\u00e9n podemos pedirle directamente al container que cree un nuevo contexto asociado a una cola en background . En iOS10 es sencillo: 1 2 let miDelegate = UIApplication . shared . delegate as ! AppDelegate let contextoBG = miDelegate . persistentContainer . newBackgroundContext () En versiones anteriores de iOS era necesario crear el contexto directamente (un objeto de la clase NSManagedObjectContext ) y en el inicializador indicar que quer\u00edamos asociarlo a una cola de operaciones que no fuera la principal. Una vez creado el contexto, con el m\u00e9todo perform (antes performBlock ) podemos ejecutar una operaci\u00f3n en su cola asociada. Dicho m\u00e9todo admite como par\u00e1metro una funci\u00f3n o clausura con el c\u00f3digo a ejecutar. 1 2 3 4 5 6 let nuevoContexto = NSManagedObjectContext ( concurrencyType :. privateQueueConcurrencyType ) ... nuevoContexto . perform () { //Aqu\u00ed vendr\u00eda la operaci\u00f3n costosa ... } perform es as\u00edncrono. La versi\u00f3n as\u00edncrona es performAndWait Crear el contexto tal cual se ha visto en este \u00faltimo ejemplo no tiene sentido de manera aislada. Para que funcione, el contexto de persistencia tiene que estar conectado a otras \"piezas\" del stack de Core Data, t\u00edpicamente a un NSPersistentStoreCoordinator . Omitiremos esa parte para simplificar, pero para ello podr\u00edas adaptar el c\u00f3digo generado por Xcode en versiones anteriores a la 8 que se vio en la primera sesi\u00f3n de Core Data.","title":"M\u00faltiples contextos para trabajos en background"},{"location":"cap9/2_comunicacion/","text":"Comunicaci\u00f3n entre contextos \u00b6 En la secci\u00f3n anterior hemos visto un ejemplo que implicaba una operaci\u00f3n costosa con objetos gestionados, pero esos objetos gestionados se \"quedaban dentro\" del contexto secundario. Las notas que se recuperaban con la fetch request no se usaban en la cola de operaciones principal, se manejaban solo dentro de la otra cola. Supongamos ahora un caso distinto: una b\u00fasqueda muy costosa, que queremos hacer tambi\u00e9n en background para no bloquear mientras tanto la interfaz de usuario, pero cuyos resultados evidentemente queremos mostrar en pantalla, y posiblemente editar o borrar. \u00bfQu\u00e9 problema tenemos aqu\u00ed? que los resultados de la b\u00fasqueda son NSManagedObjects asociados a un contexto distinto al \"principal\", y las otras operaciones las estar\u00edamos realizando en el contexto \"principal\". Con un NSManagedObject solo se puede operar desde el contexto al que pertenece. N\u00f3tese que todas las operaciones del ciclo de vida ( insertNewObject , fetch , save , delete ), siempre llevan como par\u00e1metro el contexto o directamente se ejecutan sobre el contexto. As\u00ed que no podemos simplemente pasarnos el objeto entre contextos. \u00bfC\u00f3mo podemos resolver esto?. Una forma es usando un identificador \u00fanico que tienen todos los objetos gestionados , que es accesible a trav\u00e9s de la propiedad objectID . Es muy sencillo obtener un objeto a partir de su ID con el m\u00e9todo objectWithID del contexto. Lo interesante es que el ID de un objeto gestionado es el mismo para todos los contextos. La idea entonces ser\u00eda hacer una fetch request en el hilo secundario y \"devolver\" una lista de ID . Desde el contexto principal se \"re-materializar\u00edan\" los objetos gestionados a partir de su ID , pero ahora asociados al contexto \"correcto\". Supongamos otro ejemplo distinto, en el que estar\u00edamos sincronizando los datos con un servicio web, pero no solo enviando datos, sino tambi\u00e9n recibiendo, es decir, modificando objetos persistentes en background . Si los objetos se estuvieran visualizando en el hilo principal necesitar\u00edamos actualizarlos. Por tanto tendr\u00edamos que hacer que el contexto principal se sincronizara con el secundario, no obtener una lista de resultados como en el caso de antes, sino ahora refrescar los datos. Una forma de hacer esto es gracias a las notificaciones que se generan cuando se guarda un objeto gestionado, y que ya comentamos. Afortunadamente, tambi\u00e9n se pueden \"escuchar\" las notificaciones que se emiten desde otro contexto de persistencia. Y tambi\u00e9n afortunadamente hay un m\u00e9todo que \"sincroniza\" un objeto por nosotros, a partir de la notificaci\u00f3n emitida por el objeto que se ha guardado: mergeChanges(fromContextDidSave:) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 let miDelegate = UIApplication . shared . delegate as ! AppDelegate //El contexto principal, como hasta ahora let miContexto = miDelegate . persistentContainer . viewContext //Un contexto secundario let contextoBg = miDelegate . persistentContainer . newBackgroundContext () //El \"notification center\" de la aplicaci\u00f3n let nc = NotificationCenter . default //Cuando el contextoBg emita una notificaci\u00f3n de este tipo, ejecutamos el c\u00f3digo nc . addObserver ( forName : . NSManagedObjectContextDidSave , object : contextoBg , queue : nil ) { notificacion in miContexto . mergeChanges ( fromContextDidSave : notificacion ) }","title":"2 comunicacion"},{"location":"cap9/2_comunicacion/#comunicacion-entre-contextos","text":"En la secci\u00f3n anterior hemos visto un ejemplo que implicaba una operaci\u00f3n costosa con objetos gestionados, pero esos objetos gestionados se \"quedaban dentro\" del contexto secundario. Las notas que se recuperaban con la fetch request no se usaban en la cola de operaciones principal, se manejaban solo dentro de la otra cola. Supongamos ahora un caso distinto: una b\u00fasqueda muy costosa, que queremos hacer tambi\u00e9n en background para no bloquear mientras tanto la interfaz de usuario, pero cuyos resultados evidentemente queremos mostrar en pantalla, y posiblemente editar o borrar. \u00bfQu\u00e9 problema tenemos aqu\u00ed? que los resultados de la b\u00fasqueda son NSManagedObjects asociados a un contexto distinto al \"principal\", y las otras operaciones las estar\u00edamos realizando en el contexto \"principal\". Con un NSManagedObject solo se puede operar desde el contexto al que pertenece. N\u00f3tese que todas las operaciones del ciclo de vida ( insertNewObject , fetch , save , delete ), siempre llevan como par\u00e1metro el contexto o directamente se ejecutan sobre el contexto. As\u00ed que no podemos simplemente pasarnos el objeto entre contextos. \u00bfC\u00f3mo podemos resolver esto?. Una forma es usando un identificador \u00fanico que tienen todos los objetos gestionados , que es accesible a trav\u00e9s de la propiedad objectID . Es muy sencillo obtener un objeto a partir de su ID con el m\u00e9todo objectWithID del contexto. Lo interesante es que el ID de un objeto gestionado es el mismo para todos los contextos. La idea entonces ser\u00eda hacer una fetch request en el hilo secundario y \"devolver\" una lista de ID . Desde el contexto principal se \"re-materializar\u00edan\" los objetos gestionados a partir de su ID , pero ahora asociados al contexto \"correcto\". Supongamos otro ejemplo distinto, en el que estar\u00edamos sincronizando los datos con un servicio web, pero no solo enviando datos, sino tambi\u00e9n recibiendo, es decir, modificando objetos persistentes en background . Si los objetos se estuvieran visualizando en el hilo principal necesitar\u00edamos actualizarlos. Por tanto tendr\u00edamos que hacer que el contexto principal se sincronizara con el secundario, no obtener una lista de resultados como en el caso de antes, sino ahora refrescar los datos. Una forma de hacer esto es gracias a las notificaciones que se generan cuando se guarda un objeto gestionado, y que ya comentamos. Afortunadamente, tambi\u00e9n se pueden \"escuchar\" las notificaciones que se emiten desde otro contexto de persistencia. Y tambi\u00e9n afortunadamente hay un m\u00e9todo que \"sincroniza\" un objeto por nosotros, a partir de la notificaci\u00f3n emitida por el objeto que se ha guardado: mergeChanges(fromContextDidSave:) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 let miDelegate = UIApplication . shared . delegate as ! AppDelegate //El contexto principal, como hasta ahora let miContexto = miDelegate . persistentContainer . viewContext //Un contexto secundario let contextoBg = miDelegate . persistentContainer . newBackgroundContext () //El \"notification center\" de la aplicaci\u00f3n let nc = NotificationCenter . default //Cuando el contextoBg emita una notificaci\u00f3n de este tipo, ejecutamos el c\u00f3digo nc . addObserver ( forName : . NSManagedObjectContextDidSave , object : contextoBg , queue : nil ) { notificacion in miContexto . mergeChanges ( fromContextDidSave : notificacion ) }","title":"Comunicaci\u00f3n entre contextos"},{"location":"cap9/3_contextos_anidados/","text":"Contextos anidados \u00b6 El contexto de persistencia est\u00e1 conectado con un Persistent Store Coordinator , cuyo trabajo, como su propio nombre indica, es el de gestionar el almacenamiento persistente. Cuando almacenamos un objeto haciendo save del contexto, es el store coordinator el que se encarga de \"pelearse\" con la base de datos SQLite (o con el almacenamiento que sea). Cuando tenemos varios contextos, t\u00edpicamente est\u00e1n todos \"conectados\" con el mismo coordinator . Este es el esquema m\u00e1s t\u00edpico en aplicaciones iOS. En iOS5 se introdujo la posibilidad de tener un contexto \"conectado\" con otro en lugar de con un coordinator . Esto se conoce tambi\u00e9n como contexto hijo . El hijo est\u00e1 \"conectado\" con el padre y el padre es el \"conectado\" al coordinator . Cuando desde el hijo se hace un save no se est\u00e1n guardando los datos en el almacenamiento persistente, sino en el contexto padre. Los objetos guardados desde el contexto hijo son \"pendientes de guardar\" para el padre. Es decir, es una operaci\u00f3n puramente en memoria. Para guardarlos en el almacenamiento persistente el padre tambi\u00e9n tendr\u00eda que hacer save . Cuando un contexto est\u00e1 \"conectado\" a un \"persistent store coordinator\" fijamos el valor de su propiedad persistentStoreCoordinator . Para indicar que est\u00e1 conectado a otro contexto \"padre\" fijamos el valor de parent 1 2 3 4 5 6 let contextoPadre = NSManagedObjectContext ( concurrencyType : . mainQueueConcurrencyType ) //El padre est\u00e1 conectado a un \"persistent store coordinator\" contextoPadre . persistentStoreCoordinator = ... let contextoHijo = NSManagedObjectContext ( concurrencyType : . mainQueueConcurrencyType ) //El hijo est\u00e1 conectado al padre contextoHijo . parent = contextoPadre \u00bfPara qu\u00e9 sirve anidar contextos?. T\u00edpicamente se suelen describir dos casos de uso distintos: usar el contexto hijo como un \"borrador\" para realizar operaciones que podemos descartar en cualquier momento, y como una forma de hacer save en background . Veamos el primero de los usos. Pensemos en una aplicaci\u00f3n que tenga una pantalla de edici\u00f3n de datos que implique la creaci\u00f3n y relaci\u00f3n entre s\u00ed de varios objetos. Por ejemplo si estamos editando un pedido de una tienda online tendremos varias entidades implicadas como Pedido , Item , etc. Si en un momento dado el usuario se \"arrepiente\" de hacer el pedido y quiere cancelarlo debemos ser capaces de poder eliminar todas las entidades que hemos creado en el proceso, y los cambios que hayamos hecho en las existentes. Los contextos anidados nos dan la posibilidad de implementar esta funcionalidad de forma muy sencilla: lo \u00fanico que tenemos que hacer es crear todas estas entidades y hacer las modificaciones en un nuevo contexto hijo del principal. Para guardar los cambios que hagamos en ese contexto, haremos save en \u00e9l y luego tambi\u00e9n en el principal. Si por el contrario queremos anular lo hecho en el contexto hijo en realidad no hace falta hacer nada especial. Simplemente no nos molestamos en hacer el save del padre. En el segundo caso, queremos hacer un save de los datos en background . Lo que tenemos que hacer es tener dos contextos en la aplicaci\u00f3n. El padre usar\u00e1 una cola de operaciones de tipo \"privado\" (es decir, distinta a la principal) mientras que el hijo usar\u00e1 la cola principal de operaciones. Cuando realicemos el save del hijo tendremos que hacer save tambi\u00e9n en el padre, pero el save del hijo no bloquear\u00e1 pr\u00e1cticamente la cola principal ya que se trata de una operaci\u00f3n en memoria. El save del padre ser\u00e1 m\u00e1s costoso en tiempo, pero no habr\u00e1 problema ya que lo har\u00e1 en background .","title":"3 contextos anidados"},{"location":"cap9/3_contextos_anidados/#contextos-anidados","text":"El contexto de persistencia est\u00e1 conectado con un Persistent Store Coordinator , cuyo trabajo, como su propio nombre indica, es el de gestionar el almacenamiento persistente. Cuando almacenamos un objeto haciendo save del contexto, es el store coordinator el que se encarga de \"pelearse\" con la base de datos SQLite (o con el almacenamiento que sea). Cuando tenemos varios contextos, t\u00edpicamente est\u00e1n todos \"conectados\" con el mismo coordinator . Este es el esquema m\u00e1s t\u00edpico en aplicaciones iOS. En iOS5 se introdujo la posibilidad de tener un contexto \"conectado\" con otro en lugar de con un coordinator . Esto se conoce tambi\u00e9n como contexto hijo . El hijo est\u00e1 \"conectado\" con el padre y el padre es el \"conectado\" al coordinator . Cuando desde el hijo se hace un save no se est\u00e1n guardando los datos en el almacenamiento persistente, sino en el contexto padre. Los objetos guardados desde el contexto hijo son \"pendientes de guardar\" para el padre. Es decir, es una operaci\u00f3n puramente en memoria. Para guardarlos en el almacenamiento persistente el padre tambi\u00e9n tendr\u00eda que hacer save . Cuando un contexto est\u00e1 \"conectado\" a un \"persistent store coordinator\" fijamos el valor de su propiedad persistentStoreCoordinator . Para indicar que est\u00e1 conectado a otro contexto \"padre\" fijamos el valor de parent 1 2 3 4 5 6 let contextoPadre = NSManagedObjectContext ( concurrencyType : . mainQueueConcurrencyType ) //El padre est\u00e1 conectado a un \"persistent store coordinator\" contextoPadre . persistentStoreCoordinator = ... let contextoHijo = NSManagedObjectContext ( concurrencyType : . mainQueueConcurrencyType ) //El hijo est\u00e1 conectado al padre contextoHijo . parent = contextoPadre \u00bfPara qu\u00e9 sirve anidar contextos?. T\u00edpicamente se suelen describir dos casos de uso distintos: usar el contexto hijo como un \"borrador\" para realizar operaciones que podemos descartar en cualquier momento, y como una forma de hacer save en background . Veamos el primero de los usos. Pensemos en una aplicaci\u00f3n que tenga una pantalla de edici\u00f3n de datos que implique la creaci\u00f3n y relaci\u00f3n entre s\u00ed de varios objetos. Por ejemplo si estamos editando un pedido de una tienda online tendremos varias entidades implicadas como Pedido , Item , etc. Si en un momento dado el usuario se \"arrepiente\" de hacer el pedido y quiere cancelarlo debemos ser capaces de poder eliminar todas las entidades que hemos creado en el proceso, y los cambios que hayamos hecho en las existentes. Los contextos anidados nos dan la posibilidad de implementar esta funcionalidad de forma muy sencilla: lo \u00fanico que tenemos que hacer es crear todas estas entidades y hacer las modificaciones en un nuevo contexto hijo del principal. Para guardar los cambios que hagamos en ese contexto, haremos save en \u00e9l y luego tambi\u00e9n en el principal. Si por el contrario queremos anular lo hecho en el contexto hijo en realidad no hace falta hacer nada especial. Simplemente no nos molestamos en hacer el save del padre. En el segundo caso, queremos hacer un save de los datos en background . Lo que tenemos que hacer es tener dos contextos en la aplicaci\u00f3n. El padre usar\u00e1 una cola de operaciones de tipo \"privado\" (es decir, distinta a la principal) mientras que el hijo usar\u00e1 la cola principal de operaciones. Cuando realicemos el save del hijo tendremos que hacer save tambi\u00e9n en el padre, pero el save del hijo no bloquear\u00e1 pr\u00e1cticamente la cola principal ya que se trata de una operaci\u00f3n en memoria. El save del padre ser\u00e1 m\u00e1s costoso en tiempo, pero no habr\u00e1 problema ya que lo har\u00e1 en background .","title":"Contextos anidados"},{"location":"cap9/4_contextos_anidados/","text":"Contextos anidados \u00b6 El contexto de persistencia est\u00e1 conectado con un Persistent Store Coordinator , cuyo trabajo, como su propio nombre indica, es el de gestionar el almacenamiento persistente. Cuando almacenamos un objeto haciendo save del contexto, es el store coordinator el que se encarga de \"pelearse\" con la base de datos SQLite (o con el almacenamiento que sea). Cuando tenemos varios contextos, t\u00edpicamente est\u00e1n todos \"conectados\" con el mismo coordinator . En iOS5 se introdujo la posibilidad de tener un contexto \"conectado\" con otro en lugar de con un coordinator . Esto se conoce tambi\u00e9n como contexto hijo . El hijo est\u00e1 \"conectado\" con el padre y el padre es el \"conectado\" al coordinator . Cuando desde el hijo se hace un save no se est\u00e1n guardando los datos en el almacenamiento persistente, sino en el contexto padre. Es decir, los save del hijo representan modificaciones pendientes de almacenar para el padre. Para guardarlos en el almacenamiento persistente el padre tambi\u00e9n tendr\u00eda que hacer save . N\u00f3tese que el save del hijo es una operaci\u00f3n puramente en memoria, lo que implica dos cosas: es r\u00e1pida y no es persistente. Precisamente estas dos caracter\u00edsticas van a ser las que nos dar\u00e1n dos casos de uso para esta funcionalidad. Vamos primero con el hecho de que el save del hijo no es una operaci\u00f3n persistente. \u00bfQu\u00e9 utilidad puede tener esto?. Pensemos en una aplicaci\u00f3n que tenga una pantalla de edici\u00f3n de datos que implique la creaci\u00f3n y relaci\u00f3n entre s\u00ed de varios objetos. Por ejemplo si estamos editando un pedido de una tienda online tendremos varias entidades implicadas como Pedido , Item , etc. Si en un momento dado el usuario se \"arrepiente\" de hacer el pedido y quiere cancelarlo debemos ser capaces de poder eliminar todas las entidades que hemos creado en el proceso, y los cambios que hayamos hecho en las existentes. Los contextos anidados nos dan la posibilidad de implementar esta funcionalidad de forma muy sencilla: lo \u00fanico que tenemos que hacer es crear todas estas entidades y hacer las modificaciones en un nuevo contexto hijo del principal. Para guardar los cambios que hagamos en ese contexto, haremos save en \u00e9l y luego tambi\u00e9n en el principal. Si por el contrario queremos anular lo hecho en el contexto hijo en realidad no hace falta hacer nada especial. Simplemente no nos molestamos en hacer el save del hijo y seguimos trabajando con el padre. Por otro lado podemos aprovechar que el save del padre es r\u00e1pido al ser solo en memoria para implementar una funcionalidad de \"guardar en background \" de un modo alternativo a como vimos en el primer apartado de la sesi\u00f3n. La idea es tener un contexto hijo que funcione en la cola principal y uno padre en una cola en background . Este \u00faltimo est\u00e1 conectado al persistent store coordinator . El hijo es el contexto \"principal\", en el que vamos a trabajar todo el rato. Cuando tengamos que hacer alguna operaci\u00f3n costosa de guardado de datos hacemos el save en el padre, que ser\u00e1 muy r\u00e1pido ya que es en memoria. El save del padre en el almacenamiento persistente ya no ser\u00e1 tan r\u00e1pido, pero al estar en una cola en background no va a afectar a la fluidez de la interfaz de usuario.","title":"4 contextos anidados"},{"location":"cap9/4_contextos_anidados/#contextos-anidados","text":"El contexto de persistencia est\u00e1 conectado con un Persistent Store Coordinator , cuyo trabajo, como su propio nombre indica, es el de gestionar el almacenamiento persistente. Cuando almacenamos un objeto haciendo save del contexto, es el store coordinator el que se encarga de \"pelearse\" con la base de datos SQLite (o con el almacenamiento que sea). Cuando tenemos varios contextos, t\u00edpicamente est\u00e1n todos \"conectados\" con el mismo coordinator . En iOS5 se introdujo la posibilidad de tener un contexto \"conectado\" con otro en lugar de con un coordinator . Esto se conoce tambi\u00e9n como contexto hijo . El hijo est\u00e1 \"conectado\" con el padre y el padre es el \"conectado\" al coordinator . Cuando desde el hijo se hace un save no se est\u00e1n guardando los datos en el almacenamiento persistente, sino en el contexto padre. Es decir, los save del hijo representan modificaciones pendientes de almacenar para el padre. Para guardarlos en el almacenamiento persistente el padre tambi\u00e9n tendr\u00eda que hacer save . N\u00f3tese que el save del hijo es una operaci\u00f3n puramente en memoria, lo que implica dos cosas: es r\u00e1pida y no es persistente. Precisamente estas dos caracter\u00edsticas van a ser las que nos dar\u00e1n dos casos de uso para esta funcionalidad. Vamos primero con el hecho de que el save del hijo no es una operaci\u00f3n persistente. \u00bfQu\u00e9 utilidad puede tener esto?. Pensemos en una aplicaci\u00f3n que tenga una pantalla de edici\u00f3n de datos que implique la creaci\u00f3n y relaci\u00f3n entre s\u00ed de varios objetos. Por ejemplo si estamos editando un pedido de una tienda online tendremos varias entidades implicadas como Pedido , Item , etc. Si en un momento dado el usuario se \"arrepiente\" de hacer el pedido y quiere cancelarlo debemos ser capaces de poder eliminar todas las entidades que hemos creado en el proceso, y los cambios que hayamos hecho en las existentes. Los contextos anidados nos dan la posibilidad de implementar esta funcionalidad de forma muy sencilla: lo \u00fanico que tenemos que hacer es crear todas estas entidades y hacer las modificaciones en un nuevo contexto hijo del principal. Para guardar los cambios que hagamos en ese contexto, haremos save en \u00e9l y luego tambi\u00e9n en el principal. Si por el contrario queremos anular lo hecho en el contexto hijo en realidad no hace falta hacer nada especial. Simplemente no nos molestamos en hacer el save del hijo y seguimos trabajando con el padre. Por otro lado podemos aprovechar que el save del padre es r\u00e1pido al ser solo en memoria para implementar una funcionalidad de \"guardar en background \" de un modo alternativo a como vimos en el primer apartado de la sesi\u00f3n. La idea es tener un contexto hijo que funcione en la cola principal y uno padre en una cola en background . Este \u00faltimo est\u00e1 conectado al persistent store coordinator . El hijo es el contexto \"principal\", en el que vamos a trabajar todo el rato. Cuando tengamos que hacer alguna operaci\u00f3n costosa de guardado de datos hacemos el save en el padre, que ser\u00e1 muy r\u00e1pido ya que es en memoria. El save del padre en el almacenamiento persistente ya no ser\u00e1 tan r\u00e1pido, pero al estar en una cola en background no va a afectar a la fluidez de la interfaz de usuario.","title":"Contextos anidados"},{"location":"cap9/4_ejercicios/","text":"En las plantillas de la sesi\u00f3n hay un proyecto llamado PruebaContextosMultiples que servir\u00e1 como base para los ejercicios de la sesi\u00f3n. La aplicaci\u00f3n solo tiene una pantalla con un listado de notas (no se pueden crear ni modificar). Hay dos operaciones costosas: exportar las notas y refrescar el listado con datos que vengan del servidor. En ambos casos el coste es simulado ya que ni se exportan de verdad ni se actualizan desde ning\u00fan servidor (ejem). El coste se simula \"durmiendo\" al hilo actual con la instrucci\u00f3n usleep . Cuando la aplicaci\u00f3n se carga, si no hay datos autom\u00e1ticamente inserta 500 objetos en la base de datos. Contextos m\u00faltiples para operaciones en background (2 puntos) \u00b6 Pulsa sobre el bot\u00f3n de \"exportar\". Ver\u00e1s que la operaci\u00f3n tarda 2-3 segundos. Si intentas hacer scroll de la pantalla durante este tiempo no podr\u00e1s, ya que se queda bloqueada. Hay que solucionar esto. ver\u00e1s que en el m\u00e9todo botonExportarPulsado del view controller se llama a un m\u00e9todo que (de modo simulado) exporta las notas y que es el \"culpable\" del bloqueo. El m\u00e9todo admite como par\u00e1metro el contexto de persistencia. Cambia el c\u00f3digo para que esta operaci\u00f3n se haga en un nuevo contexto en background . Recuerda que las operaciones de interfaz (como mostrar el alert tras la exportaci\u00f3n) deben hacerse en el thread principal.","title":"4 ejercicios"},{"location":"cap9/4_ejercicios/#contextos-multiples-para-operaciones-en-background-2-puntos","text":"Pulsa sobre el bot\u00f3n de \"exportar\". Ver\u00e1s que la operaci\u00f3n tarda 2-3 segundos. Si intentas hacer scroll de la pantalla durante este tiempo no podr\u00e1s, ya que se queda bloqueada. Hay que solucionar esto. ver\u00e1s que en el m\u00e9todo botonExportarPulsado del view controller se llama a un m\u00e9todo que (de modo simulado) exporta las notas y que es el \"culpable\" del bloqueo. El m\u00e9todo admite como par\u00e1metro el contexto de persistencia. Cambia el c\u00f3digo para que esta operaci\u00f3n se haga en un nuevo contexto en background . Recuerda que las operaciones de interfaz (como mostrar el alert tras la exportaci\u00f3n) deben hacerse en el thread principal.","title":"Contextos m\u00faltiples para operaciones en background (2 puntos)"},{"location":"cap9/intro/","text":"Hasta ahora siempre hemos usado el stack de Core Data que Xcode crea para nosotros al crear un nuevo proyecto. Este stack es muy simple, pero podemos personalizarlo totalmente seg\u00fan las necesidades de nuestra aplicaci\u00f3n. La personalizaci\u00f3n m\u00e1s t\u00edpica en aplicaciones iOS es usar varios contextos de persistencia en lugar de uno solo. En esta sesi\u00f3n veremos por qu\u00e9 es necesario usar varios contextos cuando hagamos programaci\u00f3n concurrente y c\u00f3mo conectar y comunicar los contextos entre s\u00ed y con el resto de \"piezas\" del stack .","title":"Intro"},{"location":"miniproyecto/restaurante_parte_1/","text":"Miniproyecto: app restaurante. Parte 1: El modelo de datos \u00b6 El objetivo es desarrollar una peque\u00f1a aplicaci\u00f3n para gestionar pedidos online a un restaurante. Para ello almacenaremos los datos de la carta y de los pedidos realizados por el usuario en Core Data. Desc\u00e1rgate la plantilla de la aplicaci\u00f3n desde moodle, aqu\u00ed est\u00e1 ya implementada la mayor parte de la interfaz. En esta primera sesi\u00f3n nos ocuparemos del modelo de datos y de leer los datos de los platos, que est\u00e1n almacenados en un JSON, y pasarlos a Core Data. El modelo de datos (1 punto) \u00b6 En el proyecto abre el fichero Restaurante.xcdatamodeld y crea el siguiente modelo de datos Nuestro modelo de datos debe tener tres entidades, Plato , Pedido y LineaPedido . Esta \u00faltima es la que relaciona los platos con los pedidos, guardando cu\u00e1ntas unidades de un plato se han incluido en un pedido. Cada entidad debe tener las siguientes propiedades y relaciones Plato : Propiedades: nombre de tipo String descripcion de tipo String precio de tipo Double tipo de tipo String Relaciones: lineasPedido , relaci\u00f3n \"a muchos\" con destino LineaPedido . La inversa es la relaci\u00f3n plato Pedido : Propiedades: direccion de tipo String telefono de tipo String fecha de tipo Date total de tipo `Double Relaciones: lineasPedido , relaci\u00f3n \"a muchos\" con destino LineaPedido . La relaci\u00f3n debe ser ordenada , para poder mostrar las lineas de un pedido siempre en el mismo orden. La inversa es la relaci\u00f3n pedido . En la regla de borrado ( delete rule ) pon Cascade para que al eliminar un pedido se eliminen autom\u00e1ticamente sus l\u00edneas. LineaPedido : Propiedades cantidad de tipo Integer 16 Relaciones pedido , relaci\u00f3n \"a uno\" con destino Pedido . La inversa es la relaci\u00f3n lineasPedido plato , relaci\u00f3n \"a uno\" con destino Plato . La inversa es la relaci\u00f3n lineasPedido Simplificaciones : en realidad se deber\u00edan usar tipos Decimal en los precios para evitar errores de redondeo, pero usaremos Double por simplicidad de uso. Adem\u00e1s, el tipo del plato deber\u00eda ser un enumerado, pero estos no se pueden almacenar directamente en Core Data. Tendr\u00edamos que generar manualmente el c\u00f3digo de las entidades para poder representar los datos externamente como enums e internamente como otro tipo. Inicializar los datos (0,5 puntos) \u00b6 Los datos de los platos del restaurante est\u00e1n en un archivo platos.json . En el AppDelegate hay una funci\u00f3n importPlatos que lee el JSON, lo almacena en un array de structs de tipo DatosPlato con los datos correspondientes, y pone una preferencia de usuario llamada platosImportados a true . El JSON solo se lee si la preferencia est\u00e1 a false (valor por defecto) A\u00f1ade c\u00f3digo Swift que copie los datos de los structs a entidades Plato y guarde el contexto de persistencia para hacer efectivos los cambios . Tendr\u00e1s que introducir el c\u00f3digo en el AppDelegate , donde est\u00e1 el comentario de TODO: . El array de structs de tipo DatosPlato se llama datos . Copia todos sus datos a Core Data. Tras esto, con la ayuda de la aplicaci\u00f3n SimSim puedes echarle un vistazo a la base de datos de SQLite creada por Core Data para ver si est\u00e1n los registros. En SimSim selecciona la app Restaurante y luego la opci\u00f3n Finder para abrir la carpeta donde se guardan sus datos en el emulador. La base de datos de SQLite se almacena en Library/Application Support . Luego con la ayuda de alg\u00fan visor de SQLite puedes ver el contenido de la BD. Si no tienes ninguno instalado puedes usar https://sqliteonline.com/ . Para forzar la recarga de los datos tambi\u00e9n puedes usar tambi\u00e9n la aplicaci\u00f3n SimSim . Tendr\u00e1s que borrar las preferencias y la base de datos. Las preferencias est\u00e1n en Library/Preferences .","title":"Enunciado parte I"},{"location":"miniproyecto/restaurante_parte_1/#miniproyecto-app-restaurante-parte-1-el-modelo-de-datos","text":"El objetivo es desarrollar una peque\u00f1a aplicaci\u00f3n para gestionar pedidos online a un restaurante. Para ello almacenaremos los datos de la carta y de los pedidos realizados por el usuario en Core Data. Desc\u00e1rgate la plantilla de la aplicaci\u00f3n desde moodle, aqu\u00ed est\u00e1 ya implementada la mayor parte de la interfaz. En esta primera sesi\u00f3n nos ocuparemos del modelo de datos y de leer los datos de los platos, que est\u00e1n almacenados en un JSON, y pasarlos a Core Data.","title":"Miniproyecto: app restaurante. Parte 1: El modelo de datos"},{"location":"miniproyecto/restaurante_parte_1/#el-modelo-de-datos-1-punto","text":"En el proyecto abre el fichero Restaurante.xcdatamodeld y crea el siguiente modelo de datos Nuestro modelo de datos debe tener tres entidades, Plato , Pedido y LineaPedido . Esta \u00faltima es la que relaciona los platos con los pedidos, guardando cu\u00e1ntas unidades de un plato se han incluido en un pedido. Cada entidad debe tener las siguientes propiedades y relaciones Plato : Propiedades: nombre de tipo String descripcion de tipo String precio de tipo Double tipo de tipo String Relaciones: lineasPedido , relaci\u00f3n \"a muchos\" con destino LineaPedido . La inversa es la relaci\u00f3n plato Pedido : Propiedades: direccion de tipo String telefono de tipo String fecha de tipo Date total de tipo `Double Relaciones: lineasPedido , relaci\u00f3n \"a muchos\" con destino LineaPedido . La relaci\u00f3n debe ser ordenada , para poder mostrar las lineas de un pedido siempre en el mismo orden. La inversa es la relaci\u00f3n pedido . En la regla de borrado ( delete rule ) pon Cascade para que al eliminar un pedido se eliminen autom\u00e1ticamente sus l\u00edneas. LineaPedido : Propiedades cantidad de tipo Integer 16 Relaciones pedido , relaci\u00f3n \"a uno\" con destino Pedido . La inversa es la relaci\u00f3n lineasPedido plato , relaci\u00f3n \"a uno\" con destino Plato . La inversa es la relaci\u00f3n lineasPedido Simplificaciones : en realidad se deber\u00edan usar tipos Decimal en los precios para evitar errores de redondeo, pero usaremos Double por simplicidad de uso. Adem\u00e1s, el tipo del plato deber\u00eda ser un enumerado, pero estos no se pueden almacenar directamente en Core Data. Tendr\u00edamos que generar manualmente el c\u00f3digo de las entidades para poder representar los datos externamente como enums e internamente como otro tipo.","title":"El modelo de datos (1 punto)"},{"location":"miniproyecto/restaurante_parte_1/#inicializar-los-datos-05-puntos","text":"Los datos de los platos del restaurante est\u00e1n en un archivo platos.json . En el AppDelegate hay una funci\u00f3n importPlatos que lee el JSON, lo almacena en un array de structs de tipo DatosPlato con los datos correspondientes, y pone una preferencia de usuario llamada platosImportados a true . El JSON solo se lee si la preferencia est\u00e1 a false (valor por defecto) A\u00f1ade c\u00f3digo Swift que copie los datos de los structs a entidades Plato y guarde el contexto de persistencia para hacer efectivos los cambios . Tendr\u00e1s que introducir el c\u00f3digo en el AppDelegate , donde est\u00e1 el comentario de TODO: . El array de structs de tipo DatosPlato se llama datos . Copia todos sus datos a Core Data. Tras esto, con la ayuda de la aplicaci\u00f3n SimSim puedes echarle un vistazo a la base de datos de SQLite creada por Core Data para ver si est\u00e1n los registros. En SimSim selecciona la app Restaurante y luego la opci\u00f3n Finder para abrir la carpeta donde se guardan sus datos en el emulador. La base de datos de SQLite se almacena en Library/Application Support . Luego con la ayuda de alg\u00fan visor de SQLite puedes ver el contenido de la BD. Si no tienes ninguno instalado puedes usar https://sqliteonline.com/ . Para forzar la recarga de los datos tambi\u00e9n puedes usar tambi\u00e9n la aplicaci\u00f3n SimSim . Tendr\u00e1s que borrar las preferencias y la base de datos. Las preferencias est\u00e1n en Library/Preferences .","title":"Inicializar los datos (0,5 puntos)"},{"location":"miniproyecto/restaurante_parte_2/","text":"Miniproyecto: app restaurante. Parte 2: Las pantallas de la app \u00b6 En esta segunda parte implementaremos las pantallas de la app . La mayor parte de la interfaz ya est\u00e1 creada, t\u00fa tienes que implementar las funcionalidades en Core Data. La Carta (3 puntos) \u00b6 Esta parte de la app es la que muestra los platos y nos permite a\u00f1adirlos al pedido. Inicializar los datos \u00b6 Los datos de los platos del restaurante est\u00e1n en un archivo platos.json . En el AppDelegate hay una funci\u00f3n importPlatos que lee el JSON, lo almacena en un array de structs con los datos correspondientes, y pone una preferencia de usuario llamada platosImportados a true . El JSON solo se lee si la preferencia est\u00e1 a false (valor por defecto) A\u00f1ade c\u00f3digo Swift que copie los datos de los structs a entidades Plato y guarde el contexto de persistencia para hacer efectivos los cambios . Para forzar el borrado de la base de datos o las preferencias puedes usar la aplicaci\u00f3n SimSim para borrar el almacenamiento de la app Restaurante en el simulador (selecciona la app y luego la opci\u00f3n Finder para abrir la carpeta). La base de datos de SQLite se almacena en Library/Application Support y las preferencias de usuario en Library/Preferences La pantalla de Carta ( PlatosViewController ) \u00b6 En esta pantalla se deben mostrar los datos de los platos. Est\u00e1 controlada por el PlatosViewController . Iremos primero con que salgan los platos listados y luego con la funcionalidad del bot\u00f3n de \"A\u00f1adir\" al pedido. Listado de platos Usa un NSFetchedResultsController para listar los platos en la tabla. Haz que los platos se agrupen en secciones seg\u00fan su tipo. Las celdas de la tabla son de la clase PlatoTableViewCell , aqu\u00ed ya est\u00e1n definidos los outlets para poder rellenar los datos. Implementa una b\u00fasqueda/filtrado de platos como hiciste en la aplicaci\u00f3n de notas, que busque texto en el nombre o en la descripci\u00f3n del plato. Para aplicar el \"filtro\" puedes: Crear un predicado ( NSPredicate ) con la condici\u00f3n de b\u00fasqueda y asign\u00e1rselo a la propiedad fetchRequest.predicate del NSFetchedResultsController . Para que se actualicen los datos tendr\u00e1s que hacer un performFetch del NSFetchedResultsController A\u00f1adir al pedido actual Las celdas de la tabla usan el patr\u00f3n delegate para avisar de que se ha pulsado el bot\u00f3n \"A\u00f1adir\". Cada celda almacena su IndexPath (su n\u00famero de fila y de secci\u00f3n) y tiene como delegate al controller de la pantalla. Para avisar al controller de que se ha pulsado sobre \"A\u00f1adir\" se llama al m\u00e9todo platoA\u00f1adido . Aqu\u00ed tienes que obtener la entidad Plato elegida (la que est\u00e1 en la fila y secci\u00f3n seleccionadas) para que el c\u00f3digo restante (ya implementado) se lo pase al controller de la pantalla siguiente. El pedido actual ( PedidoActualViewController ) (3 puntos) \u00b6 A partir de aqu\u00ed necesitar\u00e1s tener tambi\u00e9n las entidades Pedido y LineaPedido . Recuerda tambi\u00e9n a\u00f1adir la relaci\u00f3n lineasPedido a la entidad plato (puedes ver el modelo completo en el ap\u00e9ndice) Esta parte de la app muestra los datos del pedido actual, a\u00f1ade los platos seleccionados al pedido y permite hacer el pedido o cancelarlo. El controller recibe el plato elegido desde el controller anterior en la propiedad platoElegido , hay que a\u00f1adir una entidad LineaPedido que vincule este plato con el pedido actual. El pedido actual no se puede guardar en el propio controller ya que por la navegaci\u00f3n entre pantallas este se destruir\u00eda al salir de ella. Por eso se debe guardar aparte, en la variable pedidoActual del singleton StateSingleton.shared . Esta variable estaba comentada para que no diera error ya que hasta ahora no exist\u00eda la entidad Pedido , descom\u00e9ntala . A\u00f1adir el plato elegido al pedido \u00b6 En el viewDidLoad de PedidoActualViewController nos tenemos que ocupar de a\u00f1adir el plato elegido al pedido actual Primero comprueba si ya existe un Pedido actual ( StateSingleton.shared.pedidoActual!=nil ), y si no existe cr\u00e9alo en Core Data, gu\u00e1rdalo en el StateSingleton y haz save() del contexto de persistencia Crea un nuevo LineaPedido As\u00edgnale cantidad 1 As\u00f3cialo con el plato elegido. Recuerda que el plato elegido deber\u00eda estar en la propiedad platoElegido del controller. As\u00f3cialo con el pedido. Xcode deber\u00eda haber generado un m\u00e9todo de Pedido llamado addToLineasPedido para a\u00f1adir una l\u00ednea de pedido a un pedido. Cambiar la cantidad de un plato \u00b6 En esta pantalla tambi\u00e9n se puede cambiar el n\u00famero de unidades que queremos pedir de un plato. Para simplificar solo podemos movernos entre 1 y 100, no podemos bajar las unidades a 0 y eliminar el plato Al igual que en la pantalla anterior se usa la idea de delegate para saber qu\u00e9 celda se est\u00e1 seleccionando. Las celdas son de la clase LineaPedidoTableviewCell , y cada vez que se pulsa en un + o un - se avisa al delegate (en este caso el controller), pas\u00e1ndole el n\u00famero de la fila. El m\u00e9todo cantidadCambiada del controller se llamar\u00e1 cada vez que el usuario cambie la cantidad de un plato. A\u00f1ade c\u00f3digo que obtenga la l\u00ednea de pedido correspondiente, cambie la cantidad y guarde los cambios Realizar y cancelar pedido \u00b6 En la pantalla tienes dos botones para realizar y cancelar el pedido. Si se pulsa a \"realizar\" bastar\u00e1 con que le asignes la fecha actual al pedido, crees un nuevo pedido en StateSingleton.shared.pedidoActual y muestres un mensaje al usuario indicando que \"su pedido est\u00e1 en camino\" o algo similar Si se pulsa a \"cancelar\" deber\u00edas borrar en Core Data el pedido actual. Si la regla de borrado en cascada est\u00e1 puesta correctamente, al borrar un pedido deber\u00edan borrarse autom\u00e1ticamente todas sus l\u00edneas. Tu historial ( PedidosViewController ) (hasta 4 puntos) \u00b6 En esta pantalla se deber\u00edan mostrar todos los pedidos realizados por el usuario actual. Est\u00e1 en blanco y puedes crear la interfaz del modo que desees. (1 punto) Si en el viewWillAppear muestras los datos de todos los pedidos en la consola con print , solo para ver que efectivamente se han almacenado correctamente (2 puntos) Si muestras en una tabla una l\u00ednea con el resumen de cada pedido (fecha, total y n\u00famero de platos pedidos) (4 puntos) Si muestras una pantalla con el listado de pedidos y otra con los detalles de cada uno Ap\u00e9ndice: \u00b6","title":"Miniproyecto: *app* restaurante. Parte 2: Las pantallas de la *app*"},{"location":"miniproyecto/restaurante_parte_2/#miniproyecto-app-restaurante-parte-2-las-pantallas-de-la-app","text":"En esta segunda parte implementaremos las pantallas de la app . La mayor parte de la interfaz ya est\u00e1 creada, t\u00fa tienes que implementar las funcionalidades en Core Data.","title":"Miniproyecto: app restaurante. Parte 2: Las pantallas de la app"},{"location":"miniproyecto/restaurante_parte_2/#la-carta-3-puntos","text":"Esta parte de la app es la que muestra los platos y nos permite a\u00f1adirlos al pedido.","title":"La Carta (3 puntos)"},{"location":"miniproyecto/restaurante_parte_2/#inicializar-los-datos","text":"Los datos de los platos del restaurante est\u00e1n en un archivo platos.json . En el AppDelegate hay una funci\u00f3n importPlatos que lee el JSON, lo almacena en un array de structs con los datos correspondientes, y pone una preferencia de usuario llamada platosImportados a true . El JSON solo se lee si la preferencia est\u00e1 a false (valor por defecto) A\u00f1ade c\u00f3digo Swift que copie los datos de los structs a entidades Plato y guarde el contexto de persistencia para hacer efectivos los cambios . Para forzar el borrado de la base de datos o las preferencias puedes usar la aplicaci\u00f3n SimSim para borrar el almacenamiento de la app Restaurante en el simulador (selecciona la app y luego la opci\u00f3n Finder para abrir la carpeta). La base de datos de SQLite se almacena en Library/Application Support y las preferencias de usuario en Library/Preferences","title":"Inicializar los datos"},{"location":"miniproyecto/restaurante_parte_2/#la-pantalla-de-carta-platosviewcontroller","text":"En esta pantalla se deben mostrar los datos de los platos. Est\u00e1 controlada por el PlatosViewController . Iremos primero con que salgan los platos listados y luego con la funcionalidad del bot\u00f3n de \"A\u00f1adir\" al pedido.","title":"La pantalla de Carta (PlatosViewController)"},{"location":"miniproyecto/restaurante_parte_2/#el-pedido-actual-pedidoactualviewcontroller-3-puntos","text":"A partir de aqu\u00ed necesitar\u00e1s tener tambi\u00e9n las entidades Pedido y LineaPedido . Recuerda tambi\u00e9n a\u00f1adir la relaci\u00f3n lineasPedido a la entidad plato (puedes ver el modelo completo en el ap\u00e9ndice) Esta parte de la app muestra los datos del pedido actual, a\u00f1ade los platos seleccionados al pedido y permite hacer el pedido o cancelarlo. El controller recibe el plato elegido desde el controller anterior en la propiedad platoElegido , hay que a\u00f1adir una entidad LineaPedido que vincule este plato con el pedido actual. El pedido actual no se puede guardar en el propio controller ya que por la navegaci\u00f3n entre pantallas este se destruir\u00eda al salir de ella. Por eso se debe guardar aparte, en la variable pedidoActual del singleton StateSingleton.shared . Esta variable estaba comentada para que no diera error ya que hasta ahora no exist\u00eda la entidad Pedido , descom\u00e9ntala .","title":"El pedido actual (PedidoActualViewController) (3 puntos)"},{"location":"miniproyecto/restaurante_parte_2/#anadir-el-plato-elegido-al-pedido","text":"En el viewDidLoad de PedidoActualViewController nos tenemos que ocupar de a\u00f1adir el plato elegido al pedido actual Primero comprueba si ya existe un Pedido actual ( StateSingleton.shared.pedidoActual!=nil ), y si no existe cr\u00e9alo en Core Data, gu\u00e1rdalo en el StateSingleton y haz save() del contexto de persistencia Crea un nuevo LineaPedido As\u00edgnale cantidad 1 As\u00f3cialo con el plato elegido. Recuerda que el plato elegido deber\u00eda estar en la propiedad platoElegido del controller. As\u00f3cialo con el pedido. Xcode deber\u00eda haber generado un m\u00e9todo de Pedido llamado addToLineasPedido para a\u00f1adir una l\u00ednea de pedido a un pedido.","title":"A\u00f1adir el plato elegido al pedido"},{"location":"miniproyecto/restaurante_parte_2/#cambiar-la-cantidad-de-un-plato","text":"En esta pantalla tambi\u00e9n se puede cambiar el n\u00famero de unidades que queremos pedir de un plato. Para simplificar solo podemos movernos entre 1 y 100, no podemos bajar las unidades a 0 y eliminar el plato Al igual que en la pantalla anterior se usa la idea de delegate para saber qu\u00e9 celda se est\u00e1 seleccionando. Las celdas son de la clase LineaPedidoTableviewCell , y cada vez que se pulsa en un + o un - se avisa al delegate (en este caso el controller), pas\u00e1ndole el n\u00famero de la fila. El m\u00e9todo cantidadCambiada del controller se llamar\u00e1 cada vez que el usuario cambie la cantidad de un plato. A\u00f1ade c\u00f3digo que obtenga la l\u00ednea de pedido correspondiente, cambie la cantidad y guarde los cambios","title":"Cambiar la cantidad de un plato"},{"location":"miniproyecto/restaurante_parte_2/#realizar-y-cancelar-pedido","text":"En la pantalla tienes dos botones para realizar y cancelar el pedido. Si se pulsa a \"realizar\" bastar\u00e1 con que le asignes la fecha actual al pedido, crees un nuevo pedido en StateSingleton.shared.pedidoActual y muestres un mensaje al usuario indicando que \"su pedido est\u00e1 en camino\" o algo similar Si se pulsa a \"cancelar\" deber\u00edas borrar en Core Data el pedido actual. Si la regla de borrado en cascada est\u00e1 puesta correctamente, al borrar un pedido deber\u00edan borrarse autom\u00e1ticamente todas sus l\u00edneas.","title":"Realizar y cancelar pedido"},{"location":"miniproyecto/restaurante_parte_2/#tu-historial-pedidosviewcontroller-hasta-4-puntos","text":"En esta pantalla se deber\u00edan mostrar todos los pedidos realizados por el usuario actual. Est\u00e1 en blanco y puedes crear la interfaz del modo que desees. (1 punto) Si en el viewWillAppear muestras los datos de todos los pedidos en la consola con print , solo para ver que efectivamente se han almacenado correctamente (2 puntos) Si muestras en una tabla una l\u00ednea con el resumen de cada pedido (fecha, total y n\u00famero de platos pedidos) (4 puntos) Si muestras una pantalla con el listado de pedidos y otra con los detalles de cada uno","title":"Tu historial (PedidosViewController) (hasta 4 puntos)"},{"location":"miniproyecto/restaurante_parte_2/#apendice","text":"","title":"Ap\u00e9ndice:"}]}