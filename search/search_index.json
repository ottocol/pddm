{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Persistencia de datos en dispositivos iOS","text":"<p>En este bloque veremos las distintas formas de almacenar datos en una aplicaci\u00f3n iOS. Comenzaremos con el sistema de archivos, donde podemos almacenar informaci\u00f3n bien en un formato propio de nuestra app o bien en alg\u00fan formato est\u00e1ndar de Apple como las property lists. Veremos tambi\u00e9n las preferencias de usuario, que se usan para almacenar de manera transparente al desarrollador datos sencillos, como los t\u00edpicos que podemos necesitar para guardar la configuraci\u00f3n de la app.</p> <p>La mayor\u00eda de las sesiones del bloque se dedica a Core Data, que es la tecnolog\u00eda recomendada por Apple para almacenar grandes cantidades de datos con posibilidad de filtrar y hacer b\u00fasquedas. Core Data es una especie de ORM (Object Relational Mapper) que nos permite trabajar con clases Swift y por defecto almacena los datos en una base de datos SQL (aunque esto \u00faltimo es transparente al desarrollador). Esto nos permite tener el rendimiento de una base de datos manteniendo un nivel de abstracci\u00f3n m\u00e1s alto en nuestro c\u00f3digo.</p>"},{"location":"SUMMARY/","title":"Summary","text":"<ul> <li>Persistencia b\u00e1sica<ul> <li>El sistema de archivos</li> <li>Serializaci\u00f3n de clases</li> <li>Property Lists</li> <li>Preferencias de usuario</li> <li>Ejercicios</li> </ul> </li> <li>SQLite<ul> <li>Introducci\u00f3n a SQLite en iOS</li> <li>El API b\u00e1sico de SQLite</li> <li>Frameworks de terceros</li> <li>Ejercicios</li> </ul> </li> <li>\u00a1Hola Core Data!. Una aplicaci\u00f3n de ejemplo<ul> <li>Introducci\u00f3n a Core Data</li> <li>El stack de Core Data</li> <li>Las entidades</li> <li>Recuperar los datos</li> </ul> </li> <li>Modelos de datos en Core Data<ul> <li>Crear modelos</li> <li>Entidades con clases propias</li> <li>CRUD</li> <li>Ejercicios</li> </ul> </li> <li>M\u00e1s sobre modelos de datos<ul> <li>Tipos de datos transformables</li> <li>Validaciones</li> <li>El ciclo de vida de los objetos gestionados</li> <li>Deshacer y rehacer operaciones</li> <li>Ejercicios</li> </ul> </li> <li>B\u00fasquedas en Core Data<ul> <li>Predicados</li> <li>Ordenaci\u00f3n</li> <li>Ejercicios</li> </ul> </li> <li>Tablas en Core Data<ul> <li>El fetched results controller</li> <li>Inicializar el \"fetched results controller\"</li> <li>Mostrar los datos en la tabla</li> <li>Refrescar la tabla</li> <li>Secciones de tabla autom\u00e1ticas</li> <li>Ejercicios</li> </ul> </li> <li>Migraciones de datos<ul> <li>Qu\u00e9 son las migraciones de datos</li> <li>Versiones del modelo de datos</li> <li>Migraciones ligeras</li> <li>Migraciones pesadas</li> <li>Ejercicios</li> <li>Ap\u00e9ndice: migraciones en iOS&lt;=9</li> </ul> </li> <li>Contextos m\u00faltiples<ul> <li>M\u00faltiples contextos para trabajos en background</li> <li>Comunicaci\u00f3n entre contextos</li> <li>Contextos anidados</li> <li>Ejercicios</li> </ul> </li> <li>Persistencia como servicio<ul> <li>Backend as a Service</li> <li>Gesti\u00f3n de usuarios en Firebase</li> <li>Persistencia en Firebase</li> <li>Ejercicios </li> </ul> </li> <li>Arquitecturas de aplicaciones en iOS<ul> <li>Model/View/Controller</li> <li>Model/View/Presenter</li> <li>Model/View/ViewModel</li> <li>VIPER</li> <li>Ejercicios parte I</li> <li>Ejercicios parte II</li> <li>Ejercicios parte III</li> </ul> </li> </ul>"},{"location":"cap1/1.0_introduccion/","title":"Introducci\u00f3n","text":"<p>Ejercicios de la sesi\u00f3n</p> <p>Al final de algunos apartados de estos apuntes hay un \"mini-ejercicio\", todos juntos suman 1.5 puntos de la nota final del m\u00f3dulo. Cuando una secci\u00f3n tiene ejercicio al final, lo pone tambi\u00e9n al principio con una nota igual a \u00e9sta.</p> <p>En esta primera sesi\u00f3n veremos qu\u00e9 APIs podemos usar si no necesitamos almacenar gran cantidad de datos o son datos no estructurados en los que no necesitamos hacer b\u00fasquedas. Casos de uso t\u00edpicos ser\u00edan guardar la configuraci\u00f3n de la app o almacenar documentos (por ejemplo en una app de procesamiento de textos).</p> <p>Si solo necesitamos guardar unos cuantos datos podemos usar las property lists, un formato propio de Apple que nos permite almacenar de forma sencilla los tipos de datos m\u00e1s habituales: Datos num\u00e9ricos, <code>String</code>s, fechas,.... Como contrapartida, no podemos hacer b\u00fasquedas y tenemos que leer/guardar todos los datos en bloque, por lo que no es un formato muy eficiente.</p> <p>El API de preferencias de usuario nos ofrece una capa de abstracci\u00f3n por encima de las property list, permiti\u00e9ndonos almacenar o recuperar datos de manera muy simple como pares clave-valor. No obstante, internamente se siguen guardando los datos en property lists, con lo que tenemos los mismos problemas de ineficiencia e imposibilidad de hacer b\u00fasquedas.</p> <p>Finalmente si en nuestra app necesitamos guardar datos en un formato propio y no nos hacen falta funcionalidades de base de datos podemos usar simplemente ficheros. Veremos c\u00f3mo est\u00e1 organizado el sistema de archivos de iOS y en qu\u00e9 directorios se pueden almacenar datos. Tambi\u00e9n veremos operaciones b\u00e1sicas con directorios y archivos. Esto lo veremos como primer apartado de los apuntes ya que tanto las property list como las preferencias f\u00edsicamente se guardan en archivos dentro de un determinado directorio.</p>"},{"location":"cap1/1.1_sistema_de_archivos/","title":"Sistema de archivos","text":"<p>Ejercicio</p> <p>Al final de esta secci\u00f3n hay un \"mini-ejercicio\" puntuado con 0.25 puntos del total de 1.5 puntos de todos los ejercicios de hoy.</p>"},{"location":"cap1/1.1_sistema_de_archivos/#introduccion","title":"Introducci\u00f3n","text":"<p>En iOS el sistema de archivos del dispositivo no es visible al completo para una aplicaci\u00f3n cualquiera por motivos de seguridad. iOS en realidad es un sistema UNIX por lo que el disco tiene la t\u00edpica estructura de directorios de estos sistemas. No obstante, cada aplicaci\u00f3n est\u00e1 contenida en lo que se denomina un sandbox, es decir un conjunto de directorios del que \"no puede salirse\" y fuera del que no puede acceder a ninguna informaci\u00f3n del disco. A la inversa otras aplicaciones tampoco pueden acceder al sandbox de nuestra aplicaci\u00f3n.</p> <p>El sandbox tiene una estructura de directorios estandarizada, donde cada directorio tiene un papel espec\u00edfico reservado en la aplicaci\u00f3n. Nuestra aplicaci\u00f3n puede crear y modificar libremente archivos y directorios, aunque siempre deber\u00eda respetar el papel que el sistema le asigna a cada directorio.</p> <p>Primero veremos cu\u00e1l es la estructura \u201cest\u00e1ndar\u201d del sandbox y luego el API para abrir, crear y modificar archivos y directorios.</p>"},{"location":"cap1/1.1_sistema_de_archivos/#el-sistema-de-archivos-de-cada-aplicacion","title":"El sistema de archivos de cada aplicaci\u00f3n","text":"<p>Cuando se instala una aplicaci\u00f3n en un dispositivo iOS el sistema crea una estructura de directorios como la que aparece en la siguiente figura.</p> <p></p> <p>Los directorios m\u00e1s importantes son los siguientes:</p> <ul> <li>nombre_de_la_aplicacion<code>.app/</code>: aunque por la extensi\u00f3n podr\u00eda parecer que es un archivo se trata de un directorio, que contiene lo que se denomina el bundle de la aplicaci\u00f3n: el ejecutable, los iconos, im\u00e1genes, sonidos, etc.</li> <li><code>Documents/</code>: es el directorio reservado para el contenido creado por el usuario. Si por ejemplo nuestra aplicaci\u00f3n es un editor de textos, aqu\u00ed es donde deber\u00edamos almacenarlos.</li> <li><code>Library/</code>: no suele contener directamente archivos sino solamente dos subdirectorios:<ul> <li><code>Caches/</code>: donde almacenamos los datos que se pueden volver a recrear sin problemas si es necesario. Por ejemplo \u00edndices de datos de nuestra aplicaci\u00f3n que sirvan para hacer las b\u00fasquedas m\u00e1s r\u00e1pidas. Por ello iOS no hace copia de seguridad de este directorio cuando hacemos un backup del dispositivo.</li> <li><code>Preferences/</code>: las preferencias de configuraci\u00f3n de la aplicaci\u00f3n, que posteriormente veremos con m\u00e1s detalle.</li> <li><code>Application Support/</code>: contenido generado por la aplicaci\u00f3n pero que no ha sido creado directamente por el usuario.</li> </ul> </li> <li><code>tmp/</code>: como puede deducirse est\u00e1 indicado para archivos y directorios temporales, de los que iOS tampoco har\u00e1 copia de seguridad.</li> </ul>"},{"location":"cap1/1.1_sistema_de_archivos/#paths-y-urls","title":"Paths y URLs","text":"<p>Antes de poder realizar cualquier operaci\u00f3n sobre un archivo o directorio, tenemos primero que localizarlo en el sistema de archivos, es decir, encontrar su path absoluto - desde la ra\u00edz del sistema de archivos. Aunque en iOS no podemos \u201csalirnos fuera\u201d del sandbox este paso sigue siendo necesario. </p> <p>En iOS podemos dar cualquier trayectoria de un archivo de dos formas distintas: como path local (un <code>String</code>) o  como URLs, que uniformizan el tratamiento de las rutas y nos permite tambi\u00e9n especificar la localizaci\u00f3n de recursos remotos. Los nombres de los m\u00e9todos en ambos casos suelen ser iguales, salvo que los que trabajan con paths generalmente acaban en <code>Path</code> y los que trabajan con URLs en <code>URL</code>.</p> <p>Apple recomienda usar URLs en lugar de paths, ya que uniformizan el tratamiento de los recursos, sean locales o no.</p> <p>La clase b\u00e1sica que se usa para interactuar con el sistema de archivos es el <code>FileManager</code>. No es necesario crear una instancia, podemos obtener la instancia por defecto con <code>FileManager.default</code></p>"},{"location":"cap1/1.1_sistema_de_archivos/#el-bundle-de-la-aplicacion","title":"El bundle de la aplicaci\u00f3n","text":"<p>Acceder al directorio con el bundle de la aplicaci\u00f3n (el <code>.app</code>) es sencillo:</p> <pre><code>let bundleURL = Bundle.main.bundleURL\n</code></pre> <p>Ya hemos visto antes este tipo de c\u00f3digo cuando acced\u00edamos a im\u00e1genes y otros archivos distribuidos junto a la aplicaci\u00f3n.</p> <p>Con <code>bundlePath</code> en lugar de <code>bundleURL</code> podemos obtener tambi\u00e9n el path en forma local (sin el <code>file://</code> delante).</p>"},{"location":"cap1/1.1_sistema_de_archivos/#los-directorios-tipicos","title":"Los directorios \u201ct\u00edpicos\u201d","text":"<p>Para obtener la URL de un directorio del sandbox se usa el m\u00e9todo <code>urls(for:in:)</code>, de la clase <code>FileManager</code>. Al m\u00e9todo le pasamos un par de constantes:</p> <ul> <li>La clase de directorio que estamos buscando, como un valor enumerado del tipo <code>FileManager.SearchPathDirectory</code> (por ejemplo para <code>Library/</code> el valor es <code>libraryDirectory</code>, para <code>Documents</code> es <code>documentDirectory</code> y para <code>Cache</code>, <code>cachesDirectory</code>). Se puede consultar la lista completa, aunque la mayor\u00eda de valores solo tienen sentido en OSX.</li> <li>El \"dominio\" o \u00e1mbito de la b\u00fasqueda, un valor enumerado del tipo <code>FileManager.SearchPathDomainMask</code>. En iOS siempre usaremos el valor <code>userDomainMask</code>, que en OSX indica el directorio del usuario, pero en iOS en realidad se refiere al \u00e1mbito de la aplicaci\u00f3n actual. </li> </ul> <p>Por ejemplo, as\u00ed obtendr\u00edamos la URL del directorio <code>Documents</code> de la aplicaci\u00f3n actual:</p> <pre><code>let urls = FileManager.default.urls(for:.documentDirectory, in:.userDomainMask)\n//N\u00f3tese que el m\u00e9todo devuelve un array de URLs\n//Casi siempre nos interesa solo la primera\nif(urls.count&gt;0) {\n    let docDir = urls[0]\n    print(\"El directorio 'Documents' es \\(docDir)\")\n}\nelse {\n    print(\"error al buscar el directorio 'Documents'\")\n}\n</code></pre> <p>Si ejecutamos el c\u00f3digo anterior en un dispositivo real nos aparecer\u00e1 una URL del estilo <code>file:///var/mobile/Containers/Data/Application/id_de_la_aplicacion/Documents</code>.</p> <p>En el simulador la URL ser\u00e1 similar pero la primera parte de la trayectoria cambia ya que se refiere a donde se est\u00e1 ejecutando la app dentro del simulador, algo como <code>file:///Users/[nombre_usuario]/Library/Developer/CoreSimulator/Devices/[id_del_dispositivo]/data/Containers/Data/Application/[id_de_la_aplicacion]/Documents/</code>. Para complicar un poco m\u00e1s el asunto, el identificador de la app cambiar\u00e1 cada vez que pongamos en marcha el simulador.</p> <p>En el simulador, el sistema de carpetas y archivos de cada app se guardan en un directorio un poco \"perdido\" en el disco y dif\u00edcil de localizar manualmente. Hay aplicaciones que nos permiten encontrarlo m\u00e1s f\u00e1cilmente para as\u00ed poder depurar la app viendo su sandbox. Una de estas aplicaciones, de libre distribuci\u00f3n es SimSim. Recomendamos su uso para poder depurar las aplicaciones viendo c\u00f3mo se crean los datos. En el ejercicio al final de la secci\u00f3n se describe brevemente su uso.</p>"},{"location":"cap1/1.1_sistema_de_archivos/#el-directorio-temporal","title":"El directorio temporal","text":"<p>Podemos obtener el path del directorio para archivos temporales con la propiedad <code>temporaryDirectory</code> del file manager</p> <pre><code>let tmpDir = FileManager.default.temporaryDirectory\nprint(\"Dir. archivos temporales: \\(tmpDir)\")\n</code></pre>"},{"location":"cap1/1.1_sistema_de_archivos/#operaciones-con-archivos-y-directorios","title":"Operaciones con archivos y directorios","text":""},{"location":"cap1/1.1_sistema_de_archivos/#listar-el-contenido-de-un-directorio","title":"Listar el contenido de un directorio","text":"<p>Sabiendo la URL de un determinado directorio podemos listar sus contenidos con el m\u00e9todo <code>contentsOfDirectory(at:includingPropertiesForKeys:options:)</code></p> <p>El siguiente ejemplo toma el directorio donde est\u00e1 el bundle de la aplicaci\u00f3n y lista sus contenidos, mostrando para cada elemento la fecha de creaci\u00f3n y si es o no un directorio. </p> <pre><code>let urlBundle = Bundle.main.bundleURL\nlet contenidos = try! FileManager.default.contentsOfDirectory(at: urlBundle, \n              includingPropertiesForKeys: [.creationDateKey, .isDirectoryKey], \n              options: .skipsHiddenFiles)\nprint(\"Hay \\(contenidos.count) elementos\")\nfor url in contenidos {\n    print(url.lastPathComponent, terminator:\"\")\n    let rv = try! url.resourceValues(forKeys: [.creationDateKey, .isDirectoryKey])\n    print(\" \\(rv.creationDate!)\", terminator:\"\")\n    if rv.isDirectory! {\n        print(\" (DIR)\")\n    }\n    else  {\n       print(\"\")\n    }\n}\n</code></pre> <ul> <li>El par\u00e1metro <code>includingPropertiesForKeys</code> es un array de constantes de la clase <code>URLResourceKey</code> donde especificamos la \"meta-informaci\u00f3n\" a obtener para cada item (por ejemplo tama\u00f1o, fecha de creaci\u00f3n, si es o no un directorio, etc).</li> <li><code>options</code> puede ser 0 o bien <code>.skipsHiddenFiles</code>para indicar que no queremos obtener los archivos o directorios ocultos.</li> </ul> <p>Una vez obtenemos los items con <code>contentsOfDirectory</code>, mostramos sus datos, incluyendo la informaci\u00f3n obtenida. La \"meta-informaci\u00f3n\" sobre el archivo/directorio se obtiene con el m\u00e9todo de la clase <code>URL</code> llamado <code>resourceValues</code>. Este nos devuelve un objeto <code>URLResourceValues</code> con propiedades que se corresponden con los datos de la \"meta-informaci\u00f3n\"</p> <p>Una versi\u00f3n simplificada del listado de directorios nos la da el m\u00e9todo <code>contentsOfDirectory(atPath:)</code> que trabaja a partir de un path en forma de <code>String</code> y no permite obtener propiedades de los items, solo nos devuelve array de <code>String</code> con los nombres.</p> <pre><code>let pathBundle = Bundle.main.bundlePath\nlet contenidos = try! FileManager.default.contentsOfDirectory(atPath: pathBundle)\nfor nombre in contenidos {\n    print(nombre)\n}\n</code></pre>"},{"location":"cap1/1.1_sistema_de_archivos/#operaciones-con-archivos-y-directorios-copiar-mover-borrar","title":"Operaciones con archivos y directorios: copiar, mover, borrar","text":"<p>B\u00e1sicamente tenemos disponibles estas operaciones a trav\u00e9s de m\u00e9todos del <code>FileManager</code>. Como venimos diciendo, por defecto se recomienda usar URLs. Si usamos paths en su lugar, genralmente el m\u00e9todo se llamar\u00e1 igual pero el nombre de los par\u00e1metros ser\u00e1 lo acabado en Path. En general tambi\u00e9n se puede operar indistintamente sobre archivos o directorios. As\u00ed por ejemplo podemos:</p> <ul> <li>copiar un item (archivo o directorio) en otro con <code>copyItem(at:to:)</code> o <code>copyItem(atPath:toPath:)</code></li> <li>mover un item con <code>moveItem(at:to:)</code> o <code>moveItem(atPath:toPath:)</code></li> <li>eliminar un item con <code>removeItem(at:)</code></li> </ul> <p>Se recomienda consultar la documentaci\u00f3n del API de FileManager para m\u00e1s detalles sobre estas y otras operaciones.</p>"},{"location":"cap1/1.1_sistema_de_archivos/#ejercicio-de-la-seccion-025-puntos","title":"Ejercicio de la secci\u00f3n (0.25 puntos)","text":"<p>El objetivo del ejercicio es simplemente \"echarle un vistazo\" al sandbox de una aplicaci\u00f3n. Como hemos dicho, en el simulador el sandbox de una app se guarda en un subdirectorio \"un poco perdido\" dentro del disco del Mac. Para comprobar en fase de desarrollo si la app est\u00e1 guardando bien los datos necesitamos tener acceso a este sandbox. La herramienta SimSim nos permite accceder a \u00e9l de forma sencilla.</p> <ol> <li>B\u00e1jate el .zip con la app SimSim, descompr\u00edmelo y arr\u00e1stralo a la carpeta de <code>Aplicaciones</code> del Mac</li> <li>Ejecuta la aplicaci\u00f3n SimSim. En la barra superior del Mac aparecer\u00e1 un icono con esta forma . Si lo pulsas ver\u00e1s una lista con las apps m\u00f3viles que hayas simulado recientemente. Si eliges una de ellas ver\u00e1s un submen\u00fa con varias opciones, entre ellas:<ul> <li><code>Finder</code> abre una ventana del administrador de archivos en el sandbox de la app simulada</li> <li><code>Terminal</code> hace lo mismo pero con una terminal </li> </ul> </li> <li>Abre una ventana del Finder en alguna app simulada de las que aparezcan en el men\u00fa de SimSim (no importa cu\u00e1l). Comprueba que la estructura de directorios se corresponde con la del sandbox t\u00edpico de una app iOS. Haz un volcado de pantalla de la ventana del Finder e incl\u00fayelo en la entrega de ejercicios como parter de la respuesta a este ejercicio.</li> <li>Crea un nuevo proyecto de Xcode, llamado PruebaArchivos, en el m\u00e9todo <code>viewDidLoad</code> de la clase <code>ViewController</code> a\u00f1ade este c\u00f3digo, que escribe un mensaje de texto dentro de un fichero \"prueba.txt\" en el <code>Documents</code> del sandbox <pre><code>let file = \"prueba.txt\"  //nombre del archivo\nlet text = \"hola iOS\"    //texto que escribiremos en \u00e9l\n\n//obtenemos la URL del directorio Documents\nif let dir = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first {\n    //le a\u00f1adimos detr\u00e1s el \"/prueba.txt\"\n    let fileURL = dir.appendingPathComponent(file)\n    //guardamos el String en el archivo\n    try! text.write(to: fileURL, atomically: false, encoding: .utf8)\n}\n</code></pre></li> <li>Ejecuta la app pruebaArchivos y con la aplicaci\u00f3n SimSim comprueba visualmente que el archivo \"prueba.txt\" se ha creado correctamente, \u00e1brelo haciendo doble clic y comprueba su contenido. Haz un volcado de pantalla de la ventana del Finder donde se vea que el archivo existe, e incl\u00fayelo en la entrega de ejercicios como parte de la respuesta a este ejercicio.</li> </ol>"},{"location":"cap1/1.2_serializacion/","title":"Serializaci\u00f3n","text":""},{"location":"cap1/1.2_serializacion/#serializacioncodificacion-de-datos","title":"Serializaci\u00f3n/Codificaci\u00f3n de datos","text":"<p>Desde la versi\u00f3n 4 de Swift la serializaci\u00f3n de datos en iOS se ha uniformizado en lo que se denomina encoding/decoding. El encoding es el proceso que nos permite pasar de una estructura de datos en memoria a otro formato m\u00e1s adecuado para archivar o transmitir la informaci\u00f3n, por ejemplo JSON, XML,... El decoding es el proceso inverso. </p>"},{"location":"cap1/1.2_serializacion/#el-protocolo-codable","title":"El protocolo <code>Codable</code>","text":"<p>Para que un objeto sea \"codificable/decodificable\" debe implementar este protocolo. En la mayor\u00eda de casos no ser\u00e1 necesario escribir nada de c\u00f3digo, siempre que nuestra clase/struct est\u00e9 compuesta por campos que sean conformes con <code>Codable</code>. Muchos tipos b\u00e1sicos de Swift lo son, como los <code>String</code>, <code>Int</code>, <code>Float</code>, <code>Date</code>, <code>Array</code>...</p> <p>En realidad <code>Codable</code> no es m\u00e1s que una combinaci\u00f3n de los protocolos, <code>Encodable</code> (para codificar) y <code>Decodable</code> (para decodificar):</p> <p>Como ejemplo, supongamos que tenemos una estructura <code>Alumno</code> que representa un alumno de un determinado curso o asignatura. Su definici\u00f3n podr\u00eda ser algo como:</p> <pre><code>struct Alumno  {\n    var nombre : String\n    var nota: Float\n    var fechaNacimiento: Date\n}\n</code></pre> <p>Como los campos de la clase son conformes a <code>Codable</code> para que la propia clase lo sea nos basta con declararla como tal:</p> <pre><code>struct Alumno : Codable {\n    //..el resto es exactamente igual\n}\n</code></pre> <p>Ahora solo necesitamos un \"encoder\", una clase capaz de transformar algo <code>Codable</code> en un formato determinado. En los APIs de iOS tenemos encoders para transformar a/desde formatos como JSON o XML. En la siguiente secci\u00f3n veremos un ejemplo.</p>"},{"location":"cap1/1.2_serializacion/#almacenar-codable-en-archivos","title":"Almacenar <code>Codable</code> en archivos","text":"<p>Una posibilidad es transformar nuestros datos <code>Codable</code> en JSON, XML o un formato para el que tengamos un encoder y luego almacenar el formato resultante en un archivo. </p> <p>Veamos un ejemplo con JSON:</p> <pre><code>//Esto se usa solo para poder generar fechas a partir de cadenas,\n//no est\u00e1 relacionado directamente con la serializaci\u00f3n\nlet df = DateFormatter() \ndf.dateFormat = \"dd-MM-yyyy\"\n//Definir un alumo cuyos datos guardaremos\nlet alumno = Alumno(nombre: \"Pepe\", nota: 10.0, fechaNacimiento: df.date(from: \"10/10/2000\")!)\n\n//Convertir el alumno a JSON\nlet encoder = JSONEncoder()\nlet datos = try! encoder.encode(alumno)\n\n//Almacenarlo en un archivo llamado \"result.json\" en la carpeta Documents\nvar urlDocs = FileManager.default.urls(for:.documentDirectory,\n                                       in:.userDomainMask)[0]\nlet urlFichero = urlDocs.appendingPathComponent(\"result.json\")\ntry! datos.write(to: urlFichero)\n</code></pre> <p>En JSON hay algunos tipos de datos, como las fechas, que no est\u00e1n estandarizados. El <code>JSONEncoder</code> soporta varios formatos, que podemos seleccionar a trav\u00e9s de la propiedad <code>dateEncodingStrategy</code>. Por ejemplo para guardar las fechas en formato ISO8601:</p> <pre><code>encoder.dateEncodingStrategy = .iso8601\n</code></pre> <p>Para leer los datos del archivo usar\u00edamos un <code>JSONDecoder</code></p> <pre><code>let datosLeidos = try Data(contentsOf: urlFichero)\nlet decoder = JSONDecoder()\nlet alumnoLeido = try decoder.decode(Jugador.self, from: datosLeidos)\n</code></pre> <p>Si al almacenar los datos hubi\u00e9ramos cambiado el formato de fecha, tendr\u00edamos que cambiarlo en la propiedad <code>dateDecodingStrategy</code> del decoder. </p> <p>Otra opci\u00f3n en lugar de usar JSON o XML es usar las clases <code>NSKeyedArchiver</code> y <code>NSKeyedUnarchiver</code> que sirven para \"archivar\" y \"desarchivar\" <code>Codable</code>s, respectivamente. </p> <p>Para codificar los datos usamos el m\u00e9todo <code>encodeEncodable</code> de <code>NSKeyedArchiver</code></p> <pre><code>//Alumno que luego guardaremos\nlet df = DateFormatter()\ndf.dateFormat = \"dd-MM-yyyy\"\nlet alumno1 = Alumno(nombre: \"Pepe\", nota: 10.0, fechaNacimiento: df.date(from: \"10/10/2000\")!)\n//El archivo se llamar\u00e1 \"datos.dat\" dentro del directorio de documentos de la app\nlet urlDocs = FileManager.default.urls(for:.documentDirectory,  \n                                       in:.userDomainMask)[0]\nlet urlArchivo = urlDocs.appendingPathComponent(\"datos.dat\")\nlet archiver = NSKeyedArchiver()\ndo {\n   //codificamos  \n   try archiver.encodeEncodable(alumno1, forKey: NSKeyedArchiveRootObjectKey)\n   //los datos codificados est\u00e1n en \"encodedData\". Los guardamos en el archivo\n   try archiver.encodedData.write(to: urlArchivo)\n} catch {\n    print(error)\n}\n</code></pre> <p>Para el paso contrario (decoding) usamos el m\u00e9todo <code>decodeTopLevelDecodable</code> de <code>NSKeyedUnarchiver</code>:</p> <pre><code>//aqu\u00ed \"urlArchivo\" tiene el mismo valor que en el ejemplo anterior\nlet datos = try Data(contentsOf: urlArchivo)\nlet unarchiver = NSKeyedUnarchiver(forReadingWith: datos)\nif let alumnoLeido = try unarchiver.decodeTopLevelDecodable(Alumno.self, \n                                      forKey: NSKeyedArchiveRootObjectKey) {\n   print(alumnoLeido.nombre) //Pepe\n}\n</code></pre> <p>En realidad estas clases existen desde antes de la introducci\u00f3n de <code>Codable</code>. Se usaban para guardar datos mediante el mecanismo que exist\u00eda anteriormente en iOS, denominado <code>NSCoding</code>, y se extendieron para poder trabajar tambi\u00e9n con <code>Codable</code>.</p>"},{"location":"cap1/1.2_serializacion/#configurar-codable","title":"Configurar Codable","text":"<p>En algunas ocasiones nos puede interesar serializar/deserializar los datos usando nombres de campos distintos a los que usamos en nuestras estructuras de datos. Por ejemplo en muchas ocasiones nos tendremos que comunicar con servicios REST cuyo JSON use nombres que nos pueden resultar extra\u00f1os en nuestro c\u00f3digo, o que no se adaptan a las convenciones de Swift.</p> <p>La asociaci\u00f3n entre los nombres de los campos en el formato serializado y en nuestro c\u00f3digo se puede definir en una enumeraci\u00f3n de <code>String</code>s llamada <code>CodingKeys</code> que debe ser conforme al protocolo <code>CodingKey</code>. </p> <p>Supongamos que en el ejemplo del <code>struct Alumno</code> queremos que en nuestra estructura de datos la fecha se siga llamando <code>fechaNacimiento</code> pero en el formato serializado sea <code>fecha_nacimiento</code>. Lo har\u00edamos del siguiente modo:</p> <pre><code>struct Alumno  {\n    var nombre : String\n    var nota: Float\n    var fechaNacimiento: Date\n    private enum CodingKeys : String, CodingKey {\n        case nombre\n        case nota\n        case fechaNacimiento = \"fecha_nacimiento\"\n    }\n}\n</code></pre>"},{"location":"cap1/1.3_property_lists/","title":"Property lists","text":"<p>Ejercicio</p> <p>Al final de esta secci\u00f3n hay un ejercicio puntuado con 0.5 puntos del total de 1.5 puntos de todos los ejercicios de hoy.</p> <p>Las property list son estructuras de datos tipo pares de clave-valor ampliamente utilizadas en iOS para almacenar datos de configuraci\u00f3n. </p> <p>Las property list tienen dos limitaciones pr\u00e1cticas fundamentales:</p> <ul> <li>No se puede almacenar cualquier tipo de datos, solo algunos: <code>String</code>, valores num\u00e9ricos, <code>Data</code>, <code>Date</code> o <code>Boolean</code>. Y como colecciones de datos <code>Array</code> y <code>Dictionary</code>.</li> <li>No son modificables, es decir, no tenemos un API para cambiar un \u00fanico dato en el archivo. Hay que serializar de nuevo toda la estructura y generar el archivo partiendo de cero. Por ello no son adecuadas para almacenar grandes cantidades de datos.</li> </ul>"},{"location":"cap1/1.3_property_lists/#el-formato-de-las-property-lists","title":"El formato de las property lists","text":"<p>Las property lists se pueden almacenar en archivos en modo texto o binario. En los ejemplos usaremos sobre todo el modo texto. En este modo se usa el formato XML, aqu\u00ed tenemos un ejemplo:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;\n&lt;plist version=\"1.0\"&gt;\n&lt;dict&gt;\n    &lt;key&gt;colorFondo&lt;/key&gt;\n    &lt;array&gt;\n        &lt;integer&gt;255&lt;/integer&gt;\n        &lt;integer&gt;255&lt;/integer&gt;\n        &lt;integer&gt;0&lt;/integer&gt;\n    &lt;/array&gt;\n    &lt;key&gt;fuente&lt;/key&gt;\n    &lt;string&gt;System&lt;/string&gt;\n&lt;/dict&gt;\n&lt;/plist&gt;\n</code></pre> <p>La ra\u00edz de la estructura de datos puede ser un diccionario, como en nuestro caso, o un array.</p> <p>Xcode incluye un editor de property lists con el que podemos editar los datos de forma \"asistida\" sin tener que tocar directamente el XML. Creamos una nueva lista con <code>File &gt; New</code> y entre las plantillas elegimos evidentemente <code>Property list</code>. La extensi\u00f3n t\u00edpica para estos archivos es <code>.plist</code>. Lo primero que hacemos es elegir qu\u00e9 va a ser la ra\u00edz (array o diccionario) y luego vamos creando \"nodos\". Para cada uno tecleamos un nombre, elegimos el tipo y tecleamos el valor.</p> <p></p> <p>En el caso de los arrays a\u00f1adimos valores \"desplegando\" el nodo (con la flechita que aparece a la izquierda, y pulsando sobre el bot\u00f3n del <code>+</code>)</p> <p></p> <p>Podemos tambi\u00e9n editar el XML en modo texto pulsando con bot\u00f3n derecho sobre el archivo y eligiendo en el men\u00fa contextual \"Open as &gt; Source Code\"</p>"},{"location":"cap1/1.3_property_lists/#leer-una-property-list","title":"Leer una property list","text":"<p>Leer una property list de un archivo es muy sencillo usando el encoding/decoding de Swift. En el framework Foundation se define un <code>PropertyListDecoder</code> que sirve para deserializar estos archivos.</p> <p>Por ejemplo supongamos una <code>plist</code> cuya ra\u00edz es un diccionario y con dos propiedades, <code>nombre</code> de tipo <code>String</code> y <code>puntuacion</code> de tipo entero. Una vez deserializados, podemos almacenar los datos en un <code>struct</code> de Swift como este</p> <pre><code>struct Props : Codable {\n    var nombre : String\n    var puntuacion : Int\n}\n</code></pre> <p>Cuando se crea una <code>plist</code> con Xcode se a\u00f1ade al bundle de la aplicaci\u00f3n. Suponiendo que est\u00e1 en dicho bundle podr\u00edamos leerla con el siguiente c\u00f3digo, que como se ve es muy sencillo gracias a <code>Codable</code>:</p> <pre><code>if let plistURL = Bundle.main.url(forResource:\"mi_plist\", \n                                  withExtension:\"plist\") {\n   let data = try Data(contentsOf: plistURL)\n   let decoder = PropertyListDecoder()\n   let misProps = try decoder.decode(Props.self, from: data)\n   print(misProps)\n}\n</code></pre> <p>En versiones anteriores de Swift la forma de leer/guardar property list era distinta, algo m\u00e1s engorrosa (aunque tampoco excesivamente complicada). Pod\u00e9is consultar un ejemplo comparando el m\u00e9todo antiguo y el nuevo en este blog.</p>"},{"location":"cap1/1.3_property_lists/#guardar-una-property-list","title":"Guardar una property list","text":"<p>Veamos c\u00f3mo har\u00edamos el paso inverso: almacenar en un archivo una estructura de datos compatible con una property list. </p> <p>Recordemos que el bundle de la aplicaci\u00f3n es solo de lectura, por lo que un .plist almacenado en esta localizaci\u00f3n no ser\u00e1 modificable. Si necesit\u00e1ramos modificar el .plist del bundle la estrategia habitual es que cuando arranque la aplicaci\u00f3n se realice una copia en otro directorio con permisos de escritura, t\u00edpicamente <code>Documents</code>, y que a partir de entonces se trabaje con esa copia.</p> <p>Suponiendo que tenemos definido el mismo <code>struct Props</code> del ejemplo anterior, har\u00edamos uso de un <code>PropertyListEncoder</code> como sigue:</p> <pre><code>var urlDocs = FileManager.default.urls(for:.documentDirectory,\n                                       in:.userDomainMask)[0]\nlet urlPlist = urlDocs.appendingPathComponent(\"result.plist\")\nlet encoder = PropertyListEncoder()\nencoder.outputFormat = .xml\nlet misProps = Props(nombre:\"John\", puntuacion:100)\nlet data = try encoder.encode(misProps)\ntry data.write(to: urlPlist)\n</code></pre>"},{"location":"cap1/1.3_property_lists/#ejercicio-de-la-seccion-05-puntos","title":"Ejercicio de la secci\u00f3n (0.5 puntos)","text":"<p>Tomando como base los ejemplos de c\u00f3digo de la secci\u00f3n, define una estructura de datos propia y gu\u00e1rdala en un fichero .plist. Luego con la aplicaci\u00f3n SimSim comprueba que se ha guardado correctamente. Paso a paso:</p> <ol> <li>Crea un <code>struct</code> Swift llamado <code>Alumno</code> que sea conforme al protocolo <code>Codable</code> y que tenga dos campos:    - un String llamado <code>nombre</code>    - un array de <code>Float</code> con las <code>notas</code></li> <li>Crea dos alumnos y a\u00f1\u00e1delos a un array <pre><code>let a1 = Alumno(nombre: \"Pepe\", notas: [5, 8.5, 10])\nlet a2 = Alumno(nombre: \"Eva\", notas: [10, 9])\nlet alumnos = [a1,a2]\n</code></pre></li> <li>Bas\u00e1ndote en el \u00faltimo ejemplo de c\u00f3digo de esta secci\u00f3n, haz que se guarde el array <code>alumnos</code> en un fichero de tipo <code>.plist</code> llamado <code>alumnos.plist</code>. Puedes incluir el c\u00f3digo en el <code>viewDidLoad</code> del <code>ViewController</code> para que se ejecute al cargar el controller de la app.</li> <li>Comprueba mediante la aplicaci\u00f3n SimSim que se ha creado el archivo dentro del <code>Documents</code> del sandbox de la app. Abre el archivo con alg\u00fan editor de texto y comprueba su contenido. Incluye el archivo en las respuestas de los ejercicios.</li> </ol>"},{"location":"cap1/1.4_preferencias/","title":"Preferencias","text":"<p>Ejercicio</p> <p>Al final de esta secci\u00f3n hay un ejercicio puntuado con 0.75 puntos del total de 1.5 puntos de todos los ejercicios de hoy.</p>"},{"location":"cap1/1.4_preferencias/#preferencias-de-usuario","title":"Preferencias de usuario","text":"<p>En la mayor\u00eda de las aplicaciones podemos configurar una serie de par\u00e1metros que las adaptan a las preferencias o necesidades del usuario. Son elementos tales como colores, tipos de fuentes, unidades de medida, nombres de usuarios y contrase\u00f1as de servicios de terceros, etc.</p> <p>iOS nos ofrece un mecanismo est\u00e1ndar para almacenar estas preferencias de modo permanente. El API es bastante sencillo y nos permite establecer unos valores por defecto, modificarlos seg\u00fan lo que indique el usuario y leer los valores previamente fijados. </p> <p>Hay que destacar que iOS solo nos da el API para leer/almacenar las preferencias, pero no el interfaz de usuario para mostrarlas/modificarlas, que es nuestra responsabilidad. Hay una excepci\u00f3n: si queremos que nuestras preferencias aparezcan dentro de las del sistema, el propio iOS se encargar\u00e1 de la interfaz.</p>"},{"location":"cap1/1.4_preferencias/#que-se-puede-guardar-en-las-preferencias","title":"Qu\u00e9 se puede guardar en las preferencias","text":"<p>Desde el punto de vista del tipo de datos, las preferencias de usuario no son m\u00e1s que una property list en la que el objeto \u201cra\u00edz\u201d es un <code>NSDictionary</code>. El sistema se encarga de serializar/deserializar los valores a/desde un archivo <code>.plist</code> de modo autom\u00e1tico.</p> <p>Si usamos este API nos ahorraremos tener que gestionar manualmente el <code>.plist</code> como hac\u00edamos en la secci\u00f3n anterior. No tenemos que crearlo nosotros, comprobar si existe, guardarlo cuando toque o recuperar los datos cuando hagan falta, iOS lo har\u00e1 por nosotros.</p> <p>El fichero <code>.plist</code>con las preferencias se almacena autom\u00e1ticamente en el directorio <code>Library/Preferences</code> de la aplicaci\u00f3n. Su nombre ser\u00e1 el del proyecto de Xcode, precedido del \"organization identifier\" del proyecto. </p> <p>Por defecto el <code>.plist</code> se genera en formato binario. Aunque no est\u00e9 en modo texto podemos igualmente abrirlo y editarlo con el editor de .plist de Xcode. Tambi\u00e9n podemos convertirlo a XML con una herramienta en l\u00ednea de comandos llamada <code>plutil</code>, instalada por defecto junto con Xcode:</p> <pre><code>plutil -convert xml1 -o resultado_xml.plist fichero_original.plist\n</code></pre>"},{"location":"cap1/1.4_preferencias/#acceder-a-las-preferencias","title":"Acceder a las preferencias","text":"<p>Las preferencias del usuario actual son accesibles a trav\u00e9s del singleton de la clase <code>UserDefaults</code>. Para acceder a la \u00fanica instancia, usar el inicializador del mismo nombre</p> <pre><code>let preferencias = UserDefaults()\n</code></pre> <p>Como las aplicaciones iOS est\u00e1n en un sandbox cada una solo tiene acceso a sus propias preferencias. El propio sistema no puede cambiar las preferencas de nuestra aplicaci\u00f3n, salvo las que coloquemos dentro de las \u201cgenerales\u201d, como veremos en el punto siguiente</p> <p>Dentro del almac\u00e9n de preferencias cada una de ellas tiene una clave, que ser\u00e1 una cadena, y un valor. As\u00ed, podemos acceder a una preferencia con una familia de m\u00e9todos <code>xxx(forKey:)</code>, donde la \"xxx\" var\u00eda seg\u00fan el tipo de datos: <code>integer</code>, <code>bool</code>, <code>float</code>, <code>double</code>, <code>array</code>, <code>object</code>,\u2026</p> <p>Por ejemplo, supongamos un juego en el que tuvi\u00e9ramos almacenado el nick del usuario y el nivel alcanzado. Podr\u00edamos obtener los valores con:</p> <pre><code>let nick = preferencias.string(forKey:\"nick\");\nlet nivel = preferencias.integer(forKey: \"nivel\")\n</code></pre> <p>Al leer los valores de las preferencias se plantea un problema: c\u00f3mo saber si ya tenemos un valor almacenado en las preferencias o no. En ciertos tipos de datos esto es sencillo: en un <code>String</code> como la preferencia nick, de no haber ya algo almacenado con esa clave se obtendr\u00e1 <code>nil</code>. Pero con otros tipos no es tan f\u00e1cil, ya que en el caso del nivel si la preferencia no exist\u00eda se obtendr\u00e1 0. Entonces \u00bfc\u00f3mo diferenciar si la preferencia se ha fijado a 0 o bien es que no se ha fijado?. La soluci\u00f3n es registrar valores por defecto para todas las preferencias, de modo que no pueda haber una preferencia con un valor no fijado, bien sea porque se ha hecho por defecto o bien sea porque lo ha hecho una acci\u00f3n del usuario.</p>"},{"location":"cap1/1.4_preferencias/#registrar-valores-por-defecto","title":"Registrar valores por defecto","text":"<p>Podemos registrar un conjunto de preferencias por defecto pas\u00e1ndole un diccionario al m\u00e9todo <code>registerDefaults</code> de <code>UserDefaults</code>:</p> <pre><code>let prefs = UserDefaults()\nprefs.register(defaults:[\n  \"nick\" : \"anonimo\",\n  \"nivel\" : 1\n])\n</code></pre> <p>Hay que destacar que los valores registrados por defecto no son permanentes. Es decir, que hay que registrarlos cada vez que arranque la aplicaci\u00f3n.</p> <p>Si registramos un valor por defecto y este ya ha sido fijado por c\u00f3digo (en la siguiente secci\u00f3n veremos c\u00f3mo) el valor por defecto no \u201cmachacar\u00e1\u201d al ya fijado. Cuando iOS busca el valor para una preferencia sigue un esquema de \u201cdominios\u201d, en el que si no encuentra la clave en un dominio la busca en el siguiente. De este modo, primero busca en el dominio de los valores fijados por el usuario y si lo encuentra aqu\u00ed lo devuelve. Es solo si no lo encuentra aqu\u00ed cuando pasa a consultar los valores por defecto.</p> <p>En un poco tedioso tener que volcar en el c\u00f3digo un diccionario con todos los valores por defecto. Un m\u00e9todo muy habitual de registrar los valores por defecto de modo m\u00e1s \u201climpio\u201d es almacenarlos en un archivo <code>.plist</code> y deserializarlos con <code>initWithContentsOfFile</code>, como vimos en el apartado de c\u00f3mo leer property lists.</p>"},{"location":"cap1/1.4_preferencias/#modificar-los-valores-de-las-preferencias","title":"Modificar los valores de las preferencias","text":"<p>Simplemente tenemos que fijar la clave al valor que queramos usando la familia de m\u00e9todos <code>set(valor,forKey:)</code></p> <pre><code>let prefs = UserDefaults()\nprefs.set(5, forKey:\"nivel\")\nprefs.set(\"Pepito\", forKey:\"nick\")\n</code></pre> <p>Por cuestiones de eficiencia, iOS no hace persistente el cambio inmediatamente sino a intervalos regulares o en momentos especiales (por ejemplo justo antes de salir de la aplicaci\u00f3n). Una property list no se puede modificar de manera parcial y hay que crearla entera de nuevo, de manera que no ser\u00eda eficiente persistir siempre los datos tras ejecutar el <code>set</code>. Por c\u00f3digo podemos forzar el cambio en el <code>.plist</code> llamando al m\u00e9todo <code>synchronize</code> de las preferencias</p> <pre><code>UserDefaults().synchronize()\n</code></pre> <p>Otra forma de \"forzar\" la persistencia probando la aplicaci\u00f3n es salir de la misma pulsando en el bot\u00f3n \"home\" (<code>Shift+Cmd+H</code> en el simulador) para que pase a background, momento en el que, como ya hemos dicho, iOS almacena de modo permanente los valores actuales. </p> <p>Como iOS tiene que modificar los datos si hay preferencias modificadas desde la \u00faltima vez que se guardaron, no es aconsejable cambiar el valor de una preferencia \u201ca las primeras de cambio\u201d. Solo es adecuado si no es previsible que vaya a cambiar dentro de poco tiempo. Una estrategia t\u00edpica es fijar los valores justo antes de salir de la aplicaci\u00f3n.</p>"},{"location":"cap1/1.4_preferencias/#material-complementario-ubicar-las-preferencias-en-el-panel-de-control-general","title":"Material complementario: ubicar las preferencias en el \u201cpanel de control\u201d general","text":"<p>Nota</p> <p>Este apartado no te servir\u00e1 para los ejercicios pero puedes echarle un vistazo para saber algo m\u00e1s del tema</p> <p>El sistema nos da la posibilidad de controlar ciertas preferencias de nuestra aplicaci\u00f3n dentro de las preferencias generales del sistema, en un apartado reservado a ella. Esto es lo que se conoce en iOS como un settings bundle. Podemos colocar aqu\u00ed todas las preferencias o solo algunas.</p> <p>Apple recomienda colocar en el sistema solo las preferencias que se cambien en raras ocasiones. Por ejemplo en una aplicaci\u00f3n que gestione un servicio de terceros podemos colocar aqu\u00ed las credenciales de uso del servicio (login y password)</p> <p>A diferencia de las preferencias dentro de la aplicaci\u00f3n, donde iOS nos da un API para editarlas/verlas pero no una interfaz esto es al contrario. En un fichero <code>.plist</code> con un formato especial podemos crear de modo sencillo una interfaz para las preferencias. </p> <p>Para crear un settings bundle en Xcode ir a <code>File &gt; New &gt; File ...</code> y en el cuadro de di\u00e1logo que aparecer\u00e1, dentro del tipo <code>Resource</code> elegir  <code>Settings Bundle</code>. Se crear\u00e1 un archivo de tipo property list llamado <code>Root.plist</code> y algunos archivos auxiliares para la internacionalizaci\u00f3n (necesarios ya que vamos a tratar con elementos de interfaz).</p> <p>Si editamos el <code>Root.plist</code> con el editor de Xcode podemos ver que tiene un formato un tanto especial: la lista de preferencias se representa con un array de items. Las propiedades de estos items son las que determinan el tipo de widget a usar para editar/ver la preferencia, sus par\u00e1metros y la clave con la que se va a almacenar la preferencia asociada. </p> <p>En el ejemplo que se muestra a continuaci\u00f3n, que se corresponde con el <code>Root.plist</code> que crea por defecto Xcode, puede verse que el item 1 es de tipo \"campo de texto\", que su <code>title</code> (la etiqueta que se ve en las preferencias) es <code>Name</code>, que el widget tiene una serie de propiedades (cuando se edita aparece un teclado alfab\u00e9tico,  no es seguro - o sea, se muestra el contenido, \u2026) y est\u00e1 asociada a la preferencia cuya clave es <code>name_preference</code> (propiedad <code>Identifier</code>). </p> <p></p> <p>No tenemos espacio en estos apuntes para explicar m\u00e1s detalladamente el proceso de configuraci\u00f3n del bundle. El lector interesado puede consultar el apartado \u201cimplementing an iOS settings bundle\u201d de la \u201cPreferences and Settings Programming Guide\u201d de Apple.</p> <p></p> <p></p>"},{"location":"cap1/1.4_preferencias/#ejercicio-075-puntos","title":"Ejercicio (0.75 puntos)","text":"<p>Vamos a realizar una peque\u00f1a aplicaci\u00f3n en la que los datos se guarden usando algunos de los mecanismos vistos en la sesi\u00f3n. Desde el punto de vista del usuario consistir\u00e1 en una \u00fanica \"pantalla\" con un <code>Text View</code> para editar un mensaje y un <code>Label</code> que mostrar\u00e1 la fecha y hora de edici\u00f3n. Los datos deben conservarse aunque salgamos de la aplicaci\u00f3n.</p> <p>Llama al proyecto <code>PersistenciaBasica</code>.</p>"},{"location":"cap1/1.4_preferencias/#interfaz-grafico","title":"Interfaz gr\u00e1fico","text":"<p>Crea la interfaz:</p> <ul> <li>Inserta un <code>Text View</code>, un <code>Label</code> y un <code>Button</code> que ponga \"guardar\" en el storyboard</li> <li>En el <code>ViewController</code><ul> <li>Crea dos outlet para acceder al contenido de text view y label. Recuerda que tienes que hacer <code>Ctrl+arrastrar</code>.</li> <li>Cra un action que responda a pulsaciones sobre el bot\u00f3n \"guardar\"  </li> <li>Crea una propiedad opcional llamada <code>fechaEdicion</code> de tipo <code>Date</code>, que representar\u00e1 la fecha y hora en que se haya editado el texto. </li> </ul> </li> </ul>"},{"location":"cap1/1.4_preferencias/#formatear-la-fecha-de-edicion","title":"Formatear la fecha de edici\u00f3n","text":"<p>Queremos que cuando se pulse el bot\u00f3n \"guardar\" (por tanto tendr\u00e1s que hacer esto en el action del bot\u00f3n):</p> <ul> <li>La <code>fechaEdicion</code> se ponga a la fecha y hora actuales</li> </ul> <pre><code>self.fechaEdicion = Date()\n</code></pre> <ul> <li>La fecha se muestre en modo texto en el label. Como el formato por defecto es un poco engorroso, mejor la formatearemos nosotros</li> </ul> <pre><code>//SUPONEMOS que el outlet del label se llama \"fechaLabel\"\n//CAMBIALO por lo que sea necesario\nself.fechaLabel.text = DateFormatter.localizedString(\n             from:self.fechaEdicion!, \n             dateStyle: .short, timeStyle: .medium)\n</code></pre> <p>Comprobar que lo anterior funciona correctamente, que al pulsar sobre el bot\u00f3n,se muestra la fecha y hora de edici\u00f3n en el label.</p>"},{"location":"cap1/1.4_preferencias/#guardar-los-datos","title":"Guardar los datos","text":"<p>En el action del bot\u00f3n a\u00f1ade el c\u00f3digo Swift que necesites para almacenar el texto y la fecha como  dos preferencias de usuario llamadas \"texto\" y \"fecha\" respectivamente (en la fecha guarda la propiedad de tipo <code>Date</code>, no la fecha convertida a texto, esa es solo para visualizaci\u00f3n). Tendr\u00e1s que mirar los apuntes para ver c\u00f3mo hacerlo (apartado \"Modificar los valores de las preferencias\")</p>"},{"location":"cap1/1.4_preferencias/#recuperar-los-datos-al-cargar-la-aplicacion","title":"Recuperar los datos al cargar la aplicaci\u00f3n","text":"<p>En el <code>viewDidLoad</code> del controller recupera las dos preferencias que guardaste y muestra su contenido en pantalla, a trav\u00e9s de los correspondientes outlets.</p> <p>Consulta el apartado \"Acceder a las preferencias\". Para recuperar la fecha:</p> <ul> <li>Como no hay un m\u00e9todo espec\u00edfico para recuperar fechas, tendr\u00e1s que usar el de objetos: <code>object(forKey:)</code> de <code>UserDefaults</code> </li> <li>Para convertirlo de objeto en fecha tendr\u00e1s que hacer un cast a <code>Date</code> (<code>as! Date</code>).</li> </ul> <p>Para comprobar si las preferencias se guardan:</p> <ul> <li>Sal de la app como lo har\u00eda un usuario en el m\u00f3vil real (men\u00fa <code>Device &gt; Home</code> del simulador). </li> <li>Ve a la aplicaci\u00f3n SimSim en el men\u00fa superior, selecciona la app <code>PersistenciaBasica</code> y luego selecciona <code>Finder</code>: se abrir\u00e1 una carpeta con el sistema de archivos de la app. </li> <li>Las preferencias se guardan en <code>Library/Preferences</code>. Deber\u00eda haber un fichero <code>.plist</code>. Si lo abres d\u00e1ndole doble clic deber\u00eda abrirse en Xcode y podr\u00e1s ver el contenido</li> </ul>"},{"location":"cap1/1.5_ejercicios/","title":"1.5 ejercicios","text":"<p>Vamos a realizar una peque\u00f1a aplicaci\u00f3n en la que los datos se guarden usando algunos de los mecanismos vistos en la sesi\u00f3n. Desde el punto de vista del usuario consistir\u00e1 en una \u00fanica \"pantalla\" con un <code>Text View</code> para editar un mensaje y un <code>Label</code> que mostrar\u00e1 la fecha y hora de edici\u00f3n. Los datos deben conservarse aunque salgamos de la aplicaci\u00f3n.</p> <p>Llama al proyecto <code>PersistenciaBasica</code>.</p>"},{"location":"cap1/1.5_ejercicios/#interfaz-grafico-025-puntos","title":"Interfaz gr\u00e1fico (0,25 puntos)","text":"<p>Crea la interfaz:</p> <ul> <li>Inserta un <code>Text View</code>, un <code>Label</code> y un <code>Button</code> que ponga \"guardar\" en el storyboard</li> <li>En el <code>ViewController</code><ul> <li>Crea dos outlet para acceder al contenido de text view y label. Recuerda que tienes que hacer <code>Ctrl+arrastrar</code>.</li> </ul> </li> <li>Cra un action que responda a pulsaciones sobre el bot\u00f3n \"guardar\"  </li> <li>Crea una propiedad opcional llamada <code>fechaEdicion</code> de tipo <code>Date</code>, que representar\u00e1 la fecha y hora en que se haya editado el texto. </li> </ul>"},{"location":"cap1/1.5_ejercicios/#almacenamiento-y-recuperacion-de-datos-075-puntos","title":"Almacenamiento y recuperaci\u00f3n de datos (0,75 puntos)","text":""},{"location":"cap1/1.5_ejercicios/#fecha-de-edicion","title":"Fecha de edici\u00f3n","text":"<p>Queremos que cuando se pulse el bot\u00f3n \"guardar\" (por tanto tendr\u00e1s que hacer esto en el action del bot\u00f3n):</p> <ul> <li>La <code>fechaEdicion</code> se ponga a la fecha y hora actuales</li> </ul> <pre><code>self.fechaEdicion = Date()\n</code></pre> <ul> <li>La fecha se muestre en modo texto en el label. Como el formato por defecto es un poco engorroso, mejor la formatearemos nosotros</li> </ul> <pre><code>//SUPONEMOS que el outlet del label se llama \"fechaLabel\"\n//CAMBIALO por lo que sea necesario\nself.fechaLabel.text = DateFormatter.localizedString(\n             from:self.fechaEdicion!, \n             dateStyle: .short, timeStyle: .medium)\n</code></pre> <p>Comprobar que lo anterior funciona correctamente, que al pulsar sobre el bot\u00f3n,se muestra la fecha y hora de edici\u00f3n en el label.</p>"},{"location":"cap1/1.5_ejercicios/#guardar-los-datos","title":"Guardar los datos","text":"<p>En el action del bot\u00f3n a\u00f1ade el c\u00f3digo Swift que necesites para almacenar el texto y la fecha como  dos preferencias de usuario llamadas \"texto\" y \"fecha\" respectivamente (en la fecha guarda la propiedad de tipo <code>Date</code>, no la fecha convertida a texto, esa es solo para visualizaci\u00f3n). Tendr\u00e1s que mirar los apuntes para ver c\u00f3mo hacerlo (apartado \"Modificar los valores de las preferencias\")</p>"},{"location":"cap1/1.5_ejercicios/#recuperar-los-datos-al-cargar-la-aplicacion","title":"Recuperar los datos al cargar la aplicaci\u00f3n","text":"<p>En el <code>viewDidLoad</code> del controller recupera las dos preferencias que guardaste y muestra su contenido en pantalla, a trav\u00e9s de los correspondientes outlets.</p> <p>Consulta el apartado \"Acceder a las preferencias\". Para recuperar la fecha:</p> <ul> <li>Como no hay un m\u00e9todo espec\u00edfico para recuperar fechas, tendr\u00e1s que usar el de objetos: <code>object(forKey:)</code> de <code>UserDefaults</code> </li> <li>Para convertirlo de objeto en fecha tendr\u00e1s que hacer un cast a <code>Date</code> (<code>as! Date</code>).</li> </ul> <p>Para comprobar si las preferencias se guardan:</p> <p>En el simulador el sistema de carpetas y archivos de cada app se guarda en un directorio un poco \"perdido\" en el disco, un poco dif\u00edcil de localizar manualmente.  Hay aplicaciones que nos permiten encontrarlo m\u00e1s f\u00e1cilmente para as\u00ed poder comprobar si nuestro c\u00f3digo est\u00e1 creando los archivos correctamente. Una de estas aplicaciones, de libre distribuci\u00f3n es SimSim. B\u00e1jatela, descompr\u00edmela y arrastra el <code>.app</code> a la carpeta de aplicaciones. Al arrancar crear\u00e1 un icono en la barra superior de men\u00fa del Mac donde podemos ver las apps que tenemos en el simulador y abrir la carpeta correspondiente con los datos en el Finder o en una terminal.</p> <ul> <li>Sal de la app como lo har\u00eda un usuario en el m\u00f3vil real (men\u00fa <code>Device &gt; Home</code> del simulador). </li> <li>Ve a la aplicaci\u00f3n SimSim en el men\u00fa superior, selecciona la app <code>PersistenciaBasica</code> y luego selecciona <code>Finder</code>: se abrir\u00e1 una carpeta con el sistema de archivos de la app. </li> <li>Las preferencias se guardan en <code>Library/Preferences</code>. Deber\u00eda haber un fichero <code>.plist</code>. Si lo abres d\u00e1ndole doble clic deber\u00eda abrirse en Xcode y podr\u00e1s ver el contenido</li> </ul>"},{"location":"cap1/intro/","title":"Persistencia b\u00e1sica en iOS","text":"<p>En este tema veremos APIs b\u00e1sicos para poder almacenar estructuras de datos relativamente sencillas. Si la cantidad de informaci\u00f3n que necesitamos almacenar no es demasiado amplia ni tampoco tenemos que hacer consultas o b\u00fasquedas podemos usar APIs de iOS bastante simples (al menos comparados con los que se usan para acceder a bases de datos).</p> <p>El caso m\u00e1s t\u00edpico es cuando necesitamos almacenar un conjunto de pares \"clave/valor\", para los que podemos usar property lists o bien el sistema de preferencias de iOS. Este es el mecanismo habitual para guardar las preferencias de una aplicaci\u00f3n (colores, tipos de letra, datos b\u00e1sicos del usuario,...).</p> <p>Si necesitamos almacenar objetos de clases propias cualesquiera podemos archivarlas, que ser\u00eda lo que en otros lenguajes se denomina serializar. Acabaremos el cap\u00edtulo viendo c\u00f3mo se pueden archivar objetos en iOS.</p>"},{"location":"cap10/2_MVC/","title":"2 MVC","text":""},{"location":"cap10/2_MVC/#modelovistacontrolador","title":"Modelo/Vista/Controlador","text":""},{"location":"cap10/2_MVC/#los-problemas-de-mvc","title":"Los problemas de MVC","text":"<p>En teor\u00eda la estructura de una aplicaci\u00f3n iOS con MVC deber\u00eda ser sencilla y \"limpia\", ya que cada uno de los tres componentes tiene una responsabilidad separada. </p> <p></p> <p>En la pr\u00e1ctica, la principal fuente de problemas de esta arquitectura es el controlador. Por un lado, el <code>UIViewController</code> est\u00e1 tan unido a la vista que acaba siendo parte de ella en lugar de un componente separado. En la realidad la arquitectura de muchas aplicaciones iOS acaba pareci\u00e9ndose m\u00e1s a la siguiente figura que a la anterior:</p> <p></p> <p>Al estar tan acoplado el controlador a la vista se hace casi imposible hacer testing del controlador en s\u00ed, sin probar la interfaz de usuario, ya que tendr\u00edamos que hacer un mock de todos los componentes de la vista que interact\u00faan con el controlador.</p> <p>Por otro lado es f\u00e1cil \"dejarse llevar\" y acabar asign\u00e1ndole demasiadas responsabilidades al controlador: colocar en \u00e9l l\u00f3gica de negocio, hacer que sea el datasource o el delegate de las tablas que contiene,... Esto da lugar a lo que de modo ir\u00f3nico se conoce como massive view controller.</p> <p>Casi todos los tutoriales y ejemplos sobre frameworks o APIs de iOS que encontrar\u00e9is en la web o en los libros tienen este problema, incluyendo muchas veces el material que os damos en este curso. Como el objetivo del tutorial o del ejemplo es aprender sobre el framework/API que no conoces, se tiende a poner todo el c\u00f3digo en el view controller, evitando crear clases adicionales que a\u00f1adir\u00edan complejidad al ejemplo y distraer\u00edan del objetivo principal. Pero por desgracia el resultado final es un Massive View Controller.</p> <p>Para solucionar todos estos problemas podemos usar una arquitectura distinta a MVC, como veremos en apartados posteriores. Pero no todo son problemas en MVC tal como lo propone Apple: tiene la ventaja de estar especialmente adaptado a la filosof\u00eda de la plataforma, los frameworks y los APIs de iOS, y adem\u00e1s es una arquitectura sencilla. Una alternativa ser\u00eda continuar us\u00e1ndolo pero intentar \"aligerar\" el controlador en la medida de lo posible para hacer el c\u00f3digo m\u00e1s mantenible. Vamos a ver c\u00f3mo podr\u00edamos hacerlo.</p>"},{"location":"cap10/2_MVC/#controladores-ligeros","title":"Controladores \"ligeros\"","text":"<p>B\u00e1sicamente la idea es dejar en el controlador el m\u00ednimo de c\u00f3digo imprescindible para coordinarse con el modelo y con la vista, que es la que deber\u00eda ser su \u00fanica labor. Esto no es m\u00e1s que una aplicaci\u00f3n del \"Principio de responsabilidad \u00fanica\" (Single Responsibility Principe), un principio b\u00e1sico en el dise\u00f1o y desarrollo de software que sostiene que cada componente deber\u00eda tener una \u00fanica responsabilidad o funcionalidad en el sistema. Esto no solo mejora la estructura del c\u00f3digo, sino que tambi\u00e9n facilita el testing y mejora la mantenibilidad de la aplicaci\u00f3n.</p> <p>Si \"nos dejamos llevar\" y colocamos todo el c\u00f3digo de la aplicaci\u00f3n en el view controller, al final puede acabar teniendo las siguientes responsabilidades:</p> <ul> <li>Almacenar temporalmente y modificar los datos de la aplicaci\u00f3n</li> <li>Implementar al menos parte de la l\u00f3gica de negocio, que deber\u00eda estar \u00fanicamente en las clases del modelo</li> <li>Implementar la persistencia de datos. Si adem\u00e1s usamos Core Data y necesitamos listar datos con un fetched results controller, el view controller acaba teniendo que convertirse en su delegate.</li> <li>En caso de tener una tabla:<ul> <li>T\u00edpicamente es datasource y delegate de la misma</li> <li>Al ser el datasource, se tiene que encargar de rellenar todos los datos de cada celda, por lo que tiene que conocer su estructura</li> </ul> </li> <li>El view controller acaba convirti\u00e9ndose la mayor\u00eda de veces en el delegate de los componentes de interfaz que requieren uno, por ejemplo los sliders o los datepickers.</li> <li>Muchas veces cuando de un view controller se salta a otro este le pasa los datos fijando propiedades en el view controller destino. Eso implica un conocimiento de la estructura interna de este controller.</li> </ul> <p>B\u00e1sicamente la soluci\u00f3n es relativamente de \"sentido com\u00fan\" y consiste en extraer todas estas funcionalidades a clases/structs adicionales. Vamos a ver algunas ideas gen\u00e9ricas de c\u00f3mo se podr\u00edan hacer estas refactorizaciones.</p>"},{"location":"cap10/2_MVC/#separacion-de-los-datasourcesdelegates","title":"Separaci\u00f3n de los datasources/delegates","text":"<p>Vamos a ver c\u00f3mo se podr\u00eda extraer el datasource de una tabla. Un delegate ser\u00eda similar. Intentaremos hacer una clase gen\u00e9rica que nos pueda servir en varios proyectos. Dicha clase:</p> <ul> <li>Por supuesto implementa los m\u00e9todos del protocolo <code>UITableViewDataSource</code></li> <li>Contiene un array con los objetos a mostrar, ya que es la forma m\u00e1s sencilla de representar los datos.</li> <li>Acepta en el constructor una clausura que se encarga de rellenar los campos de una celda a partir de un objeto</li> </ul> <pre><code>import Foundation\nimport UIKit\n\nclass ListaItemsDataSource&lt;Item&gt; : NSObject, UITableViewDataSource {\n    private var items : [Item]\n    private var idCelda : String\n    private var configurarCelda : (UITableViewCell, Item) -&gt; Void\n\n    init(listaItems: [Item], idCelda : String, configurarCelda : @escaping (UITableViewCell, Item) -&gt; Void) {\n        self.items = listaItems\n        self.idCelda = idCelda\n        self.configurarCelda = configurarCelda\n    }\n\n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {\n        return items.count\n    }\n\n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {\n        let cell = tableView.dequeueReusableCell(withIdentifier: self.idCelda, for: indexPath)\n        self.configurarCelda(cell, self.items[indexPath.row])\n        return cell\n    }   \n}\n</code></pre> <p>Y aqu\u00ed tenemos un view controller de ejemplo que hace uso de esta clase. Por ejemplo supongamos que queremos mostrar una lista de objetos <code>Persona</code></p> <pre><code>class MiController: UIViewController {\n    var miDataSource : ListaItemsDataSource&lt;Usuario&gt;!\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        //Tendr\u00edamos que obtener los datos de alg\u00fan sitio, p.ej. de Core Data\n        let lista = ...\n        self.miDataSource = ListaItemsDataSource&lt;Usuario&gt;(listaItems: lista, idCelda: \"MiCelda\") {\n            celda,persona in\n              celda.textLabel?.text = persona.nombre\n              let df = DateFormatter()\n              df.dateFormat = \"dd/MM/yyyy\"\n              let fechaString = df.string(from: persona.fechaNacimiento)\n              celda.detailTextLabel?.text = fechaString\n        }\n        self.tableView.dataSource = self.miDataSource\n    }\n}\n</code></pre>"},{"location":"cap10/2_MVC/#extraer-el-codigo-de-configuracion-de-la-celda","title":"Extraer el c\u00f3digo de configuraci\u00f3n de la celda","text":"<p>En el c\u00f3digo anterior el View Controller sigue teniendo que ocuparse de rellenar los campos de la celda, lo que hace que tenga que conocer su estructura: en el ejemplo, que la celda tiene un <code>textLabel</code> y un <code>detailTextLabel</code> y tambi\u00e9n que tenga que ocuparse de formatear los datos, por ejemplo la fecha.</p> <p>Podemos encapsular la informaci\u00f3n sobre la \"estructura interna\" de la celda en una nueva clase, que en MVC pertenecer\u00eda a la vista. </p> <pre><code>class CeldaPersona : UITableViewCell {\n    static let idCelda = \"MiCelda\"\n    var nombre : String? {\n        didSet {\n            self.textLabel?.text = self.nombre\n        }\n    }\n    var fecha : Date? {\n        didSet {\n            let df = DateFormatter()\n            df.dateStyle = .short\n            self.detailTextLabel?.text = df.string(from: self.fecha!)\n        }\n    }\n}\n</code></pre> <p>N\u00f3tese que ahora \"desde fuera\" para configurar la celda lo \u00fanico que hay que hacer es fijar el valor de las propiedades \"texto\" y \"fecha\". Los <code>didSet</code> se encargar\u00e1n autom\u00e1ticamente de rellenar los campos de la celda con el formato adecuado.</p> <p>De este modo el view controller quedar\u00eda a\u00fan m\u00e1s sencillo</p> <pre><code>class MiController: UIViewController {\n    var miDataSource : ListaItemsDataSource&lt;Usuario&gt;!\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        //Tendr\u00edamos que obtener los datos de alg\u00fan sitio, p.ej. de Core Data\n        let lista = ...\n        self.miDataSource = ListaItemsDataSource&lt;Usuario&gt;(listaItems: lista, idCelda: \"MiCelda\") {\n            celda,persona in\n              if let celdaPersona = celda as? CeldaPersona {\n                celdaPersona.nombre = persona.nombre\n                celdaPersona.fecha = persona.fechaNacimiento\n              } \n        }\n        self.tableView.dataSource = self.miDataSource\n    }\n}\n</code></pre> <p>Para que el cast de <code>celda as CeldaPersona</code> pueda tener \u00e9xito, en Xcode habr\u00e1 que seleccionar la celda prototipo en el storyboard y cambiar en el \"identity inspector\" del panel derecho la clase de la celda por <code>CeldaPersona</code>.</p>"},{"location":"cap10/3_MVP/","title":"3 MVP","text":""},{"location":"cap10/3_MVP/#modelviewpresenter","title":"Model/View/Presenter","text":"<p>Este patr\u00f3n de dise\u00f1o soluciona algunos de los problemas que tiene el MVC \"al estilo Apple\". El nuevo componente, llamado presenter se encarga de la l\u00f3gica de presentaci\u00f3n, y debe ser independiente de la tecnolog\u00eda que se est\u00e9 usando para la vista, que en iOS ser\u00e1 <code>UIKit</code>. La l\u00f3gica de presentaci\u00f3n engloba todas las operaciones necesarias para formatear los datos del modelo de modo que se puedan visualizar adecuadamente. Por ejemplo es posible que el modelo nos devuelva la distancia total de una ruta, y queramos que se pueda visualizar en metros o kil\u00f3metros. La conversi\u00f3n de unidades ser\u00eda responsabilidad del presenter.</p> <p></p> <p>A primera vista el diagrama de componentes anterior parece muy similar al original de MVC, simplemente sustituyendo el controller por el presenter. No obstante, el que el presenter deba ser independiente de la tecnolog\u00eda de la vista tiene un impacto bastante importante en el c\u00f3digo. En las aplicaciones debemos seguir usando <code>UIViewControllers</code>, ya que son una parte b\u00e1sica de la plataforma. Sin embargo esta clase no es totalmente independiente de la tecnolog\u00eda de la vista, porque est\u00e1 \u00edntimamente unida a ella. De hecho, esto era uno de los problemas que ten\u00edamos en el MVC \"estilo Apple\". Por eso, en MVP consideraremos al view controller como parte de la vista. Es decir, el presenter de ning\u00fan modo es el antiguo controller bajo otro nombre, sino algo totalmente distinto.</p> <p>Vamos a verlo a trav\u00e9s de un ejemplo. Usaremos la aplicaci\u00f3n <code>UAdivino</code>, que fue nuestra primera aplicaci\u00f3n iOS en Swift. Recordemos que se trata de una app a la que se le \"formula una pregunta\" (\u00bfAprender\u00e9 Swift?) y nos da una contestaci\u00f3n positiva o negativa (claro que s\u00ed, o ni de casualidad). Vamos a hacer que si la contestaci\u00f3n es positiva se muestre en color verde y si es negativa en color rojo. </p> <p></p> <p>Lo primero que vamos a hacer es formalizar la interfaz de los tres componentes, modelo, vista y presentador, usando protocolos. El diagrama de componentes quedar\u00eda del siguiente modo:</p> <p></p> <p>Cuando se pulsa el bot\u00f3n de \"obtener respuesta\" la vista llama a <code>solicitarRespuesta()</code> del presentador. Este a su vez le pide al modelo que \"haga el trabajo\", generando una respuesta al  azar. La respuesta contiene un texto y un booleano indicando si es positiva o negativa. Con este \u00faltimo el presentador calcula el color (verde o rojo, respectivamente), y le pasa texto y color a la vista para que lo muestre. En este caso la \"l\u00f3gica de presentaci\u00f3n\" consiste simplemente en calcular el color correspondiente a la respuesta.</p> <p>Al ser este un ejemplo muy sencillo el modelo no necesita notificaciones para \"avisar\" al presentador de que hay datos que mostrar. Una aplicaci\u00f3n que hiciera una b\u00fasqueda en un servicio web llamar\u00eda a un callback del presenter cuando se hubieran recibido los datos.</p> <p>Pod\u00e9is ver el c\u00f3digo fuente completo en el repositorio de GitHub.</p>"},{"location":"cap10/3_MVP/#ensamblado-de-la-arquitectura","title":"Ensamblado de la arquitectura","text":"<p>vista y presentador deben comunicar el uno con el otro, as\u00ed que cada uno debe tener una referencia al otro.</p>"},{"location":"cap10/4_MVVM/","title":"4 MVVM","text":""},{"location":"cap10/4_MVVM/#mvvm","title":"MVVM","text":""},{"location":"cap10/4_MVVM/#mvvm-vs-mvp","title":"MVVM vs. MVP","text":"<p>El patr\u00f3n de dise\u00f1o Model/View/ViewModel es muy similar al MVP que vimos en el apartado anterior. </p> <p></p> <p>De hecho, el ViewModel tiene m\u00e1s o menos la misma funcionalidad que el presenter, implementar la l\u00f3gica de presentaci\u00f3n y aislarla de la tecnolog\u00eda concreta usada para la presentaci\u00f3n.</p> <p>\u00bfD\u00f3nde est\u00e1 la diferencia entonces?. En que MVVM soluciona uno de los principales problemas que tiene MVP, el acoplamiento entre vista y presenter. Como estuvimos discutiendo, la vista y el presenter deben \"conocerse\" mutuamente, ya que la vista debe comunicarle a este las acciones del usuario, y el presenter enviarle a la vista los datos a mostrar. Esto hace que ambos componentes est\u00e9n acoplados entre s\u00ed, ya hemos visto en el c\u00f3digo de ejemplo de MVP que en la vista hay una referencia al presenter y viceversa. En MVVM no existe este acoplamiento, y lo vamos a evitar usando bindings, es decir, vinculaci\u00f3n autom\u00e1tica entre los datos de la modelo y el presenter, de manera que cuando cambie alguno de ellos se modifique autom\u00e1ticamente el otro. Esto permite que el c\u00f3digo quede mucho m\u00e1s \"limpio\", ya que no hay que actualizar el otro componente de modo expl\u00edcito.</p> <p>En iOS no hay ninguna tecnolog\u00eda est\u00e1ndar para vincular elementos de la vista con propiedades del modelo (aunque en OSX s\u00ed existe). Podr\u00edamos usar KVO o notificaciones para hacer la vinculaci\u00f3n, pero la implementaci\u00f3n ser\u00eda un poco tediosa. As\u00ed que tendremos que usar alguna librer\u00eda de terceros. Aqu\u00ed veremos una bastante sencilla de usar llamada Bond (el nombre completo es Bond, Swift Bond :)).</p> <p>Para implementar los bindings podr\u00edamos usar tambi\u00e9n alg\u00fan framework de reactive programming. Este paradigma de programaci\u00f3n permite implementar la funcionalidad de manera bastante elegante. No obstante usar un framework de este tipo solo para implementar bindings probablemente sea demasiado, ya que la idea de reactive programming es bastante m\u00e1s amplia. En cualquier caso es posible que encontr\u00e9is tutoriales y otros recursos de MVVM en iOS que usen frameworks reactivos como ReactiveCocoa o RXSwift. De hecho, Bond est\u00e1 construido sobre un framework de este tipo, aunque m\u00e1s sencillo. Y como se ver\u00e1, en el ejemplo usaremos funcionalidades t\u00edpicas de programaci\u00f3n reactiva.</p>"},{"location":"cap10/4_MVVM/#mvvm-con-la-libreria-bond","title":"MVVM con la librer\u00eda \"Bond\"","text":"<p>Vamos a verlo con un ejemplo, ya que as\u00ed se entender\u00e1n mejor los conceptos. Implementaremos ahora una versi\u00f3n MVVM de la aplicaci\u00f3n <code>UAdivino</code>, al estilo de la que hicimos en el apartado anterior, es decir, mostrando cada tipo de respuesta de un color distinto. La diferencia fundamental va a estar en que vincularemos de modo autom\u00e1tico tanto el texto de la respuesta como el color para que no haga falta fijarlos de forma expl\u00edcita en la vista. Esta vinculaci\u00f3n la haremos gracias a la librer\u00eda Bond.</p> <p>La forma m\u00e1s sencilla de configurar un proyecto de Xcode con Bond es usando Cocoapods. En el README de Bond en Github est\u00e1n las instrucciones. Vamos a empezar a trabajar suponiendo que ya se ha hecho esta configuraci\u00f3n. Como en el caso de la versi\u00f3n MVP pod\u00e9is consultar el c\u00f3digo fuente completo en GitHub.</p>"},{"location":"cap10/4_MVVM/#vinculacion-de-viewmodel-a-vista","title":"Vinculaci\u00f3n de viewmodel a vista","text":"<p>Al vincular un origen con un destino lo que hacemos es que cuando el primero cambia, el segundo tambi\u00e9n lo hace autom\u00e1ticamente. Esto simplifica mucho el c\u00f3digo ya que podemos cambiar una propiedad del viewmodel y que se refleje autom\u00e1ticamente en la vista, o viceversa.</p> <p>En nuestro ejemplo del <code>UAdivino</code> queremos vincular dos propiedades del viewmodel con la vista: el texto de la respuesta y el color de la misma. En la librer\u00eda Bond los bindings se basan en la idea de observable. Esta es una idea similar a la de los eventos. Podemos indicar que queremos observar un elemento observable de modo que se nos \"avisar\u00e1\" de cu\u00e1ndo cambia su valor. No obstante a diferencia de los eventos, que ya suelen estar predefinidos en el sistema, podemos crear los observables \"bajo demanda\" y adem\u00e1s como veremos se pueden manipular, transformar y combinar permiti\u00e9ndonos hacer cosas complejas de modo relativamente sencillo. La idea de observable es la idea fundamental tras el paradigma de programaci\u00f3n reactiva, aunque en este paradigma suele recibir otros nombres, siendo el m\u00e1s t\u00edpico el de stream (en librer\u00edas como ReactiveCocoa se denominan signals).</p> <p>As\u00ed, definiremos el texto de la respuesta como un observable \"de tipo\" <code>String</code> en lugar de simplemente como un <code>String</code>, para poder vincularlo a la vista. En el viewmodel har\u00edamos esto para crear el observable con un valor inicial de \"\" (cadena vac\u00eda):</p> <pre><code>import Bond\n\nlet textoResp = Observable&lt;String&gt;(\"\")\n</code></pre> <p>N\u00f3tese que <code>textoResp</code> no es un <code>String</code> sino un observable. El valor que hay \"dentro\" del observable es accesible a trav\u00e9s de su propiedad <code>value</code></p> <pre><code>print(textoResp.value) //imprimir\u00e1 la cadena vac\u00eda\ntextoResp.value = \"hola\"\n</code></pre> <p>Para vincular una propiedad de un elemento de <code>UIKit</code> con un observable usamos el m\u00e9todo <code>bind(to:)</code>. La librer\u00eda Bond extiende los elementos de interfaz a\u00f1adi\u00e9ndoles una propiedad <code>reactive</code>. Dentro de esta es donde est\u00e1n las propiedades \"vinculables\". Por ejemplo el texto de un campo estar\u00eda en <code>reactive.text</code>, el color en <code>reactive.textColor</code>, etc.</p> <p>Supongamos que en la vista tenemos el viewmodel accesible en la propiedad <code>viewModel</code> (como veremos en el apartado siguiente). Entonces har\u00edamos algo como:</p> <pre><code>self.viewModel.textoResp.bind(to:self.labelRespuesta.reactive.text)\n</code></pre> <p>para vincular el observable <code>textoResp</code> del viewmodel al texto de la etiqueta <code>labelRespuesta</code>. A partir de este momento cada vez que el viewmodel cambie el valor del observable se cambiar\u00e1 tambi\u00e9n el mensaje en la pantalla.</p> <p>Vamos a ver ahora la vinculaci\u00f3n entre el color de la respuesta y el que se muestra en pantalla. El viewmodel usa un tipo propio enumerado, <code>ColorRespuesta</code> para representar el color con que se deber\u00eda mostrar la resupesta. Por tanto en el viewmodel crearemos un observable de este tipo con un valor inicial cualquiera.</p> <pre><code>let colorResp = Observable&lt;ColorRespuesta&gt;(.verde)\n</code></pre> <p>En iOS lo m\u00e1s sencillo para representar colores es usar la clase <code>UIColor</code>, pero recordemos que el viewmodel no deber\u00eda contener c\u00f3digo de <code>UIKit</code>, por eso usamos el tipo propio <code>ColorRespuesta</code>.</p> <p>Ahora el problema es que no podemos vincular directamente el color del label con este observable, ya que el color de los elementos de la interfaz es un <code>UIColor</code> y nosotros tenemos un tipo distinto. Sin embargo una idea bastante poderosa de los observables es que se pueden transformar y adem\u00e1s de modo encadenado. Para ello se pueden usar las primitivas t\u00edpicas de programaci\u00f3n funcional (<code>map</code>, <code>filter</code>,...) y adem\u00e1s algunas adicionales, dando lugar a lo que se conoce como FRP (Functional Reactive Programming). Por tanto lo que haremos ser\u00e1 transformar el observable en un <code>UIColor</code> y vincular con este (ya que la transformaci\u00f3n de un observable es tambi\u00e9n un observable, lo que nos permite encadenar operaciones). En la vista har\u00edamos algo como:</p> <pre><code>viewModel.colorResp\n    .map {\n       color in\n       return (color == .verde ? UIColor.green : UIColor.red)\n    }\n    .bind(to: self.labelRespuesta.reactive.textColor)\n</code></pre> <p>Recordemos que <code>map</code> parte de un valor y devuelve el valor transformado gracias a la clausura que se le pasa como par\u00e1metro.</p>"},{"location":"cap10/4_MVVM/#vinculacion-de-vista-a-viewmodel","title":"Vinculaci\u00f3n de vista a viewmodel","text":"<p>En el ejemplo de <code>UAdivino</code> no hay ning\u00fan caso de uso de vinculaci\u00f3n en la direcci\u00f3n contraria, es decir, de la vista hacia el viewmodel, as\u00ed que pondremos otro ejemplo. Supongamos un campo de texto en que el usuario escribe un texto de b\u00fasqueda. En la vista tendremos definido un outlet que referencie el campo de texto. Vincularemos desde la propiedad <code>reactive.text</code> del campo hacia la propiedad correspondiente del viewmodel. Pero cuidado, el destino no puede ser un tipo \"normal\" de Swift sino que debe ser un <code>Observable</code> En el viewmodel</p> <pre><code>var textoBusqueda = Observable&lt;String&gt;(\"\")\n</code></pre> <p>En la vista, suponiendo que el viewmodel es accesible a trav\u00e9s de la propiedad <code>viewModel</code>:</p> <pre><code>self.campoTexto.reactive.text.bind(to:viewModel.textoBusqueda)\n</code></pre> <p>Podemos establecer tambi\u00e9n una vinculaci\u00f3n bidireccional de modo que cuando cambie cualquiera de los dos lados cambie el otro (de la propiedad a la vista y viceversa). Esto lo har\u00edamos simplemente usando <code>bidirectionalBind</code> en lugar de <code>bind</code></p> <pre><code>self.campoTexto.reactive.text.bidirectionalBind(to:viewModel.textoBusqueda)\n</code></pre>"},{"location":"cap10/4_MVVM/#ensamblaje-de-modelo-viewmodel-y-vista","title":"\"Ensamblaje\" de modelo, viewmodel y vista","text":"<p>Al igual que en el caso de MVP, hay que conectar las \"piezas\": modelo, viewmodel y vista. Como seg\u00fan el esquema del patr\u00f3n la vista \"posee\" al viewmodel, definiremos este como una propiedad de la vista:</p> <pre><code>class UAdivinoView : UIViewController {\n   let viewModel = UAdivinoViewModel()\n   ...\n} \n</code></pre> <p>Y como el viewmodel \"posee\" al modelo definiremos este como una propiedad del primero:</p> <pre><code>class UAdivinoViewModel {\n   let model = UAdivinoModel(nombre: \"Rappel\")\n   ...\n}\n</code></pre> <p>En MVVM, una parte importante del ensamblaje es inicializar los bindings. Una forma sencilla de hacer esto es en el <code>viewDidLoad</code> de la vista:</p> <pre><code>override func viewDidLoad() {\n   self.bindViewModel()\n}\n\nfunc bindViewModel() {\n    //conectamos viewModel.textoResp -&gt; texto del label\n    viewModel.textoResp.bind(to: self.labelRespuesta.reactive.text)\n    ...\n}\n</code></pre>"},{"location":"cap10/5_VIPER/","title":"5 VIPER","text":""},{"location":"cap10/5_VIPER/#viper","title":"VIPER","text":"<p>MVP y MVVM son un paso m\u00e1s en la separaci\u00f3n de responsabilidades en los componentes de la aplicaci\u00f3n, pero no dejan claro c\u00f3mo estructurar el modelo. Adem\u00e1s algunas cosas quedan fuera de la arquitectura, como es el caso del cambio de pantallas en la aplicaci\u00f3n: t\u00edpicamente habr\u00e1 un MVVM por cada pantalla, pero \u00bfqui\u00e9n decide a d\u00f3nde ir saltando y c\u00f3mo hacerlo?.</p> <p>VIPER (View/Interactor/Presenter/Entity/Router) es una arquitectura que intenta solucionar o al menos abordar estos problemas.</p>"},{"location":"cap10/5_VIPER/#que-es-viper","title":"Qu\u00e9 es VIPER","text":"<p>VIPER es una adaptaci\u00f3n a iOS de la Clean Architecture propuesta por el \"gur\u00fa\" de la ingenier\u00eda del software Robert C. Martin, conocido familiarmente como \"Uncle Bob\". El t\u00edo Bob ha explicado los detalles de su clean architecture en m\u00faltiples ocasiones, por ejemplo en su blog y en algunas charlas. VIPER aparece descrito por primera vez en este art\u00edculo de 2014.</p> <p>Igual que suced\u00eda con los \"controladores ligeros\" en MVC, una de las ideas b\u00e1sicas de la Clean Architecture y por tanto de VIPER es llevar a la pr\u00e1ctica el \"Principio de \u00danica Responsabilidad\".</p>"},{"location":"cap10/5_VIPER/#componentes-de-la-arquitectura","title":"Componentes de la arquitectura","text":"<p>Como hemos enumerado antes, los componentes son los siguientes:</p> <ul> <li>View: muestra los datos que le pasa el presenter, y le pasa a este las acciones del usuario. Como vemos es el mismo papel que desempe\u00f1a en MVP o MVVM.</li> <li>Interactor: es la l\u00f3gica de negocio, los casos de uso de nuestra aplicaci\u00f3n. T\u00edpicamente cada m\u00f3dulo VIPER implementar\u00e1 un caso de uso distinto.</li> <li>Presenter: contiene la l\u00f3gica de presentaci\u00f3n, al igual que en MVP.</li> <li>Entity: los modelos del dominio. Se podr\u00eda decir que contienen la l\u00f3gica de negocio \"gen\u00e9rica\" mientras que el interactor contiene la l\u00f3gica propia de nuestra aplicaci\u00f3n.</li> <li>Router: contiene la l\u00f3gica de navegaci\u00f3n, para saber qu\u00e9 pantallas mostrar y c\u00f3mo cambiar entre ellas. En algunos sitios se conoce tambi\u00e9n como wireframe</li> </ul> <p>Los componentes se comunican entre s\u00ed seg\u00fan se indica en el siguiente diagrama:</p> <p></p>"},{"location":"cap10/5_VIPER/#principios-basicos-de-viper","title":"Principios b\u00e1sicos de VIPER","text":"<p>Adem\u00e1s de los componentes que lo forman y la forma de comunicarse entre ellos, hay unas cuantas ideas adicionales importantes en VIPER.</p> <p>La primera de ellas es que todos los componentes se comunican entre s\u00ed a trav\u00e9s de protocolos (o interfaces, como dir\u00edamos en otros lenguajes). Esto hace posible sustituir una implementaci\u00f3n de un componente por otra sin afectar al resto del componentes. Es decir, seguimos el principio b\u00e1sico del desarrollo software de programar contra interfaces y no contra implementaciones.</p> <p>En la clean architecture original se hablaba de dos tipos de interfaces: input ports y output ports, y en la mayor\u00eda de implementaciones de VIPER se ha conservado esta idea y terminolog\u00eda. Para un componente, su input port lo constituyen las operaciones que \u00e9l implementa, y que ser\u00e1n llamadas desde otros componentes. El output port ser\u00e1n las operaciones que el componente necesita, implementadas por otro componente. Si tenemos dos componentes, A y B, y A necesita de B, el output port de A ser\u00e1 el mismo protocolo o interfaz que el input port de B. </p> <p>La misi\u00f3n de estos output ports es conseguir lo que se llama inversi\u00f3n de dependencias. Veamos qu\u00e9 es esto. Si nos fijamos en el diagrama principal de VIPER veremos que conforme nos movemos de izquierda a derecha vamos yendo de lo m\u00e1s \"concreto\" y poco reutilizable a lo m\u00e1s \"abstracto\", reutilizable e independiente de los APIs de iOS. La vista est\u00e1 totalmente atada a <code>UIKit</code>, mientras que en el otro extremo el <code>Interactor</code> deber\u00eda ser igual para cualquier plataforma, salvo por el hecho de estar escrito en Swift. Si pensamos en los componentes como capas (m\u00e1s internas conforme avanzamos hacia la derecha),  es adecuado que un componente de una capa dependa de los de las capas internas, pero no a la inversa, ya que estar\u00edamos haci\u00e9ndolo depender de \"detalles de implementaci\u00f3n\" que est\u00e1n por debajo de su nivel de abstracci\u00f3n: un ejemplo: cuando el interactor termina su trabajo y debe devolver los datos al presenter tiene que llamarlo para pas\u00e1rselos, pero para no introducir dependencias incorrectas debe hacerlo a trav\u00e9s de un protocolo. Y adem\u00e1s este protocolo deber\u00eda implementarse en el \"paquete\" del interactor, para evitar dependencias directas de c\u00f3digo de interactor a presenter. Este protocolo ser\u00eda el <code>InteractorOutput</code>. Y esto se llama inversi\u00f3n de dependencias porque aunque el interactor llama al presenter en c\u00f3digo no depende de \u00e9l.</p> <p></p> <p>Otra idea importante es qu\u00e9 datos se pasan entre los componentes. Vamos a verlo con un ejemplo. Si estamos haciendo una aplicaci\u00f3n de tareas pendientes probablemente tendremos una entidad llamada <code>Tarea</code>. Por ejemplo, cuando listamos las tareas pendientes las recuperar\u00e1 el interactor (quiz\u00e1 usando Core Data), que se las pasar\u00e1 al presenter (que formatear\u00e1 los datos adecuadamente, por ejemplo las fechas), y este a su vez a la vista para que las muestre en pantalla. Probablemente lo m\u00e1s directo ser\u00eda pasar objetos <code>Tarea</code> de un componente a otro, pero esto tiene el problema de que estamos acopl\u00e1ndolos todos a la entidad, y si cambiamos esta tendremos que cambiar todos los componentes. Por eso en VIPER y en clean architecture se recomienda pasar solamente los datos que se necesiten y adem\u00e1s en un formato ad hoc, t\u00edpicamente <code>structs</code> o tuplas de datos. </p>"},{"location":"cap10/5_VIPER/#ventajas-e-inconvenientes","title":"Ventajas e inconvenientes","text":"<p>Las ventajas de VIPER son las de cualquier arquitectura bien dise\u00f1ada:</p> <ul> <li>Facilita la colaboraci\u00f3n en el equipo de desarrollo, si cada desarrollador se ocupa de un componente separado o un conjunto de componentes.</li> <li>Facilita el mantenimiento de la aplicaci\u00f3n.</li> <li>Hace posible el testing.</li> </ul> <p>Como inconveniente principal est\u00e1 la sobrecarga que supone crear un m\u00ednimo de 5 componentes por cada m\u00f3dulo. Es una arquitectura que para aplicaciones peque\u00f1as o para aplicaciones implementadas por un solo desarrollador quiz\u00e1 presenta una complicaci\u00f3n excesiva.</p>"},{"location":"cap10/6_ejercicios/","title":"6 ejercicios","text":"<p>Tenemos la aplicaci\u00f3n para consultar el tiempo que ya usamos en el m\u00f3dulo de tecnolog\u00edas de desarrollo y queremos cambiarla para que en lugar de usar MVC use MVVM.</p> <p>IMPORTANTE: Abre el <code>.xcworkspace</code>, no el <code>.xcodeproj</code> como habitualmente. Tras abrirlo deber\u00edas ver dos proyectos: el principal <code>Eltiempo</code> y otro \"secundario\" <code>Pods</code> con las librer\u00edas necesarias. Haz un <code>build</code> del proyecto antes de empezar a trabajar con \u00e9l, para que se compile la librer\u00eda Bond y las otras dependencias.</p>"},{"location":"cap10/6_ejercicios/#carpetas-para-los-fuentes","title":"Carpetas para los fuentes","text":"<p>Lo primero ser\u00e1 crear las \"carpetas\" necesarias para los fuentes (o groups como se llaman en Xcode)</p> <ul> <li>Crea un group llamado <code>Vista</code> (<code>File &gt; New group...</code>) y mueve a \u00e9l la clase <code>ViewController</code>, ya que en MVVM el <code>ViewController</code> es parte de la vista.</li> <li>Crear otro group llamado <code>ViewModel</code> y en \u00e9l crear un archivo <code>TiempoViewModel</code> con una clase del mismo nombre vac\u00eda por el momento</li> </ul>"},{"location":"cap10/6_ejercicios/#ensamblaje-de-vista-modelo-y-viewmodel-1-punto","title":"Ensamblaje de vista, modelo y viewmodel (1 punto)","text":"<p>En la clase de la vista (el <code>ViewController</code>) a\u00f1adir una propiedad que represente al viewmodel</p> <pre><code>let viewModel = TiempoViewModel()\n</code></pre> <p>En el <code>TiempoViewModel</code> a\u00f1adir una propiedad que represente al modelo</p> <pre><code>let modelo = TiempoModelo()\n</code></pre>"},{"location":"cap10/6_ejercicios/#mostrar-la-descripcion-del-tiempo-2-puntos","title":"Mostrar la descripci\u00f3n del tiempo (2 puntos)","text":"<p>En este apartado conseguiremos que al pulsar en el bot\u00f3n \"consultar tiempo\" la descripci\u00f3n en modo texto (p.ej. \"sol\") aparezca en la pantalla del dispositivo.</p> <p>En el <code>TiempoViewModel</code></p> <ul> <li>A\u00f1ade un <code>import Bond</code></li> <li>Crear un <code>observable</code> de tipo <code>String</code> llamado <code>estado</code>, con valor inicial la cadena vac\u00eda (mira la sintaxis en transparencias/apuntes)</li> <li>Crea un m\u00e9todo <code>consultarTiempo</code> que admita como par\u00e1metro un <code>String</code> con el nombre de la localidad a consultar</li> </ul> <pre><code>func consultarTiempo(de localidad : String) {\n  //AQUI\n  1. LLama a consultarTiempo del modelo. P\u00e1sale la localidad y como segundo par\u00e1metro una clausura a la que el modelo llamar\u00e1 cuando el servidor devuelva el estado del tiempo. Esta clausura recibe dos par\u00e1metros, el estado del tiempo como una cadena, y otra cadena con la url del icono que lo representa\n  2. Dentro de esa clausura actualiza el observable \"estado\" con el valor del primer par\u00e1metro, m\u00e1s tarde nos ocuparemos del icono \n}\n</code></pre> <p>Ahora en la vista</p> <ul> <li>en el m\u00e9todo consultarTiempoPulsado sustituir la llamada al modelo por</li> </ul> <pre><code>self.viewModel.consultarTiempo(de: loc)\n</code></pre> <ul> <li>en el <code>viewDidLoad()</code> vincular la propiedad <code>estado</code> del <code>viewModel</code> al texto de la etiqueta <code>estadoLabel</code></li> </ul>"},{"location":"cap10/6_ejercicios/#mostrar-el-icono-del-tiempo-2-puntos","title":"Mostrar el icono del tiempo (2 puntos)","text":"<ul> <li>Haz lo mismo para el icono del tiempo, solo que ser\u00e1 m\u00e1s complicado ya que vinculamos un String con un icono (<code>UIImage</code>)</li> <li>Para convertir una String en un icono:</li> <li>Filtrar los Strings con <code>filter</code> solo dejando pasar los distintos de la cadena vac\u00eda</li> <li>Una vez filtrados, usar <code>map</code> para transformar de String-&gt;URL-&gt;Data-&gt;UIImage. En Swift puedes:<ul> <li>llamar al inicializador <code>URL(string:)</code> </li> <li>obtener los datos binarios de una URL con <code>Data(contentsOf:)</code></li> <li>crear un UIImage a partir de datos binarios con <code>UIIMage(data:)</code></li> </ul> </li> </ul>"},{"location":"cap10/6_ejercicios_redux/","title":"6 ejercicios redux","text":"<p>En las plantillas de la sesi\u00f3n tenemos una aplicaci\u00f3n que implementa una \"lista de la compra\" para apuntar cosas pendientes de comprar y que est\u00e1 desarrollada siguiendo el paradigma MVC. Queremos pasarla a Redux con la ayuda de ReSwift.</p> <p>IMPORTANTE: Abre el <code>.xcworkspace</code>, no el <code>.xcodeproj</code> como habitualmente. Tras abrirlo deber\u00edas ver dos proyectos: el principal <code>ListaCompra</code> y otro \"secundario\" <code>Pods</code> con las librer\u00edas adicionales (<code>ReSwift</code> en este caso). Haz un <code>build</code> del proyecto antes de empezar a trabajar con \u00e9l, para que se compilen las dependencias.</p> <p>En todos los archivos que uses la librer\u00eda <code>ReSwift</code> necesitar\u00e1s un </p> <pre><code>import ReSwift\n</code></pre>"},{"location":"cap10/6_ejercicios_redux/#el-estado-05-puntos","title":"El estado (0.5 puntos)","text":"<p>Crea un group llamado <code>State</code> (<code>File &gt; New group...</code>) para guardar el struct que implementa el estado. Por convenio en <code>ReSwift</code> se suele llamar <code>AppState</code>   - Declara que es conforme al protocolo <code>StateType</code>   - A\u00f1\u00e1dele un campo llamado <code>lista</code> de tipo <code>ListaCompra</code></p>"},{"location":"cap10/6_ejercicios_redux/#las-acciones-05-puntos","title":"Las acciones (0.5 puntos)","text":"<p>En el ejercicio \u00fanicamente implementaremos una acci\u00f3n para a\u00f1adir un item a la lista.</p> <p>Crea un group llamado <code>Actions</code> (<code>File &gt; New group...</code>) para guardar un struct <code>AddItem</code> que representar\u00e1 esta acci\u00f3n</p> <ul> <li>Declara que es conforme al protocolo <code>Action</code></li> <li>A\u00f1\u00e1dele un campo de tipo <code>Item</code> para representar el item a\u00f1adido </li> </ul>"},{"location":"cap10/6_ejercicios_redux/#el-reducer-1-punto","title":"El reducer (1 punto)","text":"<p>Crea un group llamado <code>Reducers</code> (<code>File &gt; New group...</code>) para almacenar los reducers. Como es una aplicaci\u00f3n muy sencilla podemos hacerlo todo en un \u00fanico reducer. </p> <p>En el group <code>Reducers</code> crea un archivo <code>AppReducer</code> y en \u00e9l define la funci\u00f3n <code>appReducer(accion: Action, estado: AppState?) -&gt; AppState</code>. Para implementarla puedes ayudarte de las transparencias.</p>"},{"location":"cap10/6_ejercicios_redux/#el-store","title":"El <code>store</code>","text":"<p>T\u00edpicamente se suele definir en el <code>AppDelegate</code> simplemente porque es accesible desde cualquier parte de la aplicaci\u00f3n</p> <pre><code>let store = Store&lt;AppState&gt;(reducer: appReducer, state: nil)\n</code></pre>"},{"location":"cap10/6_ejercicios_redux/#suscribirse-a-los-cambios-de-estado-1-punto","title":"Suscribirse a los cambios de estado (1 punto)","text":"<p>El <code>ListaViewController</code> es el view controller de la pantalla que muestra la lista de notas, y puede encargarse de recibir los cambios de estado.</p> <ul> <li>En la cabecera del <code>ListaViewController</code> indica que es conforme al protocolo <code>StoreSubscriber</code>. Quedar\u00e1:</li> </ul> <pre><code>class ListaViewController: UITableViewController, StoreSubscriber {\n</code></pre> <ul> <li> <p>Al poner el protocolo la clase est\u00e1 \"obligada\" a:</p> </li> <li> <p>Especificar el tipo del estado: Simplemente hay que poner en la clase <code>typealias StoreSubscriberStateType = AppState</code></p> </li> <li>Implementar el m\u00e9todo <code>newState(state:)</code> donde se reciben los cambios de estado. En este m\u00e9todo tendr\u00e1s que hacer</li> </ul> <pre><code>listaDataSource.setLista(state.lista)\nself.tableView.reloadData()\n</code></pre> <p>CAMBIOS DEL CODIGO ANTERIOR: en el m\u00e9todo <code>unwind</code> sobra todo el c\u00f3digo que era el que antes recib\u00eda el nuevo item creado, ahora puedes dejarlo vac\u00edo (pero no lo elimines, si no no se podr\u00e1 volver a esta pantalla desde la de edici\u00f3n del item)</p>"},{"location":"cap10/6_ejercicios_redux/#despachar-las-acciones-1-punto","title":"Despachar las acciones (1 punto)","text":"<p>Todav\u00eda nos falta disparar todo el proceso, es decir, despachar la acci\u00f3n de \"a\u00f1adir item\". Esto tendr\u00e1s que hacerlo desde la pantalla de editar item, controlada por el <code>NuevoItemViewController</code>. En el m\u00e9todo <code>shouldPerformSegue</code>, dentro del <code>if identifier==\"guardar\"</code> a\u00f1ade c\u00f3digo que despache la acci\u00f3n al store. </p> <p>CAMBIOS DEL CODIGO ANTERIOR: elimina la propiedad <code>nuevoItem</code> del controller ,ya no es necesaria, antes era el objeto que tomaba la pantalla principal para a\u00f1adirlo a la lista, pero ahora esta informaci\u00f3n no se la pasa este view controller sino el store.</p> <p>Una vez hecho todo esto la parte de a\u00f1adir ya deber\u00eda estar funcionando con redux.</p>"},{"location":"cap10/6a_ejercicios1/","title":"6a ejercicios1","text":""},{"location":"cap10/6a_ejercicios1/#ejercicios-de-arquitecturas-ios-parte-i","title":"Ejercicios de arquitecturas iOS, parte I","text":"<p>En la aplicaci\u00f3n de Notas que venimos desarrollando en la asignatura, el view controller <code>ListaNotasController</code> tiene demasiadas funcionalidades.</p> <p>(4 puntos) Separa los m\u00e9todos que implementan el datasource de la tabla en una clase aparte:   - Crea la clase <code>ListaNotasDatasource</code>:     - A\u00f1\u00e1dele un m\u00e9todo <code>setLista()</code> que reciba un array de notas (<code>[Nota]</code>) como par\u00e1metro y se lo guarde en una propiedad de la clase llamada <code>listaNotas</code>     - Ll\u00e9vate a esta clase el c\u00f3digo de los m\u00e9todos que implementan el datasource   - En el <code>ListaNotasViewController</code>     - A\u00f1ade una propiedad  <code>ds</code>, de tipo <code>ListaNotasDataSource</code>      - En el <code>viewDidLoad</code>, haz que el <code>ds</code> sea el datasource de la tabla</p> <pre><code>```swift\nself.tableView.dataSource = self.ds\n```\n\n- En el `viewWillAppear`, cada vez que obtengas la lista de notas con el *fetch request*, p\u00e1saselas al `ds`, con `ds.setLista()`\n- La propiedad `listaNotas` del `ListaNotasViewController` ya sobra, porque la lista ahora la maneja el *datasource*\n</code></pre> <p>(1 punto) En el <code>ListaNotasDatasource</code> separa el c\u00f3digo que se encarga de rellenar los campos de la celda y encaps\u00falalo en una clase aparte igual que se muestra en las transparencias</p>"},{"location":"cap10/intro/","title":"Intro","text":"<p>En este tema veremos algo que no est\u00e1 directamente relacionado con la persistencia, pero que es pertinente en este punto del curso. Hasta ahora hemos visto multitud de tecnolog\u00edas para desarrollar aplicaciones en iOS, pero una cosa que nos falta es saber c\u00f3mo estructurar el c\u00f3digo de la aplicaci\u00f3n para hacerlo lo m\u00e1s claro, mantenible y testable que sea posible. </p> <p>Ya vimos al comienzo del curso que la arquitectura recomendada por Apple es Modelo/Vista/Controlador, pero aunque es muy apropiada para ejemplos y para aplicaciones peque\u00f1as, con aplicaciones m\u00e1s grandes presenta algunos problemas. Primero veremos cu\u00e1les son estos problemas y c\u00f3mo solucionarlos aunque sea parcialmente y luego abordaremos otras arquitecturas que se han propuesto como alternativas al cl\u00e1sico MVC.</p>"},{"location":"cap10/notas/","title":"Notas","text":"<ul> <li> <p>Los problemas de MVC</p> <ul> <li>MVC de Apple: expectativa vs. realidad</li> <li>Adelgazar controladores. \u00bfPero d\u00f3nde ponemos el c\u00f3digo que sobra?</li> </ul> </li> <li> <p>MVx</p> </li> <li> <p>Viper</p> </li> <li> <p>Arquitecturas reactivas</p> </li> </ul>"},{"location":"cap10/notas/#referencias","title":"Referencias","text":""},{"location":"cap10/notas/#mvp","title":"MVP","text":"<ul> <li>http://iyadagha.com/using-mvp-ios-swift/</li> <li>https://ios.james.ooo/model-view-controller-presenter-8bb4149fa5ef#.b63z6tbjy</li> </ul>"},{"location":"cap11/1_introduccion_BAAS/","title":"1 introduccion BAAS","text":"<p>Aunque hay algunas aplicaciones que pueden funcionar por s\u00ed solas sin necesidad de un servidor, muchas aplicaciones actuales necesitan de un backend para poder almacenar datos \u201cen la nube\u201d. As\u00ed el usuario pueda acceder a su informaci\u00f3n independientemente del dispositivo que est\u00e9 usando. Otras muchas aplicaciones lo usan para que se pueda compartir informaci\u00f3n con otros usuarios.  </p> <p>El problema es que desarrollar un backend para una aplicaci\u00f3n m\u00f3vil no es una tarea trivial, incluso si se tienen los conocimientos necesarios. Hay que escribir la aplicaci\u00f3n en el lado del servidor, desplegarla, alojarla en alg\u00fan hosting, hacerla escalable, \u2026. Y adem\u00e1s muchos desarrolladores de aplicaciones m\u00f3viles no tienen las habilidades necesarias, ya que en el backend se usan lenguajes, tecnolog\u00edas y herramientas totalmente diferentes de los usados para el desarrollo del cliente.</p> <p>Esto ha hecho que surja un mercado de lo que se conoce como \u201cBackend as a Service\u201d (o BaaS), es decir, ofrecer como servicio \u201clisto para usar\u201d las funcionalidades m\u00e1s t\u00edpicas de los backends para aplicaciones m\u00f3viles: autentificaci\u00f3n de usuarios, persistencia de datos \u201cen la nube\u201d, anal\u00edticas de tr\u00e1fico, notificaciones push etc. Por supuesto las propias plataformas de desarrollo m\u00f3vil ya ofrecen algunos de estos servicios (por ejemplo Apple ofrece persistencia \u201cen la nube\u201d con iCloud), pero ha surgido una serie de compa\u00f1\u00edas que ofrecen estos servicios con compatibilidad multiplataforma, de modo que por ejemplo podemos acceder a los mismos datos remotos estemos en la versi\u00f3n iOS, en la versi\u00f3n Android o incluso en la versi\u00f3n web de la aplicaci\u00f3n.</p> <p>En la actualidad existen m\u00faltiples plataformas de terceros que ofrecen funcionalidades de Baas. Vamos a centrarnos aqu\u00ed en Firebase simplemente porque es una de las m\u00e1s conocidas y porque es multiplataformas. El resto de plataformas ofrecen funcionalidades similares.</p> <p>Para usar Firebase lo primero es darse de alta en la plataforma. Una vez dados de alta, podremos crear proyectos en Firebase. Un proyecto es una app con un conjunto de usuarios, una base de datos, un espacio para alojar archivos, etc. Esta app Firebase puede tener varios clientes: iOS, Android, web, ...</p> <p>Para crear una aplicaci\u00f3n iOS que act\u00fae como cliente de nuestro proyecto de Firebase podemos seguir las instrucciones de Google: c\u00f3mo agregar Firebase a tu proyecto de iOS. Las instrucciones est\u00e1n bastante detalladas y adem\u00e1s traducidas a espa\u00f1ol. </p>"},{"location":"cap11/2_gestion_usuarios/","title":"2 gestion usuarios","text":"<p>La gran mayor\u00eda de aplicaciones tiene que gestionar datos de usuarios y autentificarlos para poder realizar ciertas operaciones. T\u00edpicamente vamos a tener que:</p> <ul> <li>Implementar un CRUD de usuarios, para poder darlos de alta, de baja y que puedan modificar sus datos de perfil.</li> <li>Implementar funcionalidades de login/logout para que el usuario se pueda autentificar en la aplicaci\u00f3n y as\u00ed tenga acceso a las funcionalidades que la requieran.</li> </ul> <p>Firebase cubre los dos tipos de funcionalidades. Adem\u00e1s no solo vamos a poder gestionar usuarios d\u00e1ndolos de alta en la aplicaci\u00f3n con login y password, sino que tambi\u00e9n nos permite autentificaci\u00f3n con credenciales externas, o identidad federada: el usuario puede identificarse en nuestra app con su login de otros sitios como Facebook, Twitter o Google, con lo que se evita tener que crearse un nuevo usuario/contrase\u00f1a solo para nuestra aplicaci\u00f3n.</p>"},{"location":"cap11/2_gestion_usuarios/#anadir-autentificacion-a-una-app-de-firebase","title":"A\u00f1adir autentificaci\u00f3n a una app de Firebase","text":"<p>Las funcionalidades de usuarios est\u00e1n en el m\u00f3dulo <code>auth</code>. Si usamos Cocoapods para gestionar las dependencias, tendremos que a\u00f1adir la siguiente dependencia al <code>Podfile</code></p> <pre><code>pod 'Firebase/Auth'\n</code></pre> <p>tras ello, ejecutar en la consola <code>pod install</code>.</p> <p>Para poder llamar a este API en nuestro c\u00f3digo necesitaremos un </p> <pre><code>import Firebase\n</code></pre> <p>Pod\u00e9is consultar online y traducida al espa\u00f1ol la documentaci\u00f3n de las librer\u00edas de iOS para gesti\u00f3n de usuarios y autentificaci\u00f3n.</p>"},{"location":"cap11/2_gestion_usuarios/#administracion-de-usuarios","title":"Administraci\u00f3n de usuarios","text":"<p>Los usuarios en Firebase tienen una serie de propiedades b\u00e1sicas: un id \u00fanico, una direcci\u00f3n de correo electr\u00f3nico, un nombre y la URL de su foto de perfil. Todos los usuarios tienen estos datos, aunque podemos simplemente ignorar alguno en nuestra app (por ejemplo la URL). A los objetos usuario no se les pueden a\u00f1adir m\u00e1s propiedades, si necesitamos m\u00e1s datos (fecha de nacimiento, sexo, e-mail secundario,...) tendremos que almacenarlos aparte en la base de datos de Firebase.</p> <p>Aunque Firebase permite que los usuarios puedan autentificarse con credenciales de Google, Facebook, Twitter, ... aqu\u00ed solo veremos la autentificaci\u00f3n con contrase\u00f1a, es decir, los usuarios van a darse de alta en nuestra app y elegir un login (que debe ser su email) y un password. passwors no lo podremos consultar desde nuestra app, solo modificar). Para ver c\u00f3mo autentificarse con identidades federadas, consultar la documentaci\u00f3n de Firebase</p> <p>Como veremos, la mayor\u00eda de m\u00e9todos del API son as\u00edncronos, ya que requieren de interacci\u00f3n con el servidor y hacerlos s\u00edncronos bloquear\u00eda la app hasta que este respondiera. Los m\u00e9todos as\u00edncronos del API tienen como \u00faltimo par\u00e1metro  una clausura que se ejecutar\u00e1 cuando el servidor complete la operaci\u00f3n. </p> <p>La clausura a ejecutar recibe como par\u00e1metro un error en caso de haberse producido alguno, y adem\u00e1s en algunos m\u00e9todos recibe un par\u00e1metro adicional con el resultado de la operaci\u00f3n si ha sido exitoso.</p>"},{"location":"cap11/2_gestion_usuarios/#dar-de-alta-usuarios","title":"Dar de alta usuarios","text":"<p>Para dar de alta un usuario llamaremos al m\u00e9todo <code>createUser(withEmail:,password:,completion:)</code>. Es un m\u00e9todo as\u00edncrono, su \u00faltimo par\u00e1metro es una clausura que se ejecutar\u00e1 cuando se complete en el servidor el proceso de registro. Como ya se ha dicho esta clausura recibe como par\u00e1metro el error producido, si lo hay. Si no ha habido error, adem\u00e1s como primer par\u00e1metro se recibe un objeto de tipo <code>AuthDataResult</code> con el resultado de la operaci\u00f3n. Dentro de este objeto el campo <code>user</code> contiene informaci\u00f3n sobre el usuario reci\u00e9n creado. </p> <p>Por ejemplo:</p> <pre><code>Auth.auth().createUser(withEmail: email, password: password) { \n    (result, error) in\n    if let error = error {\n        print(\"Error\")\n    }\n    else {\n        print(\"Dado de alta usuario con email: \\(result?.user.email!)\")\n    }\n}\n</code></pre> <p>Como es l\u00f3gico, antes de poder llamar a este m\u00e9todo tenemos que haber hecho alg\u00fan formulario para que el usuario rellene sus datos, pedirle dos veces la contrase\u00f1a para chequear errores, etc. Esto es tarea nuestra y de ello no se va a ocupar <code>createUser</code>. Llamaremos a este m\u00e9todo solo cuando hayamos validado que los datos introducidos por el usuario son correctos (que el email no est\u00e1 vac\u00edo y tiene un formato adecuado, que los dos passwords del formulario coinciden, ...).</p> <p>Como crear las pantallas de alta, login, etc es un proceso tedioso, en Firebase existe un m\u00f3dulo denominado <code>FirebaseUI</code> que implementa la interfaz de las operaciones m\u00e1s comunes. Pod\u00e9is consultar m\u00e1s informaci\u00f3n en la documentaci\u00f3n de Firebase.</p> <p>N\u00f3tese adem\u00e1s que el <code>createUser</code> solo rellena los datos m\u00e1s b\u00e1sicos, para rellenar el resto de datos usaremos la funcionalidad de actualizar perfil.</p>"},{"location":"cap11/2_gestion_usuarios/#validar-el-alta-de-un-usuario","title":"Validar el alta de un usuario","text":"<p>En muchos sitios web cuando un usuario se da de alta se le env\u00eda por email un link para que confirme el registro. En Firebase podemos hacer esto con el m\u00e9todo <code>sendEmailVerification</code> del usuario actual. Este m\u00e9todo pertenece al usuario autentificado .</p> <p>Para obtener el usuario autentificado actualmente en la app accedemos a la propiedad <code>Auth.auth().currentUser</code>. Si es <code>nil</code> no hay ning\u00fan usuario autentificado.</p> <pre><code>Auth.auth().currentUser?.sendEmailVerification { (error) in\n  // ...\n}\n</code></pre>"},{"location":"cap11/2_gestion_usuarios/#modificar-el-perfil-de-un-usuario","title":"Modificar el perfil de un usuario","text":"<p>Para modificar los datos de un usuario, el objeto usuario correspondiente debe llamar a <code>createProfileChangeRequest</code>, hacemos los cambios y finalmente llamamos a <code>commitChanges(completion:)</code>, que es as\u00edncrono, y al que se le pasa una clausura a ejecutar cuando los cambios se hagan efectivos en el servidor. </p> <pre><code>let changeRequest = Auth.auth().currentUser?.createProfileChangeRequest()\nchangeRequest?.displayName = displayName\nchangeRequest?.commitChanges { (error) in\n  if let error = error {\n     print(\"Error: \\(error)\")\n  } \n  else {\n     print(\"Perfil actualizado OK\")\n  }\n}\n</code></pre> <p>Hay m\u00e9todos individuales para actualizar el email y el password: <code>updateEmail</code> y <code>updatePassword</code>. Son m\u00e9todos as\u00edncronos, y como par\u00e1metro, adem\u00e1s del nuevo valor, pasaremos una clausura a ejecutar cuando acabe la operaci\u00f3n:</p> <pre><code>Auth.auth().currentUser?.updateEmail(to: email) { (error) in\n  // ...\n}\nAuth.auth().currentUser?.updatePassword(to: password) { (error) in\n  // ...\n}\n</code></pre> <p>Por razones de seguridad, cuando un usuario cambia su direcci\u00f3n de correo electr\u00f3nico, se le env\u00eda un email a la su direcci\u00f3n  para que pueda consultar el cambio. Se puede cambiar la plantilla que se usa para este email en la consola de Firebase, en el apartado: <code>Autenticaci\u00f3n &gt; Plantillas</code>.</p> <p>En lugar de actualizar el password directamente, podemos enviarle al usuario el t\u00edpico mensaje de resetear password, con un enlace en el que se hace clic se saltar\u00e1 a una p\u00e1gina (hecha por Google) con un formulario para cambiar el password.  </p>"},{"location":"cap11/2_gestion_usuarios/#dar-de-baja-a-un-usuario","title":"Dar de baja a un usuario","text":"<p>Para borrar a un usuario, usamos <code>delete</code>, que de nuevo es un m\u00e9todo as\u00edncrono:</p> <pre><code>let user = Auth.auth().currentUser\nuser?.delete { error in\n  if let error = error {\n    print(\"Error\")\n  } else {\n    print(\"Cuenta dada de baja\")\n  }\n}\n</code></pre>"},{"location":"cap11/2_gestion_usuarios/#autentificacion","title":"Autentificaci\u00f3n","text":"<p>Para hacer login en la aplicaci\u00f3n, llamamos al m\u00e9todo <code>signIn</code>, que como viene siendo habitual es as\u00edncrono. Si la autentificaci\u00f3n tiene \u00e9xito se devuelve un objeto de tipo <code>AuthDataResult</code> que contiene entre otros datos la referencia al usuario autentificado en su campo <code>user</code>.</p> <pre><code>Auth.auth().signIn(withEmail: email, password: password) { \n  (result, error) in\n  if let error = error {\n    print(\"Error\")\n  } else {\n    print(\"Login de: \\(result?.user.email!)\")\n  }\n}\n</code></pre> <p>como ya hemos visto en el apartado anterior, para saber el usuario actual podemos acceder a <code>Auth.auth().currentUser</code>.</p> <p>Hay que destacar que la \"sesi\u00f3n\" actual se guarda de manera persistente, as\u00ed que si salimos de la aplicaci\u00f3n y volvemos a entrar, el usuario seguir\u00e1 estando activo hasta que cerremos expl\u00edcitamente la sesi\u00f3n. Para cerrar la sesi\u00f3n, llamar al m\u00e9todo <code>signOut</code>, que es s\u00edncrono:</p> <pre><code>do {\n  try Auth.auth().signOut()\n} catch let signOutError as NSError {\n  print(\"Error cerrando la sesi\u00f3n: \\(signOutError)\")\n}\n</code></pre> <p>Podemos detectar el sign-in y sign-out del usuario con <code>addStateDidChangeListener</code>. Le pasaremos una clausura que se ejecutar\u00e1 cuando se haga una de estas dos operaciones, es decir, es un listener del cambio de estado. T\u00edpicamente se usa para mostrar el estado actual en la interfaz de usuario, por lo que normalmente se a\u00f1adir\u00e1 el listener al mostrar la pantalla con los datos, es decir en el <code>viewWillAppear</code> del controlador de la vista:</p> <pre><code>//donde \"handle\" ser\u00eda una propiedad del view controller\nself.handle = Auth.auth().addStateDidChangeListener { (auth, user) in\n  // ...\n}\n</code></pre> <p>El valor de retorno del m\u00e9todo anterior se usa para eliminar el listener. Habitualmente el lugar m\u00e1s apropiado es cuando salimos de la pantalla, en el <code>viewWillDisappear</code>) del controlador de la vista:</p> <p><code>`swift Auth.auth().removeStateDidChangeListener(self.handle)</code></p>"},{"location":"cap11/3_persistencia/","title":"3 persistencia","text":"<p>Actualmente hay dos bases de datos disponibles en Firebase: la realtime database, que es la \"original\" y el cloud firestore, que se introdujo posteriormente. Ambas son bases de datos NoSQL, aunque la realtime tiene una estructura de datos algo m\u00e1s peculiar. Vamos a ver aqu\u00ed la realtime database, que como su nombre indica es especialmente apropiada para aplicaciones en tiempo real, ya que adem\u00e1s de poder hacer las t\u00edpicas consultas podemos \"escuchar\" los cambios en los datos. No obstante se puede usar en cualquier tipo de aplicaci\u00f3n.</p> <p>Pod\u00e9is consultar online y traducida al espa\u00f1ol la documentaci\u00f3n de los APIs de iOS para la realtime database.</p>"},{"location":"cap11/3_persistencia/#estructurar-los-datos","title":"Estructurar los datos","text":"<p>Como ya hemos comentado, las dos bases de datos disponibles en Firebase son NoSQL. Esto quiere decir que los datos no tienen la divisi\u00f3n habitual en tablas a la que estamos acostumbrados en bases de datos relacionales. La base de datos tampoco se ocupa de comprobar autom\u00e1ticamente la consistencia o la integridad de los datos, quedando esta tarea en manos de la aplicaci\u00f3n.</p> <p>En la realtime database todos los datos est\u00e1n contenidos en un \u00fanico \"\u00e1rbol\" de pares clave-valor. Los valores pueden ser primitivos (n\u00fameros, cadenas o valores booleanos) o pueden ser valores compuestos a su vez de pares clave-valor.  Por ejemplo podr\u00edamos tener algo como:</p> <pre><code>{\n    \"personas\" : {\n        \"jap2\" : {\n            \"nombre\" : \"Juan\",\n            \"apellidos\": \"Arriquitaun P\u00e9rez\"\n        },\n        \"ems21\" : {\n            \"nombre\" : \"Eva\",\n            \"apellidos\": \"Mar\u00edn Salgado\"\n        }\n    }\n}\n</code></pre> <p>En este caso el \u00e1rbol contiene un \u00fanico par clave/valor en su nivel superior. El valor asociado a la clave \"personas\" es compuesto y consiste de dos pares cuyas claves son \"jap2\" y \"ems21\", y as\u00ed sucesivamente. N\u00f3tese que la clave se separa del valor por \":\", que un par se separa del siguiente con una coma y que los valores compuestos se delimitan entre llaves. Es decir, es un formato de datos muy similar a JSON, aunque en JSON se pueden representar listas de datos con <code>[]</code> y esa posibilidad no existe aqu\u00ed. </p> <p>N\u00f3tese que, al contrario que en las bases de datos relacionales no existe un esquema inicial que restrinja el formato de los datos. Mientras se respete la estructura b\u00e1sica de pares clave/valor los datos tienen un formato libre. Por ejemplo no necesariamente tendr\u00edamos que tener propiedad \"nombre\" para todas las personas de la BD, o podr\u00edamos tener alguna propiedad m\u00e1s para algunas personas s\u00ed y para otras no.</p> <p>Al no existir tablas ni relaciones entre ellas, la forma m\u00e1s habitual de representar las relaciones entre datos es \"embeber\" unos datos dentro de otros. Por ejemplo:</p> <pre><code>{\n  \"personas\" : {\n    \"ems21\" : {\n      \"apellidos\" : \"Mar\u00edn Salgado\",\n      \"nombre\" : \"Eva\",\n      \"mensajes\" : {\n        \"m1\" : {\n          \"texto\" : \"Hola amigos\",\n          \"timestamp\" : 19029898493\n        },\n        \"m2\" : {\n          \"texto\" : \"\u00bfNo me contesta nadie? :(\",\n          \"timestamp\" : 20458569556\n        }\n      }\n    },\n    \"jap2\" : {\n      \"apellidos\" : \"Arriquitaun P\u00e9rez\",\n      \"direccion\" : {\n        \"calle\" : \"Pez, 25\",\n        \"localidad\" : \"Madrid\"\n      },\n      \"mensajes\" : {\n        \"m3\" : {\n            \"texto\": \"Hola, s\u00ed!!\"\n            \"timestamp\" : 21020129382\n        }\n      },\n      \"nombre\" : \"Juan\"\n    }\n  }\n}\n</code></pre> <p>En el c\u00f3digo anterior podemos ver algunos de ejemplos de lo que en bases de datos relaciones ser\u00edan precisamente relaciones. Por un lado una relaci\u00f3n 1:1 entre \"persona\" y \"direccion\", que se reperesenta aqu\u00ed con la propiedad compuesta \"direccion\" dentro de la persona. Por otro lado una relaci\u00f3n 1:N entre \"persona\" y \"mensajes\", que se representa de la misma forma, guardando los \"mensajes\" dentro de la \"persona\".</p> <p>El problema de las estructuras de datos anidadas es a la hora de sacar la informaci\u00f3n de la BD. Como veremos, con Firebase podemos listar y filtrar de forma sencilla todos los nodos hijos de un nodo dado (por ejemplo obtener todos los mensajes de la persona \"ems21\" ordenados por timestamp). El problema lo tendr\u00edamos si quisi\u00e9ramos obtener una lista de todos los mensajes independientemente de qui\u00e9n los ha enviado, que con la estructura de datos anterior requerir\u00eda ejecutar una consulta por cada usuario para finalmente unir todos los resultados y ordenarlos.</p> <p>Este problema se puede resolver desnormalizando los datos, es decir, duplicando la informaci\u00f3n. Adem\u00e1s de la estructura anterior podr\u00edamos tener repetidos por otro lado todos los mensajes dentro de un nodo \"mensajes\" independientemente de qui\u00e9n los haya enviado:</p> <pre><code>{\n  \"personas\" : {\n    //Igual que antes, personas con sus mensajes\n  }\n  \"mensajes\" : {\n    //Aqu\u00ed todos los mensajes de todos los usuarios\n  }\n\n}\n</code></pre>"},{"location":"cap11/3_persistencia/#referencias","title":"Referencias","text":"<p>Un concepto fundamental y necesario para poder leer y escribir datos es el de referencia. Una referencia representa un nodo del \u00e1rbol de datos. Con los m\u00e9todos del API podemos obtener directamente una referencia a un nodo cualquiera si conocemos su path desde la ra\u00edz. O bien podemos partir de una referencia que ya tengamos a un nodo y movernos a uno de sus hijos. Una vez obtenida la referencia al nodo que nos interesa, podremos leer su estado/modificarlo con otros m\u00e9todos del API.</p> <p>Por ejemplo supongamos que tenemos la estructura de datos en Firebase que vimos en el apartado anterior.</p> <pre><code>{\n    \"personas\" : {\n        \"jap2\" : {\n            \"nombre\" : \"Juan\",\n            \"apellidos\": \"Arriquitaun P\u00e9rez\"\n        },\n        \"ems21\" : {\n            \"nombre\" : \"Eva\",\n            \"apellidos\": \"Mar\u00edn Salgado\"\n        }\n    }\n}\n</code></pre> <p>Para obtener una referencia a un nodo, lo primero es obtener la base de datos en s\u00ed, a la que accedemos con <code>Database.database()</code>. A partir de aqu\u00ed:</p> <ul> <li>El nodo ra\u00edz lo podemos obtener con <code>reference()</code>, y podemos ir bajando por los hijos con <code>child()</code>, por ejemplo:</li> </ul> <pre><code>//El \u00e1rbol completo, dicho de otro modo el nodo ra\u00edz\nlet rootRef = Database.database().reference()\n//El nodo \"personas\"\nlet personasRef = rootRef.child(\"personas\")\n//El nodo \"nombre\" perteneciente a \"jap2\"\nlet nombreRef = personasRef.child(\"jap2\").child(\"nombre\")\n</code></pre> <ul> <li>Tambi\u00e9n podemos acceder a un nodo con su path desde el nodo ra\u00edz, para ello usamos el m\u00e9todo <code>reference(withPath:)</code>, por ejemplo:</li> </ul> <pre><code>let db = Database.database()\n//El nodo \"nombre\" perteneciente a \"jap2\"\nlet nombreRef = db.reference(withPath:\"personas/jap2/nombre\")\n</code></pre> <p>N\u00f3tese que podemos obtener una referencia a un nodo aunque este no exista todav\u00eda en la base de datos. Por ejemplo, esto ser\u00eda v\u00e1lido en el ejemplo que estamos siguiendo, aunque en la BD no hay nada relativo a pedidos:</p> <pre><code>let ref = db.reference(withPath(\"pedidos/1\"))\n</code></pre> <p>Esto nos permitir\u00e1 crear un nuevo pedido cuyos datos sean hijos del nodo \"pedidos/1\" sin necesidad de haber creado previamente los nodos intermedios.</p>"},{"location":"cap11/3_persistencia/#crear-y-actualizar-datos","title":"Crear y actualizar datos","text":"<p>Para modificar un nodo usamos <code>setValue(&lt;nuevovalor&gt;)</code> sobre su referencia. Este m\u00e9todo es destructivo, ya que sustituye completamente el valor actual del nodo, incluso aunque este tenga otros nodos hijos. Por ejemplo:</p> <pre><code>let db = Database.database()\nlet nombreRef = db.reference(withPath:\"personas/jap2/nombre\")\n//El nombre cambia de Juan a John\nnombreRef.setValue(\"John\")\n//CUIDADO, sustituye el valor de \"personas\", con todo lo que hay por debajo\nlet personasRef = db.reference(withPath:\"personas\")\npersonasRef.setValue(\"La que has liao, pollito\")\n</code></pre> <p>N\u00f3tese que el segundo cambio modifica el valor de un nodo compuesto, sustituyendo todo lo que hay \"por debajo\", as\u00ed que el \u00e1rbol quedar\u00eda</p> <pre><code>{\n    \"personas\" : \"La que has liao, pollito\"\n}\n</code></pre> <p>Tambi\u00e9n podemos crear un nodo aunque los nodos intermedios no existan</p> <pre><code>self.db = Database.database()\n//Este nodo no existe, pero vamos a usar la referencia para crear un valor\nlet mlmj15 = db.reference(withPath: \"personas/mlmj15\")\nmlmj15.setValue([\"nombre\":\"Mar\u00eda Luisa\", \"apellidos\":\"Mar\u00edn Ju\u00e1rez\"])\n</code></pre> <p>El resultado ser\u00eda:</p> <pre><code>{\n  \"personas\" : {\n    \"mlmj15\" : {\n      \"apellidos\" : \"Mar\u00edn Ju\u00e1rez\",\n      \"nombre\" : \"Mar\u00eda Luisa\"\n    }\n  }\n}\n</code></pre> <p>En los ejemplos anteriores hemos asignado un nuevo valor que es un dato primitivo, pero tambi\u00e9n podr\u00eda ser asignar un valor compuesto, basta con pasar un diccionario. Por ejemplo, Podr\u00edamos cambiar los datos de \"mlmj15\" con:</p> <pre><code>let db = Database.database()\nlet ref = db.reference(withPath:\"personas/mlmj15\")\nref.setValue([\"nombre\":\"Mari Loli\", \"apellidos\":\"Mart\u00ednez Ja\u00e9n\"])\n</code></pre> <p>En lugar de sobreescribir totalmente un nodo podemos actualizar solo algunas de sus propiedades con <code>updateChildValues</code></p> <pre><code>let db = Database.database()\nlet ref = db.reference(withPath:\"personas/mlmj15\")\nref.updateChildValues([\"nombre\":\"M.L.\"])\n</code></pre> <p>En este ejemplo estamos usando un identificador generado manualmente para cada persona, pero en muchos casos necesitaremos generar el identificador autom\u00e1ticamente. Podemos hacerlo con <code>childByAutoId</code>.</p> <pre><code>let db = Database.database()\nlet personasRef = db.reference(withPath:\"personas\")\nlet nuevoIdRef = personasRef.childByAutoId()\nnuevoIdRef.setValue([\"nombre\":\"Luis Ricardo\", \"apellidos\":\"Borriquero\"])\n</code></pre> <p>quedando algo como:</p> <pre><code>{\n  \"personas\" : {\n    \"L33iv1bhzKkFkQd_ff4\" : {\n      \"apellidos\" : \"Borriquero\",\n      \"nombre\" : \"Luis Ricardo\"\n    },\n    ...\n  }\n}\n</code></pre> <p>El algoritmo de generaci\u00f3n de ids asegura que no va a haber colisiones entre los identificadores generados por los distintos clientes. Adem\u00e1s el id incluye un timestamp, de modo que si ordenamos por id estamos ordenando impl\u00edcitamente por orden de inserci\u00f3n en la base de datos.</p> <p>Finalmente, podemos borrar datos con <code>removeValue()</code>. Tambi\u00e9n podr\u00edamos hacer <code>setValue(nil)</code>, o poner a <code>nil</code> alguna propiedad en <code>updateChildValues</code>.</p>"},{"location":"cap11/3_persistencia/#consultas","title":"Consultas","text":"<p>La realtime Database, como su propio nombre indica, tiene funcionalidades apropiadas para aplicaciones que necesitan datos en tiempo real. En concreto podemos escuchar los cambios en los datos. Como luego veremos podemos usar este API tambi\u00e9n para hacer consultas al estilo m\u00e1s cl\u00e1sico, que simplemente devuelvan el estado actual de la BD.</p> <p>Para observar los cambios en los datos de un nodo, incluyendo tambi\u00e9n todos los nodos que hay \"por debajo\", podemos usar <code>observe(_,withBlock:)</code>, donde el \u00faltimo par\u00e1metro es una clausura a ejecutar cuando se produzca el evento. Por ejemplo:</p> <pre><code>let db = Database.database()\nlet personasRef = db.reference(withPath:\"personas\")\npersonasRef.observe(.value) {\n    snapshot in\n    print(\"Algo ha cambiado en \\(snapshot.value)\")\n}\n</code></pre> <p>El par\u00e1metro de la clausura es un objeto de tipo <code>DataSnapshot</code>, que representa un snapshot de un fragmento de datos en un determinado momento.</p> <p>Hay que llevar cuidado con el nivel en el que estamos escuchando, ya que se detectar\u00e1 cualquier cambio en los niveles que hay por debajo y esto puede ser costoso para los niveles superiores del \u00e1rbol.</p> <p>La clausura se llamar\u00e1 una vez con el valor actual de la BD y a partir de ese momento, de nuevo cada vez que se produzca un cambio. Para dejar de \"escuchar\" los cambios podemos usar <code>removeObserverWithHandle()</code>. A este m\u00e9todo hay que pasarle el handle del listener creado por <code>observe</code>. Este handle lo devuelve el m\u00e9todo observe, aunque en el ejemplo anterior hemos ignorado el valor. De modo que har\u00edamos algo como:</p> <pre><code>...\n//a\u00f1adimos el \"listener\" y nos guardamos el handle\nlet handle = personasRef.observe(.value) {\n    ...\n}\n//eliminamos el \"listener\" anterior usando el handle\npersonasRef.removeObserver(withHandle: handle)\n//tambi\u00e9n podr\u00edamos hacer esto para eliminar todos los listener sobre personasRef\npersonasRef.removeAllObservers()\n</code></pre> <p>Podemos escuchar otros eventos, no solo los cambios de valor. En concreto, podemos saber cu\u00e1ndo ha cambiado alg\u00fan hijo de un nodo dado (ha sido a\u00f1adido, modificado o borrado). En ese caso el snapshot solo contendr\u00e1 el nodo que ha cambiado. Por ejemplo, as\u00ed podr\u00edamos saber si ha sido insertado un nuevo nodo que sea hijo del nodo \"personas\":</p> <pre><code>self.db = Database.database()\nlet personasRef = db.reference(withPath:\"personas\")\npersonasRef.observe(.childAdded) {\n   snapshot in\n   print(\"\\(snapshot.key)=\\(snapshot.value)\")\n}\n</code></pre> <p>Tambi\u00e9n podemos hacer consultas m\u00e1s cl\u00e1sicas, en las que simplemente queremos conocer el estado actual de la base de datos pero no nos interesan los sucesivos cambios. Podemos hacerlo sustituyendo <code>observe</code> por <code>observeSingleEvent</code>. Por lo dem\u00e1s el c\u00f3digo es igual:</p> <pre><code>self.db = Database.database()\nlet personasRef = db.reference(withPath:\"personas\")\npersonasRef.observeSingleEvent(.childAdded) {\n   snapshot in\n   print(\"\\(snapshot.key)=\\(snapshot.value)\")\n}\n</code></pre>"},{"location":"cap11/4_ejercicios/","title":"4 ejercicios","text":"<p>En las plantillas de la sesi\u00f3n hay un proyecto Xcode con las librer\u00edas de Firebase ya instaladas y configuradas. El proyecto est\u00e1 vinculado con una aplicaci\u00f3n ya dada de alta en el servidor de Firebase.</p> <p>IMPORTANTE: para trabajar con el proyecto, abrir el <code>.xcworkspace</code>, NO el <code>.xcodeproj</code> que abrimos habitualmente. Al abrir el workspace ver\u00e9is dos proyectos, uno con la app en s\u00ed, llamado <code>ChatFirebase</code> y otro con las librer\u00edas auxiliares llamado <code>pods</code>. Tras abrir el workspace lo primero que deber\u00edais hacer es <code>Product &gt; Build</code>.</p> <p>El objetivo es desarrollar un peque\u00f1o chat con la realtime database. La plantilla ya tiene la interfaz hecha y hay que a\u00f1adirle el c\u00f3digo de Firebase.</p>"},{"location":"cap11/4_ejercicios/#loginlogout-05-puntos","title":"Login/logout (0,5 puntos)","text":"<p>La aplicaci\u00f3n usa una cuenta de Firebase que ya est\u00e1 dada de alta en Google, los alumnos del m\u00e1ster est\u00e1is a\u00f1adidos como usuarios con vuestro email de <code>alu.ua.es</code> que es tanto vuestro login en la app como la contrase\u00f1a. Probad esta secci\u00f3n con esas credenciales. Si no os funciona avisad al profesor, es posible que haya alg\u00fan problema con vuestro usuario de Firebase en el servidor.</p>"},{"location":"cap11/4_ejercicios/#pantalla-inicial","title":"Pantalla inicial:","text":"<p>En la pantalla inicial de la app hay un formulario para hacer login. A\u00f1ade el c\u00f3digo necesario para que cuando se pulse sobre el bot\u00f3n \"Entrar\" se haga login en Firebase. </p> <p>Si el login ha tenido \u00e9xito habr\u00e1 que saltar a la segunda pantalla por el segue llamado \"login\"</p> <pre><code>performSegue(withIdentifier:\"login\", sender:self)\n</code></pre>"},{"location":"cap11/4_ejercicios/#segunda-pantalla","title":"Segunda pantalla","text":"<p>En el outlet <code>usuarioLabel</code> deber\u00eda aparecer el login del usuario que se ha autentificado.</p> <p>A\u00f1ade el c\u00f3digo necesario para mostrar el email del usuario actual de Firebase en el <code>usuarioLabel</code>. Puedes hacerlo en el m\u00e9todo <code>viewWillAppear</code> del <code>ChatViewController</code>. </p> <p>Finalmente, a\u00f1ade el c\u00f3digo necesario para que al pulsar sobre <code>Salir</code> se haga logout en Firebase.  </p>"},{"location":"cap11/4_ejercicios/#mensajes-del-chat-1-punto","title":"Mensajes del chat (1 punto)","text":"<p>Usaremos la siguiente estructura para almacenar los mensajes del chat:</p> <pre><code>{\n  \"mensajes\": {\n    \"1jdakdueidas\" : {\n        \"texto\":\"hola qu\u00e9 tal\",\n        \"usuario\":\"pepe@ua.es\"\n    },\n    \"uiusd_ur48850_d\" : {\n        \"texto\":\"bien,y t\u00fa?\",\n        \"usuario\":\"pepa@ua.es\"\n    }\n  }\n}\n</code></pre> <p>donde los identificadores de mensaje deber\u00edan ser generados autom\u00e1ticamente por la base de datos con <code>childByAutoId()</code></p> <p>Llevad mucho cuidado, ya que con vuestro usuario ten\u00e9is permiso total para escribir en la base de datos, por lo que por error podr\u00edais borrar los mensajes enviados por los dem\u00e1s.</p> <p>Para que funcione el chat hay que implementar dos funcionalidades:</p>"},{"location":"cap11/4_ejercicios/#enviar-mensajes","title":"Enviar mensajes","text":"<p>Que cuando se pulse sobre \"Enviar\" se guarde el mensaje en la BD. Usando el API de la base de datos habr\u00e1 que:   + Obtener la referencia al nodo \"mensajes\"   + Generar la referencia a un nuevo nodo id hijo de la referencia anterior con <code>childByAutoId()</code>    + Fijar el valor de este nuevo nodo con <code>setValue()</code> a un diccionario Swift con las claves \"texto\" y \"usuario\" y que contenga el texto del mensaje y el email del usuario actual de Firebase.</p> <p>Con el HTML llamado \"Consola Firebase\" que se incluye en las plantillas pod\u00e9is ver en un recuadro el estado actual de la BD y pod\u00e9is comprobar si se ha insertado correctamente vuestro mensaje. Tambi\u00e9n pod\u00e9is enviar mensajes, pero eso ser\u00eda para probar la siguiente secci\u00f3n</p>"},{"location":"cap11/4_ejercicios/#recibir-mensajes","title":"Recibir mensajes","text":"<p>Que cuando alguien env\u00ede un mensaje al chat este aparezca en la tabla</p> <p>Como es m\u00e1s que posible que en este momento est\u00e9s probando t\u00fa sol@ la app no habr\u00e1 nadie m\u00e1s enviando mensajes al chat. Puedes similar que env\u00edas mensajes como otro usuario desde el HTML de moodle que act\u00faa como \"consola de Firebase\"</p> <p>En el <code>viewWillAppear</code> del <code>ChatViewController</code> a\u00f1adir un listener para que escuche el evento <code>.childAdded</code> sobre el nodo \"mensajes\"</p> <p>Ten en cuenta que el c\u00f3digo que recibe el evento recibe un par\u00e1metro <code>snapshot</code> con los nuevos valores en el campo <code>value</code>. En nuestro caso ser\u00e1 un diccionario con el texto y el usuario. Podemos hacer el cast a un diccionario con claves y valores <code>String</code> para poder usarlo en el c\u00f3digo, algo como:</p> <p><pre><code>if let valor = snapshot.value, let v = valor as? [String:String] {\n   //Aqu\u00ed ya podr\u00edamos acceder a los valores con v[\"texto\"] y v[\"usuario\"]\n}\n</code></pre> Cuando se reciba el evento, para mostrar el mensaje en la tabla:</p> <ul> <li>Con el texto del mensaje y el email del usuario construir un <code>struct</code> de tipo <code>Mensaje</code> y a\u00f1adirlo al array <code>self.mensajes</code> del <code>ChatViewController</code>. </li> <li>Para que aparezca visualmente en la tabla tienes adem\u00e1s que a\u00f1adir una fila en la posici\u00f3n correspondiente:</li> </ul> <pre><code>let indexPath = IndexPath(row:self.mensajes.count-1,section:0)\nself.miTabla.insertRows(at: [indexPath], \n                     with: UITableViewRowAnimation.bottom)\n</code></pre>"},{"location":"cap2/2.1_intro_SQLite/","title":"2.1 intro SQLite","text":""},{"location":"cap2/2.1_intro_SQLite/#introduccion-a-sqlite-en-ios","title":"Introducci\u00f3n a SQLite en iOS","text":"<p>En iOS no hay ning\u00fan framework est\u00e1ndar para trabajar con SQLite de forma nativa. Lo m\u00e1s habitual es usar directamente el API C de la librer\u00eda. Al ser C un subconjunto de Objective-C (e interoperable con Swift) usar este API no es mayor problema, salvo por el \u201cengorro\u201d de tener que emplear funcionalidades de bajo nivel y tipos de datos de C (<code>char *</code> en lugar de <code>String</code>, por ejemplo).</p> <p>Como vamos a ver, el API es considerablemente de nivel m\u00e1s bajo que los que hab\u00e9is usado en Android. Es muy improbable que en el futuro aparezca en iOS un API SQLite de nivel m\u00e1s alto, ya que Apple recomienda el uso del framework \"Core data\" sobre el uso directo de SQLite (como veremos, Core Data usa habitualmente SQLite de modo interno). No obstante, para casos de uso relativamente sencillos SQLite va a ser una alternativa mucho m\u00e1s ligera en recursos que Core Data. Adem\u00e1s SQLite supone una barrera de entrada bastante baja para cualquier desarrollador habituado a trabajar con SQL y bases de datos, cosa que no se puede decir de Core Data.</p>"},{"location":"cap2/2.1_intro_SQLite/#configurar-el-proyecto","title":"Configurar el proyecto","text":"<p>Para poder usar SQLite en un proyecto iOS primero hay que a\u00f1adir manualmente la librer\u00eda, no se a\u00f1ade autom\u00e1ticamente al contrario que otros frameworks. Seleccionamos el icono del proyecto (el azul) y en las propiedades del proyecto, opci\u00f3n <code>General</code>, al final de las opciones en <code>Linked frameworks and libraries</code>, (Xcode&lt;11) o <code>Frameworks, Libraries and Embedded Content</code>  (Xcode&gt;=11) pulsar sobre <code>+</code> y a\u00f1adir <code>libsqlite3.tdb</code>.</p> <p></p> <p>Para poder usar c\u00f3digo C en un proyecto Swift necesitamos crear un archivo especial con los <code>include</code> necesarios. Esto es lo que se llama un bridging header.</p> <p>Para crear el bridging header vamos en Xcode a <code>File &gt; New &gt; File...</code> y en las plantillas seleccionamos \"header file\". Le damos cualquier nombre, por ejemplo <code>b-h.h</code>. El contenido de la plantilla que crea Xcode no nos sirve, debemos borrarlo y sustituirlo simplemente por esto:</p> <pre><code>#include &lt;sqlite3.h&gt;\n</code></pre> <p>Ahora debemos decirle a Xcode que este <code>.h</code> es efectivamente un bridging header. Para eso seleccionamos el icono del proyecto (el azul) y en el apartado <code>build settings</code> seleccionamos <code>All</code> y en el cuadro de b\u00fasqueda buscamos \"bridging header\". Aparecer\u00e1 una opci\u00f3n llamada <code>Objective-C Bridging Header</code>, que estar\u00e1 vac\u00eda, y en la que debemos escribir el nombre de nuestro <code>b-h.h</code> (si lo has metido en una carpeta dentro del proyecto tendr\u00e1s que poner delante su nombre)</p> <p></p> <p>Este proceso es mucho m\u00e1s simple cuando importamos directamente c\u00f3digo C u Obj-C a nuestro proyecto, ya que al a\u00f1adir el <code>.c</code> o <code>.m</code> Xcode lo detecta y crea y configura el bridging header autom\u00e1ticamente. No es este el caso, ya que aqu\u00ed estamos usando una librer\u00eda ya compilada. </p>"},{"location":"cap2/2.1_intro_SQLite/#incluir-la-base-de-datos-en-el-proyecto","title":"Incluir la base de datos en el proyecto","text":"<p>La forma m\u00e1s t\u00edpica de incluir la base de datos en el proyecto es copiarla al bundle de la aplicaci\u00f3n. </p> <p>No arrastres el archivo desde el finder hasta la ventana de Xcode. Se copiar\u00e1 en el directorio del proyecto pero no en el bundle de la aplicaci\u00f3n</p> <p>Pulsa con el bot\u00f3n derecho sobre el proyecto y selecciona la opci\u00f3n de <code>Add files to \"(nombre_del_proyecto)\"</code>. En el cuadro de di\u00e1logo que aparecer\u00e1, seleccionar el archivo con la base de datos, pulsar sobre el bot\u00f3n <code>Options</code> y asegurarse de que est\u00e1 marcada la casilla <code>Copy items if needed</code>, para hacer una copia en el directorio del proyecto y no usar simplemente una referencia al archivo original.</p>"},{"location":"cap2/2.1_intro_SQLite/#manejar-bases-de-datos-desde-la-consola","title":"Manejar bases de datos desde la consola","text":"<p>Aunque en el Mac no hay ninguna herramienta gr\u00e1fica por defecto para gestionar bases de datos SQLite s\u00ed hay preinstalada una herramienta en l\u00ednea de comandos: <code>sqlite3</code>. </p> <p>Para abrir una base de datos, desde la terminal: </p> <pre><code>sqlite3 nombre_bd\n</code></pre> <p>Se abrir\u00e1 un prompt donde podemos usar varios comandos, por ejemplo:</p> <ul> <li><code>.tables</code>, para listar tablas</li> <li><code>.schema nombre_de_tabla</code> para ver estructura de una tabla</li> <li>Se pueden teclear directamente sentencias SQL, termin\u00e1ndolas en `;``</li> </ul>"},{"location":"cap2/2.2_API_SQLite/","title":"2.2 API SQLite","text":""},{"location":"cap2/2.2_API_SQLite/#el-api-de-sqlite","title":"El API de SQLite","text":""},{"location":"cap2/2.2_API_SQLite/#acceder-a-la-bd","title":"Acceder a la BD","text":"<p>Vamos a ver aqu\u00ed c\u00f3mo abrir la base de datos para comenzar a trabajar con ella.</p>"},{"location":"cap2/2.2_API_SQLite/#abrir-y-cerrar-la-bd","title":"Abrir y cerrar la BD","text":"<p>En el API C de SQLite la base de datos se representa en nuestro c\u00f3digo mediante un puntero a un  <code>struct</code> de tipo <code>sqlite3</code>. En swift podemos representar un puntero de C con el tipo <code>OpaquePointer</code>, as\u00ed que en nuestro c\u00f3digo tendremos algo como</p> <pre><code>var db: OpaquePointer? = nil\n</code></pre> <p>Para abrir la BD se usa la funci\u00f3n <code>sqlite3_open</code>, a la que hay que pasarle el path de la base de datos y la referencia a este struct</p> <pre><code>sqlite3_open(path_db, &amp;db);\n</code></pre> <p>Vamos a crear una clase <code>DBManager</code> en la que implementaremos los m\u00e9todos que interact\u00faan con la base de datos. En esta clase creamos una variable miembro privada para almacenar la referencia a la base de datos.</p> <pre><code>class DBManager {\n    var db : OpaquePointer? = nil   \n}\n</code></pre> <p>Podemos implementar un inicializador que abra la base de datos suponiendo que est\u00e1 incluida en el bundle</p> <pre><code>class DBManager {\n    var db : OpaquePointer? = nil\n\n    init(conDB nombreDB : String) {\n        if let dbPath = Bundle.main.path(forResource: nombreDB, ofType: \"db\") {\n            if sqlite3_open(dbPath, &amp;(self.db)) == SQLITE_OK {\n                print(\"Base de datos \\(dbPath) abierta OK\")\n            }\n            else {\n                let error = String(cString:sqlite3_errmsg(db))\n                print(\"Error al intentar abrir la BD: \\(error) \")\n            }\n        }\n        else {\n            print(\"El archivo no se encuentra\")\n        }\n    }\n}\n</code></pre> <p>Del c\u00f3digo anterior debemos destacar los siguientes aspectos:</p> <ul> <li>Las llamadas al API de SQLite devuelven la constante <code>SQLITE_OK</code> si no ha habido error, as\u00ed que para saber si <code>sqlite3_open</code> ha tenido \u00e9xito comprobamos si ha devuelto este valor. </li> <li>Si se produce un error, para ver cu\u00e1l es podemos usar la funci\u00f3n <code>sqlite3_errmsg</code>, que devuelve el mensaje del error m\u00e1s reciente asociado a una llamada hecha al API de SQLite. Al ser c\u00f3digo C el mensaje de error se devuelve como un <code>char *</code>, ya que en C no existe el tipo <code>String</code>. En nuestro c\u00f3digo convertimos este tipo a un <code>String</code> de Swift, para poder tratarlo (imprimirlo, en nuestro caso). Esta conversi\u00f3n la hacemos con el inicializador <code>String(cString:)</code></li> <li>A la inversa, las funciones C que requieren un <code>char *</code> como par\u00e1metro aceptan directamente un <code>String</code> de Swift. Esto por ejemplo pasa al hacer el <code>sqlite3_open</code>, que en realidad requiere que se le pase un <code>char *</code> con el path de la BD.</li> </ul> <p>Para cerrar la base de datos se usa la funci\u00f3n <code>sqlite3_close()</code> a la que se le pasa como par\u00e1metro el puntero al struct con la informaci\u00f3n de la base de datos.</p>"},{"location":"cap2/2.2_API_SQLite/#abrir-la-bd-con-permiso-de-escritura","title":"Abrir la BD con \u201cpermiso de escritura\u201d","text":"<p>Un problema que tiene incluir f\u00edsicamente la base de datos en el bundle de la aplicaci\u00f3n es que este es de solo lectura. Eso quiere decir que no podr\u00edamos ejecutar consultas de actualizaci\u00f3n sobre la base de datos.</p> <p>La forma m\u00e1s habitual de resolver este problema es crear una copia de la base de datos en alg\u00fan directorio con permiso de escritura cuando se arranca la aplicaci\u00f3n. T\u00edpicamente se usa el directorio <code>Documents</code> ya que es el m\u00e1s apropiado para este prop\u00f3sito.</p> <p>Aqu\u00ed tenemos un m\u00e9todo que copia la BD del bundle  al directorio <code>Documents</code>, si es que no se ha copiado ya:</p> <pre><code>func copyDB(conNombre nombre : String)-&gt;URL? {\n    let fileManager = FileManager.default\n    let docsURL = fileManager.urls(for: .documentDirectory, in: .userDomainMask)[0]\n    let dbCopiaURL = docsURL.appendingPathComponent(nombre).appendingPathExtension(\"db\")\n    if fileManager.fileExists(atPath: dbCopiaURL.path) {\n        return dbCopiaURL\n    }\n    else {\n        if let dbOriginalURL = Bundle.main.url(forResource: nombre, withExtension: \"db\") {\n            if (try? fileManager.copyItem(at: dbOriginalURL, to: dbCopiaURL)) != nil {\n                return dbCopiaURL\n            }\n            else {\n                return nil\n            }\n        }\n        else {\n            return nil\n        }\n    }\n}\n</code></pre> <p>Tendremos que modificar el inicializador del apartado anterior para que llame a este m\u00e9todo y despu\u00e9s no abra la base de datos del bundle sino la de <code>Documents</code>:</p> <pre><code>class DBManager {\n    var db : OpaquePointer? = nil\n\n    init(conDB nombreDB : String) {\n        if let dbCopiaURL = copyDB(conNombre: nombreDB) {\n            if sqlite3_open(dbCopiaURL.path, &amp;(self.db)) == SQLITE_OK {\n                print(\"Base de datos \\(dbCopiaURL) abierta OK\")\n            }\n//contin\u00faa como antes...\n</code></pre>"},{"location":"cap2/2.2_API_SQLite/#consultas-de-seleccion","title":"Consultas de selecci\u00f3n","text":""},{"location":"cap2/2.2_API_SQLite/#compilar-y-ejecutar-una-consulta-de-seleccion","title":"Compilar y ejecutar una consulta de selecci\u00f3n","text":"<p>El esquema general para ejecutar una consulta de selecci\u00f3n y recorrer los registros resultantes es el siguiente:</p> <ol> <li>Compilar la query (convertirla de SQL en \"modo texto\" a un formato \"ejecutable\" por SQLite)</li> <li>Ir avanzando registro a registro por los resultados, mientras queden registros<ul> <li>Obtener los campos que nos interesen del registro actual, sabiendo el n\u00famero de columna que ocupan. Las columnas empiezan en 0</li> <li>Habitualmente \u201cempaquetaremos\u201d los valores del registro actual en un objeto o <code>struct</code> de Swift, e iremos construyendo una lista de resultados (un array es lo m\u00e1s sencillo).</li> </ul> </li> <li>Liberar la memoria ocupada por la query compilada</li> </ol> <p>Vamos a ver un ejemplo de c\u00f3digo que implementa este esquema:</p> <pre><code>let querySQL = \"SELECT * FROM Personas\"\nvar statement : OpaquePointer?;\nvar lista : [Persona] = [];\n\nlet result = sqlite3_prepare_v2(db, querySQL, -1, &amp;statement, nil)\nif (result==SQLITE_OK) {\n    while (sqlite3_step(statement) == SQLITE_ROW) {\n        let id = sqlite3_column_int(statement, 0)\n        let nombre = String(cString: sqlite3_column_text(statement, 1))\n        let persona = Persona(id: Int(id), nombre: nombre)\n        lista.append(persona)\n    }\n}\nsqlite3_finalize(statement);\nfor p in lista {\n    print(\"\\(p.id) \\(p.nombre)\")\n}\n</code></pre> <ul> <li>En la funci\u00f3n <code>sqlite3_prepare_v2()</code> <ul> <li>Los dos primeros argumentos son el <code>struct</code> que representa la base de datos y la cadena con la query.  </li> <li>Aunque en el ejemplo no usamos esta funcionalidad se podr\u00edan poner varias sentencias SQL en la misma cadena y compilar solo una de ellas. El tercer argumento de indica la longitud en caracteres que queremos tomar de la query (-1 indica leer toda la cadena). </li> <li>Con el \u00faltimo argumento SQLite nos informa qu\u00e9 parte de query queda por ejecutar, en este caso pasamos <code>nil</code> ya que no nos interesa esta funcionalidad. </li> </ul> </li> <li>Vamos avanzando por los registros con <code>sqlite_step()</code>. Mientras que esta funci\u00f3n devuelva <code>SQLITE_ROW</code> tenemos una nueva fila y podemos obtener sus campos con <code>sqlite_column_XXX()</code>, donde <code>XXX</code> es el tipo de campo</li> <li>De nuevo tenemos el problema de que como el API de SQLite est\u00e1 en C, devuelve <code>char *</code> para los campos de tipo cadena, y no <code>String</code> por lo que debemos hacer la conversi\u00f3n con el inicializador <code>String(cString:)</code></li> <li>Aqu\u00ed usamos la estrategia de \u201cempaquetar\u201d los datos obtenidos de la BD en un objeto y guardar todos los objetos en un array.</li> <li>Finalmente <code>sqlite3_finalize</code> libera la memoria ocupada por la query</li> </ul>"},{"location":"cap2/2.2_API_SQLite/#fechas-en-sqlite","title":"Fechas en SQLite","text":"<p>SQLite no tiene el tipo fecha. Posibles alternativas son representar una fecha en formato cadena o bien como un entero, el t\u00edpico \"UNIX timestamp\" (n\u00famero de segundos transcurridos desde el 1 de enero de 1970). Por ejemplo si sabemos que la fecha est\u00e1 almacenada como un timestamp podr\u00edamos hacer algo como:</p> <pre><code>//supongamos que la columna 2 es una fecha en formato timestamp UNIX\nlet unix_time = sqlite3_column_int(statement, 2);\n//TimeInterval es equivalente a Double. Hacemos una conversi\u00f3n\nlet fecha = Date(timeIntervalSince1970: TimeInterval(valor))\n//La clase DateFormatter nos permite mostrar una fecha\nlet df = DateFormatter()\n//Hay una serie de estilos predefinidos\ndf.dateStyle = .full\nprint(\"\\(df.string(from: fecha))\")\n</code></pre> <p>En el ejemplo se usa la clase <code>DateFormatter</code> para mostrar la fecha, se puede configurar para variar el locale y el formato concreto. Hay una serie de formatos predefinidos (<code>.short</code>, <code>.medium</code>, <code>.full</code>, ...) y tambi\u00e9n podemos especificar mediante una cadena de formato qu\u00e9 componentes queremos mostrar y en qu\u00e9 orden. Para m\u00e1s informaci\u00f3n consultar la documentaci\u00f3n de <code>DateFormatter</code>.</p> <p>Tambi\u00e9n podr\u00edamos almacenar las fechas en formato cadena (formato <code>a\u00f1o-mes-dia horas:minutos:segundos</code>). Parsear las fechas ser\u00e1 algo m\u00e1s tedioso que con timestamps, pod\u00e9is consultar este ejemplo.</p>"},{"location":"cap2/2.2_API_SQLite/#consultas-con-parametros","title":"Consultas con par\u00e1metros","text":"<p>En el ejemplo del apartado anterior la consulta SQL era una cadena fija pero en muchos casos necesitaremos parametrizar la consulta (por ejemplo obtener todos los alumnos cuyo apellido empiece por una letra, o los nacidos despu\u00e9s de una fecha determinada). </p> <p>Aunque podemos construir el  <code>String</code> concatenando subcadenas es m\u00e1s \"limpio\" usar par\u00e1metros, que adem\u00e1s nos protegen contra posibles intentos de inyecci\u00f3n SQL. Al igual que en la mayor\u00eda de BD los par\u00e1metros se especifican con el s\u00edmbolo <code>?</code></p> <pre><code>let querySQL = \"SELECT * FROM alumnos WHERE fecha_nacimiento &lt; ?\"\n</code></pre> <p>Para instanciar el par\u00e1metro con un determinado valor usaremos la familia de funciones <code>sqlite3_bind_XXX</code>, en la que las <code>XXX</code> indican el tipo de datos del par\u00e1metro (<code>int</code>, <code>double</code>, <code>text</code>,\u2026). Esta instanciaci\u00f3n se debe hacer despu\u00e9s de \"preparar\" la query con <code>sqlite3_prepare_v2</code> pero antes de ejecutarla con <code>sqlite3_step()</code>.</p> <p>Por ejemplo, vamos a buscar todas las personas que tengan m\u00e1s de 18 a\u00f1os (cuya fecha de nacimiento sea anterior a la actual rest\u00e1ndole 18 a\u00f1os)</p> <pre><code>let querySQL = \"SELECT * FROM alumnos WHERE fecha_nacimiento&lt;?\"\nvar statement : OpaquePointer?\n\nlet result = sqlite3_prepare_v2(db, querySQL, -1, &amp;statement, nil)\nlet cal = Calendar.current\nlet hace18 = cal.date(byAdding: Calendar.Component.year, value: -18, to: Date(), wrappingComponents: false)\nsqlite3_bind_int(statement, 1, Int32(hace18!.timeIntervalSince1970))\n</code></pre> <p>N\u00f3tese que para instanciar un par\u00e1metro debemos conocer su posici\u00f3n y que las posiciones de los par\u00e1metros comienzan en 1, no en 0.</p> <p>En SQLite tambi\u00e9n se pueden definir par\u00e1metros por nombre con el formato <code>:nombre</code>, por ejemplo</p> <pre><code>let querySQL = \"SELECT * FROM alumnos WHERE fecha_nacimiento &lt; :fecha\";\n</code></pre> <p>No obstante el API C no nos permite instanciar el par\u00e1metro directamente por nombre. Primero debemos obtener su posici\u00f3n con la funci\u00f3n <code>sqlite3_bind_parameter_index(sentencia,nombre)</code> y luego aplicar la ya conocida <code>sqlite3_bind_XXX()</code>. </p>"},{"location":"cap2/2.2_API_SQLite/#consultas-de-actualizacion","title":"Consultas de actualizaci\u00f3n","text":"<p>Como ya hemos comentado, para que se puedan ejecutar consultas de actualizaci\u00f3n sobre la base de datos esta tiene que estar almacenada en un directorio con permisos de escritura</p> <p>Las consultas de actualizaci\u00f3n se manejan de un modo similar a las de selecci\u00f3n: se preparan con <code>sqlite3_prepare_v2()</code>, se vinculan los par\u00e1metros si estos existen con <code>sqlite3_bind_XXX()</code> y se ejecutan con <code>sqlite3_step()</code>. Por supuesto en ellas no hay bucle para recorrer los resultados.</p> <pre><code>let querySQL = \"INSERT INTO alumnos (nombre, fecha_nacimiento) VALUES (?,?)\"\nvar statement : OpaquePointer?\nsqlite3_prepare_v2(db, querySQL, -1, &amp;statement, nil);\nsqlite3_bind_text(statement, 1, nombre, -1, nil);\nsqlite3_bind_int(statement, 2, Int32(fechaNacimiento.timeIntervalSince1970));\nlet result = sqlite3_step(statement);\nif (result==SQLITE_DONE) {\n    print(\"Registro almacenado OK\");\n}\n</code></pre> <p>Como vemos, cuando se ejecuta con \u00e9xito una consulta de actualizaci\u00f3n, la ejecuci\u00f3n devuelve el valor <code>SQLITE_DONE</code>.</p> <p>N\u00f3tese que el <code>sqlite3_bind_text</code> tiene un par de par\u00e1metros adicionales con respecto a <code>sqlite3_bind_int</code>. En los casos m\u00e1s habituales se pasan siempre los valores <code>-1</code> y <code>nil</code> respectivamente. Para ver m\u00e1s informaci\u00f3n sobre estos par\u00e1metros, consultar la documentaci\u00f3n de SQLite</p> <p>Podemos contar cu\u00e1ntas filas han sido afectadas por la consulta de actualizaci\u00f3n (en el ejemplo cu\u00e1ntas filas se han insertado, o sea 1) con la funci\u00f3n <code>sqlite3_changes()</code> a la que hay que pasarle el <code>struct</code> que representa a la base de datos:</p> <pre><code>var db : OpaquePointer?\n...\nprint(\"Filas afectadas: \\(sqlite3_changes(db))\";\n</code></pre>"},{"location":"cap2/2.3_frameworks/","title":"2.3 frameworks","text":""},{"location":"cap2/2.3_frameworks/#frameworks-de-terceros","title":"Frameworks de terceros","text":"<p>Ya hemos visto que no hay un API en Swift (ni en Objective-C) para usar SQLite y que tampoco es de esperar que aparezca ninguno, dado el \u00e9nfasis que Apple hace en Core Data para las tareas de persistencia. No obstante esto no ha impedido que aparezcan librer\u00edas de terceros implementando un API para SQLite que sea de m\u00e1s alto nivel y m\u00e1s sencillo de usar en iOS.</p> <p>Hay multitud de wrappers de SQLite en Swift. De ellos uno de los m\u00e1s conocidos es SQLite.swift.</p> <p>No obstante los frameworks m\u00e1s usados para SQLite siguen siendo Objective-C, el m\u00e1s conocido es probablemente FMDB. Vamos a ver una introducci\u00f3n muy b\u00e1sica a este framework</p>"},{"location":"cap2/2.3_frameworks/#uso-de-fmdb-en-proyectos-swift","title":"Uso de FMDB en proyectos Swift","text":"<p>Swift es una librer\u00eda hecha en Objective-C pero ya sabemos que podemos mezclar Objective-C con Swift en un proyecto.</p>"},{"location":"cap2/2.3_frameworks/#instalacion-de-la-libreria","title":"Instalaci\u00f3n de la librer\u00eda","text":"<p>Aunque la forma recomendada para instalar FMDB en un proyecto es a trav\u00e9s del uso de CocoaPods probablemente es m\u00e1s simple importar directamente los fuentes. Para eso nos podemos bajar directamente el .zip de FMDB de su repositorio de Github.</p> <p>Una vez descomprimido el .zip vamos al directorio <code>fmdb-master/src/fmdb</code> e importamos todos los archivos de este directorio a nuestro proyecto (menos el <code>.plist</code>, que no es necesario). Al importarlos, Xcode detectar\u00e1 que son archivos en Objective-C y nos preguntar\u00e1 si queremos crear el \"bridging header\". Le decimos que s\u00ed y se crear\u00e1 el fichero vac\u00edo <code>&lt;nombre-del-proyecto&gt;-Bridging-Header.h</code>, en el que a\u00f1adiremos la siguiente l\u00ednea:</p> <pre><code>#import \"FMDB.h\"\n</code></pre> <p>A partir de este momento ya podemos usar las clases de FMDB dentro de nuestro c\u00f3digo Swift</p>"},{"location":"cap2/2.3_frameworks/#el-api-de-fmdb","title":"El API de FMDB","text":"<p>Vamos a ver unos cuantos ejemplos de uso de la librer\u00eda FMDB para que se vea que es bastante m\u00e1s f\u00e1cil de usar que el API C. La librer\u00eda tiene varias clases b\u00e1sicas (pod\u00e9is consultar online la referencia del API). De ellas las dos m\u00e1s usadas en un c\u00f3digo t\u00edpico son:</p> <ul> <li><code>FMDatabase</code>, que es un objeto que representa a la base de datos. Es la clase m\u00e1s importante y con la que se va a interactuar la mayor parte del tiempo. Se usa para abrir/cerrar la conexi\u00f3n y tambi\u00e9n para ejecutar las consultas.</li> <li><code>FMResultSet</code>, que encapsula un conjunto de registros resultado de una consulta de selecci\u00f3n. Podemos ir iterando por el conjunto y obtener los campos del registro actual, al igual que con el API C, pero de forma mucho m\u00e1s sencilla: por ejemplo podemos obtener el valor de un campo por nombre, y las llamadas est\u00e1n bastante simplificadas para adaptarse mejor a los casos de uso m\u00e1s t\u00edpicos.</li> </ul> <p>Por ejemplo, veamos c\u00f3mo se abrir\u00eda una base de datos, se ejecutar\u00eda una consulta de selecci\u00f3n y se ir\u00eda iterando por el conjunto de registros resultante</p> <pre><code>let dbPath = Bundle.main.path(forResource: \"prueba\", ofType: \"db\")\nif let db = FMDatabase(path: dbPath) {\n    if (!db.open()) {\n        print(\"Error al abrir la bd: \\(db.lastErrorMessage())\")\n    }\n    else {\n        if let resultSet = try? db.executeQuery(\"SELECT * FROM Personas\", values: nil) {\n            while (resultSet.next()) {\n               print(resultSet.string(forColumn: \"nombre\"))\n            }\n        }\n    }\n}\n</code></pre> <ul> <li>Para inicializar la BD necesitamos el path y usamos el m\u00e9todo de clase <code>databaseWithPath</code></li> <li>Abrir y cerrar la BD es tan sencillo como llamar a <code>open</code> y <code>close</code>. El m\u00e9todo <code>open</code> devuelve un valor booleano que indica si se ha abierto o no correctamente. En caso de error en una operaci\u00f3n de BD podemos acceder a m\u00e1s informaci\u00f3n sobre el mismo con los m\u00e9todos <code>lastErrorMessage</code> o <code>lastErrorCode</code>.</li> </ul> <p>Cuando se abre una BD que no existe, FMDB la crea autom\u00e1ticamente, se puede cambiar este comportamiento llamando a <code>openWithFlags</code> con los par\u00e1metros adecuados, en lugar de a <code>open</code>. Tambi\u00e9n se puede usar una BD en memoria si se le pasa <code>NULL</code> como path a <code>databaseWithPath</code></p> <ul> <li>Las consultas se ejecutan con <code>executeQuery</code> y devuelven una instancia de la clase <code>FMResultSet</code>. Para iterar por el resultset usamos el m\u00e9todo <code>next</code>.</li> <li>Podemos obtener los campos del registro actual con una serie de m\u00e9todos <code>XXXForColumn:</code>, donde la parte inicial del nombre es el tipo de datos de la columna (<code>string</code>, <code>int</code>, <code>long</code>, <code>date</code>,\u2026). Obs\u00e9rvese adem\u00e1s que se accede a la columna por nombre y no por posici\u00f3n (aunque tambi\u00e9n se puede acceder por posici\u00f3n con <code>XXXForColumnIndex:</code>).</li> </ul> <p>Por supuesto podemos ejecutar consultas con par\u00e1metros. El m\u00e9todo <code>executeQuery:</code> admite una lista de argumentos con los valores, por ejemplo:</p> <pre><code>let rs = db.executeQuery(\"SELECT * FROM alumnos\n                       where fecha_nacimiento&lt;?\", values:[fecha_ref];\n</code></pre> <p>Para ejecutar una consulta de actualizaci\u00f3n se usa <code>executeUpdate:</code> en lugar de <code>executeQuery</code>.</p> <p>Tambi\u00e9n podemos usar de forma sencilla par\u00e1metros por nombre (algo que en el API C es un poco tedioso). Basta con crear un diccionario con los nombres de los par\u00e1metros como claves y los valores deseados</p> <pre><code>let query = \"INSERT INTO personas (dni, nombre) VALUES (:dni, :nombre)\"\nlet datos = [\n    \"dni\" : \"1222333K\",\n    \"nombre\": \"Pepito\"\n]\ndb.executeUpdate(query, withParameterDictionary: datos)\n</code></pre>"},{"location":"cap2/2.4_ejercicios/","title":"Ejercicio de SQLite: app de tareas pendientes (5 puntos)","text":"<p>En este ejercicio vamos a crear una peque\u00f1a aplicaci\u00f3n de gesti\u00f3n de tareas pendientes, en la que se puedan listar tareas y a\u00f1adir tareas nuevas. Cada tarea tiene un <code>id</code> (entero, autonum\u00e9rico), un <code>titulo</code> (cadena),  un <code>vencimiento</code> (fecha) y una una <code>descripcion</code> (cadena). Las columnas est\u00e1n por este orden en la tabla. La base de datos ya est\u00e1 creada, y t\u00fa debes copiarla a tu proyecto como se explica a continuaci\u00f3n.</p>"},{"location":"cap2/2.4_ejercicios/#infraestructura-basica-1-punto","title":"Infraestructura b\u00e1sica (1 punto)","text":""},{"location":"cap2/2.4_ejercicios/#configurar-el-proyecto","title":"Configurar el proyecto","text":"<ul> <li>Crear un proyecto llamado <code>TareasSQLite</code> de tipo Master-Detail Application</li> <li>En la carpeta <code>archivos SQLite</code> de las plantillas hay unos cuantos recursos que debes copiar al proyecto<ul> <li>Copia en el proyecto la base de datos <code>tareas.db</code>. NO LO HAGAS ARRASTRANDO, usa el men\u00fa <code>File &gt; Add files to TareasSQLite...</code> y selecciona el archivo <code>tareas.db</code>. En el cuadro de di\u00e1logo de copia, pulsa sobre el boton <code>options</code> de la parte inferior y aseg\u00farate de que la casilla de <code>Copy items if needed</code> est\u00e1 marcada. En caso contrario est\u00e1s haciendo solo una referencia al archivo original, que se pierde si mueves el proyecto, y tampoco se sube al repositorio.</li> <li>Crea en el proyecto un <code>DBManager.swift</code> con el siguiente c\u00f3digo, es muy parecido al que tienes en los apuntes</li> </ul> </li> </ul> <pre><code>import Foundation\n\nclass DBManager {\n    var db : OpaquePointer? = nil\n\n    init(db nombreDB : String, reload: Bool) {\n        if let dbCopiaURL = copyDB(conNombre: nombreDB, reload: reload) {\n            if sqlite3_open(dbCopiaURL.path, &amp;(self.db)) == SQLITE_OK {\n                print(\"Base de datos \\(dbCopiaURL) abierta OK\")\n            }\n            else {\n                let error = String(cString:sqlite3_errmsg(db))\n                print(\"Error al intentar abrir la BD: \\(error) \")\n            }\n        }\n        else {\n            print(\"El archivo no se encuentra\")\n        }\n    }\n\n    deinit {\n        sqlite3_close(self.db)\n    }\n\n    //Copia la base de datos desde el bundle al directorio Documents, para que se pueda modificar\n    //si el par\u00e1metro \"machaca\" es true, copia la BD aunque ya est\u00e9 en Documents.\n    //En una app normal esto no lo har\u00edamos cada vez que arranquemos, ya que se machacar\u00eda la BD\n    func copyDB(conNombre nombre : String, reload machaca : Bool)-&gt;URL? {\n        let fileManager = FileManager.default\n        let docsURL = fileManager.urls(for: .documentDirectory, in: .userDomainMask)[0]\n        let dbCopiaURL = docsURL.appendingPathComponent(nombre)\n        let existe = fileManager.fileExists(atPath: dbCopiaURL.path)\n        if  existe &amp;&amp; !machaca {\n            return dbCopiaURL\n        }  \n        else {\n            if let dbOriginalURL = Bundle.main.url(forResource: nombre, withExtension: \"\") {\n                if (existe) {\n                    try! fileManager.removeItem(at: dbCopiaURL)\n                }\n                if (try? fileManager.copyItem(at: dbOriginalURL, to: dbCopiaURL)) != nil {\n                    return dbCopiaURL\n                }\n                else {\n                    return nil\n                }\n            }\n            else {\n                return nil\n            }\n        }\n    }    \n}\n</code></pre> <p>De momento, dar\u00e1 errores de compilaci\u00f3n porque todav\u00eda no has incluido SQLite en el proyecto. Ahora hay que configurar el proyecto para poder usar SQLite. A\u00f1ade la librer\u00eda <code>libsqlite3.tbd</code> y crea el Bridging Header seg\u00fan se explica en el apartado \"Configurar el proyecto\" de los apuntes.</p> <p>Para comprobar que funciona, introduce el siguiente c\u00f3digo en el  m\u00e9todo <code>viewDidLoad</code> del <code>MasterViewController</code> </p> <pre><code>let manager = DBManager(db:\"tareas.db\", reload:false)\n</code></pre> <p>Si todo es correcto, en el log debe aparecer el mensaje \"Base de datos url_enormemente_larga_de_la_BD abierta OK\". Una vez que sepas que funciona, quita la l\u00ednea que has insertado en el <code>viewDidLoad</code> para que no interfiera con el resto del ejercicio.</p> <p>N\u00f3tese que como primer par\u00e1metro se pasa el nombre de la BD, y como segundo un booleano indicando si la copia de la BD de <code>Documents</code> se va a sobreescribir cada vez que se arranque la aplicaci\u00f3n (\u00fatil cuando en desarrollo estamos cambiando \u201cdesde fuera\u201d la BD para hacer pruebas)</p> <p>Si por alg\u00fan motivo cambias manualmente la estructura o el contenido de la base de datos, recuerda poner el par\u00e1metro <code>reload</code> a <code>true</code> la primera vez que ejecutes la aplicaci\u00f3n tras la modificaci\u00f3n</p>"},{"location":"cap2/2.4_ejercicios/#codigo-base","title":"C\u00f3digo base","text":"<ul> <li> <p>Crea una <code>struct</code> Swift llamada <code>Tarea</code> en un archivo <code>Tarea.swift</code> y a\u00f1\u00e1dele como propiedades:</p> <ul> <li><code>id</code> de tipo <code>Int</code></li> <li><code>titulo</code> de tipo <code>String</code></li> <li><code>vencimiento</code> de tipo <code>Date</code></li> <li><code>descripcion</code> de tipo <code>String</code></li> </ul> </li> <li> <p>Crea un archivo <code>TareasManager.swift</code> donde se defina una clase del mismo nombre, y que sea una subclase de <code>DBManager</code>. En los siguientes apartados implementaremos aqu\u00ed las operaciones con la tabla de tareas.</p> </li> </ul>"},{"location":"cap2/2.4_ejercicios/#funcionalidad-1-listar-tareas-3-puntos","title":"Funcionalidad 1: Listar tareas (3 puntos)","text":""},{"location":"cap2/2.4_ejercicios/#implementar-el-listado-en-si","title":"Implementar el listado en s\u00ed","text":"<p>En <code>TareasManager</code>  Implementa un m\u00e9todo <code>listarTareas</code> que debe hacer un SELECT de la tabla <code>tareas</code> ordenado por fecha de vencimiento y devolver un array de objetos <code>Tarea</code> . Ser\u00e1 muy similar al c\u00f3digo que sirve para listar personas en los apuntes.</p> <p>Recuerda que en la tabla <code>tareas</code> las columnas son los mismos campos que en la <code>struct Tarea</code>: <code>id</code>, <code>titulo</code>, <code>vencimiento</code> y <code>descripcion</code>.</p> <p>Para ir paso a paso, puedes implementar primero en TareasManager una versi\u00f3n inicial de <code>listarTareas</code> que solo saque de la BD el campo <code>titulo</code> (columna 1, de tipo cadena), y ponga el resto de campos a valores fijos y arbitrarios. </p> <p>Una vez lo tengas puedes probarlo en el  <code>MasterViewController</code>. A\u00f1ade la siguiente propiedad para almacenar una referencia al <code>TareasManager</code> </p> <pre><code>var tm : TareasManager! = nil\n</code></pre> <p>y ahora en el <code>viewDidLoad</code> a\u00f1ade:</p> <pre><code>self.tm = TareasManager(db: \"tareas.db\", reload: false)\nlet lista = self.tm.listarTareas()\nfor t in lista {\n    print(\"\\(t.titulo)\");\n}\n</code></pre> <p>Deber\u00edan salir los t\u00edtulos de 3 tareas distintas. Si esto va, ya sabes que la parte b\u00e1sica te funciona y ahora puedes a\u00f1adir  en <code>listarTareas</code> el resto de campos: <code>id</code>, <code>descripcion</code> y <code>vencimiento</code>. Este \u00faltimo campo ten en cuenta que usa \u201ctiempo UNIX\u201d: n\u00famero de segundos transcurridos desde el 1/1/1970.</p>"},{"location":"cap2/2.4_ejercicios/#mostrar-las-tareas-en-la-tabla","title":"Mostrar las tareas en la tabla","text":"<p>Vamos a modificar el c\u00f3digo del <code>viewDidLoad</code> para integrarlo mejor con la plantilla que ha generado Xcode. Fijate que lo que nosotros definimos como lista la plantilla lo define en la propiedad <code>objects</code> de la clase <code>MasterViewController</code>, y que es un array de objetos cualesquiera  (<code>[Any]()</code>). C\u00e1mbialo por un array de tareas, <code>[Tarea]()</code>), y cambia el c\u00f3digo del apartado anterior para que use <code>self.objects</code> en vez de <code>lista</code>. Quedar\u00e1 como:</p> <pre><code>self.tm = TareasManager(db: \"tareas.db\", reload: false)\nself.objects = self.tm.listarTareas()\n</code></pre> <p>Para que las tareas aparezcan correctamente el interfaz  gr\u00e1fico puedes cambiar las l\u00ednea en el m\u00e9todo <code>tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath)</code> que dicen</p> <pre><code>let object = objects[indexPath.row] as! NSDate\ncell.textLabel!.text = object.description\n</code></pre> <p>por otras que usen la clase <code>Tarea</code> y referencien su propiedad <code>titulo</code>:</p> <pre><code>let tarea = objects[indexPath.row]\ncell.textLabel!.text = tarea.titulo\n</code></pre> <p>Para evitar errores de compilaci\u00f3n, en el m\u00e9todo <code>insertNewObject</code> cambia la primera l\u00ednea (<code>objects.insert...</code>) por:</p> <pre><code>objects.insert(Tarea(id:0, titulo:\"Prueba\", descripcion:\"\", vencimiento:Date()), at: 0)\n</code></pre> <p>Ahora puedes probar la app y los t\u00edtulos de las tareas deber\u00edan aparecer en la lista (aunque si pinchas en alguna de ellas dar\u00e1 error en tiempo de ejecuci\u00f3n, ya que la plantilla asume que son <code>NSDate</code> y no objetos <code>Tarea</code>)</p> <p>Para poder ver alg\u00fan detalle m\u00e1s en la lista, por ejemplo la fecha de vencimiento, abre el storyboard y selecciona la celda de tabla que aparece en la segunda pantalla de la aplicaci\u00f3n. En las propiedades, cambiar el <code>Style</code> de <code>Basic</code> a <code>Subtitle</code>, por ejemplo (aunque tambi\u00e9n valdr\u00edan los otros dos estilos).</p> <p>En el c\u00f3digo de <code>tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath)</code> debes incluir c\u00f3digo que</p> <ol> <li>convierta <code>object</code> a Tarea</li> <li>acceda a su propiedad <code>vencimiento</code>, que ser\u00e1 una fecha, y la convierta a texto con <code>DateFormatter</code> (mira las transparencias)</li> <li>Asigne esta fecha en formato texto a <code>cell.detailTextLabel.text</code>.</li> </ol> <p>Finalmente, para que funcione la pantalla secundaria de detalle hay que:</p> <ul> <li>En el m\u00e9todo <code>prepare</code> del <code>MasterViewController</code> cambiar la l\u00ednea</li> </ul> <pre><code>let object = objects[indexPath.row] as! NSDate\n</code></pre> <p>eliminando la conversi\u00f3n a <code>NSDate</code>, quedar\u00e1 simplemente como </p> <pre><code>let object = objects[indexPath.row]\n</code></pre> <ul> <li>En la l\u00ednea 31 de la clase <code>DetailViewController</code> cambiar el tipo de  <code>DetailItem</code> de <code>NSDate</code> a <code>Tarea</code></li> <li>En la l\u00ednea 20 de la misma clase cambiar <code>detail.description</code> por <code>detail.descripcion</code> que es un campo que s\u00ed tienen los objetos <code>Tarea</code></li> </ul>"},{"location":"cap2/2.4_ejercicios/#funcionalidad-2-insertar-nueva-tarea-2-puntos","title":"Funcionalidad 2: Insertar nueva tarea (2 puntos)","text":"<p>Implementar un m\u00e9todo <code>func insertar(tarea : Tarea)-&gt;Bool</code> en la clase <code>TareasManager</code>, que inserte una nueva tarea en la BD y devuelva <code>true</code> si todo ha ido bien y <code>false</code> en caso contrario.</p> <p>Al campo <code>id</code> no es necesario darle valor al insertar un registro ya que es autonum\u00e9rico.</p> <p>Primero comprueba que funciona correctamente, insertando una tarea con datos fijos desde el <code>viewDidLoad</code> del <code>MasterViewController.</code>  (hazlo antes del que las lista, para que la nueva est\u00e9 incluida tambi\u00e9n en la lista de tareas)</p> <pre><code>let nueva = Tarea()\nnueva.titulo = \"Tarea nueva\";\nnueva.descripcion = \"nueva descripcion\";\n//24*60*60 segundos posterior a la fecha actual -&gt; ma\u00f1ana a la misma hora\nnueva.vencimiento = Date(timeIntervalSinceNow:24*60*60);\nself.tm.insertar(tarea:nueva)\n</code></pre> <p>Una vez comprobado puedes eliminar el c\u00f3digo anterior. Para a\u00f1adir la funcionalidad en la interfaz de forma sencilla podemos usar un <code>UIAlertAction</code></p> <p>Ser\u00eda mucho m\u00e1s elegante tener una pantalla aparte para introducir los datos de la tarea, pero lo que nos importa en esta sesi\u00f3n es trabajar con SQLite y \"perder\u00edamos\" demasiado tiempo en crear la interfaz.</p> <p>Copia este m\u00e9todo en el <code>MasterViewController</code>:</p> <pre><code>@objc func nuevaTarea() {\n    let alert = UIAlertController(title: \"Nueva tarea\",\n                                 message: \"Introduce los datos\",\n                                 preferredStyle: .alert)\n    let crear = UIAlertAction(title: \"Crear\", style: .default) {\n        action in\n        let tit = alert.textFields![0].text!\n        if let desc = alert.textFields![1].text {\n            if let diasVenc = Double(alert.textFields![2].text!) {\n               let venc = Date(timeIntervalSinceNow:24*60*60*diasVenc)\n               let t = Tarea(id:0, titulo: tit, descripcion: desc, vencimiento: venc)\n               if (self.tm.insertar(tarea: t)) {\n                    self.objects.insert(t, at: 0)\n                    let indexPath = IndexPath(row: 0, section: 0)\n                    self.tableView.insertRows(at: [indexPath], with: .automatic)\n               }\n            }\n        }\n    }\n    let cancelar = UIAlertAction(title: \"Cancelar\", style: .cancel) {\n        action in\n        print(\"Cancelada creaci\u00f3n de tarea\")\n    }\n    alert.addAction(crear)\n    alert.addAction(cancelar)\n    alert.addTextField() { $0.placeholder = \"T\u00edtulo\"}\n    alert.addTextField() { $0.placeholder = \"Descripci\u00f3n\"}\n    alert.addTextField() { $0.placeholder = \"Vencimiento (d\u00edas)\"}\n    self.present(alert, animated: true)\n}\n</code></pre> <p>Ahora hay que vincular el bot\u00f3n <code>+</code> de la interfaz con este m\u00e9todo. En el <code>viewDidLoad</code> busca la l\u00ednea</p> <pre><code>let addButton = UIBarButtonItem(barButtonSystemItem: .add, target: self, action: #selector(insertNewObject(_)))\n</code></pre> <p>y d\u00e9jala como</p> <pre><code>let addButton = UIBarButtonItem(barButtonSystemItem: .add, target: self, action: #selector(nuevaTarea))\n</code></pre> <p>Ahora al pulsar el bot\u00f3n <code>+</code> deber\u00eda aparecer un alert para escribir los datos de la tarea. En esta versi\u00f3n simplificada no se puede poner una fecha de vencimiento d\u00eda-mes-a\u00f1o, sino solo un n\u00famero de d\u00edas a partir de la fecha actual.</p>"},{"location":"cap2/intro/","title":"SQLite","text":"<p>En este cap\u00edtulo veremos c\u00f3mo usar la base de datos SQLite en iOS. Esta base de datos es m\u00e1s adecuada que las herramientas del cap\u00edtulo anterior si necesitamos hacer b\u00fasquedas o bien queremos guardar una cantidad de datos apreciable. Aunque Apple recomienda el uso del API Core Data para estas tareas, el uso de SQLite tiene la ventaja de presentar una baja barrera de entrada: simplemente conociendo SQL podemos trabajar con una base de datos relacional en iOS sin necesidad de aprender APIs complejos como Core Data. </p>"},{"location":"cap3/3.1_intro/","title":"Introducci\u00f3n a Core Data","text":""},{"location":"cap3/3.1_intro/#que-es-core-data","title":"\u00bfQu\u00e9 es Core Data?","text":"<p>Core Data es el principal framework de persistencia de iOS. Nos proporciona un mecanismo para poder almacenar de forma persistente los objetos de nuestra aplicaci\u00f3n y luego recuperarlos. Es capaz de guardar autom\u00e1ticamente un grafo entero de objetos con las relaciones (uno a uno, uno a muchos, muchos a muchos) que hay entre ellos. Si bien es un API complejo y tiene una curva de aprendizaje pronunciada, para cualquier aplicaci\u00f3n medianamente grande usar Core Data nos va a resultar mucho m\u00e1s sencillo que implementar nosotros la persistencia de manera manual con, digamos, SQLite.</p> <p>Core Data se puede considerar en cierto modo como un ORM (object relational mapper). A los desarrolladores que hayan usado un ORM en cualquier lenguaje les va a resultar familiar si no el API s\u00ed al menos las ideas b\u00e1sicas y la filosof\u00eda de trabajo. A\u00fan m\u00e1s, ciertos t\u00e9rminos usados en Core Data (objetos gestionados, contexto, ...) son t\u00edpicos tambi\u00e9n de otros ORM como por ejemplo JPA en Java. </p> <p>Siendo puristas, Core Data no es un ORM estrictamente hablando, ya que su objetivo no es la persistencia \u00fanicamente en bases de datos relacionales. En principio el backend de persistencia podr\u00eda ser cualquiera. Con la implementaci\u00f3n actual Core Data admite como \u00fanica BD relacional para persistencia SQLite, y tambi\u00e9n puede almacenar datos en memoria y en XML (esto \u00faltimo solo en OSX).</p>"},{"location":"cap3/3.1_intro/#el-stack-de-core-data","title":"El stack de Core Data","text":"<p>El stack de Core Data usa un cierto n\u00famero de clases con una terminolog\u00eda que al principio puede resultar un poco confusa o complicada. La tarea de almacenar de forma persistente un grafo de objetos en realidad es complicada, as\u00ed que en parte por eso lo es la infraestructura necesaria. Vamos a resumir aqu\u00ed brevemente el papel de cada componente del stack</p> <p>Por supuesto,  para poder almacenar informaci\u00f3n de forma persistente lo primero es disponer de un medio de almacenamiento persistente (una base de datos relacional, un fichero XML, un archivo JSON,\u2026). El <code>NSPersistentStore</code> es la clase que se ocupa de gestionar este almacenamiento persistente. Core Data nos proporciona dos implementaciones de almacenamiento \"persistente\" en iOS: la BD relacional SQLite, que ya conocemos, y el almacenamiento en memoria. Tambi\u00e9n podemos escribir nuestras propias implementaciones de <code>NSPersistentStore</code>.</p> <p>Es evidente que el almacenamiento en memoria no es precisamente persistente, pero va a ser muy r\u00e1pido y es apropiado para manejar datos de solo lectura o que puedan ser f\u00e1cilmente re-creados. </p> <p>El <code>NSPersistentStoreCoordinator</code> podr\u00eda considerarse como el n\u00facleo de Core Data. Es la clase responsable de gestionar la persistencia y por eso tiene que interactuar con el <code>NSPersistentStore</code>. No obstante, por muy importante que sea su papel de modo interno nuestro c\u00f3digo no va a interactuar apenas con esta clase, salvo en su inicializaci\u00f3n. Para poder hacer su trabajo, el <code>NSPersistentStoreCoordinator</code> necesita de un modelo de datos, o <code>NSManagedObjectModel</code>. Este modelo, que es similar a lo que ser\u00eda un modelo E-R en una base de datos relacional, define las \u201cclases\u201d que componen nuestro modelo del dominio, especificando sus atributos y las relaciones entre clases. Como veremos, en el proyecto de Xcode un modelo de datos se representa con un archivo <code>.xcdatamodeld</code>. El <code>NSManagedObjectModel</code> ser\u00eda como la versi\u00f3n compilada y binaria de este archivo. De nuevo solo vamos a usar directamente esta clase en nuestro c\u00f3digo en la parte de inicializaci\u00f3n (aunque por supuesto crear y editar el archivo <code>.xcdatamodeld</code> nos va a llevar bastante tiempo para cualquier modelo no trivial). </p> <p>Llegamos ya a las clases con las que nuestro c\u00f3digo va a interactuar m\u00e1s habitualmente:</p> <ul> <li><code>NSManagedObjectContext</code> es el \u201ccontexto de persistencia\u201d. Este contexto es un grafo de objetos, relacionados entre s\u00ed, y cuyo ciclo de vida est\u00e1 gestionado por Core Data (de ah\u00ed la terminolog\u00eda de managed objects). Esto significa que por ejemplo no creamos los objetos persistentes como habitualmente (con el inicializador) sino que le debemos pedir al  <code>NSManagedObjectContext</code> que los cree por nosotros. Cada vez que necesitemos recuperar un objeto del almacenamiento persistente o guardarlo all\u00ed, tambi\u00e9n tendremos que ped\u00edrselo al contexto. As\u00ed que no es dif\u00edcil ver por qu\u00e9 va esta clase va a aparecer tanto en nuestro c\u00f3digo.</li> <li>Como hemos dicho, los objetos gestionados por el contexto de persistencia son los que representan nuestro modelo del dominio. Estos objetos son de la clase <code>NSManagedObject</code> o de clases descendientes de ella. Conforme vayamos realizando operaciones en la aplicaci\u00f3n iremos llen\u00e1ndolos de datos, relacion\u00e1ndolos entre s\u00ed, guard\u00e1ndolos, busc\u00e1ndolos, etc.</li> </ul> <p>Gestionar tantas clases puede ser complicado, por lo que desde hace unas cuantas versiones de Core Data tenemos disponible el <code>NSPersistentContainer</code>, que permite crear todo el stack de manera sencilla, como veremos en el siguiente apartado.</p> <p>Finalmente, si para buscar datos en una base de datos relacional se usa SQL, para recuperar objetos del almacenamiento persistente en Core Data usaremos <code>NSFetchRequest</code>. Al igual que en SQL podemos ejecutar consultas especificando las condiciones que deben cumplir los objetos a recuperar.</p>"},{"location":"cap3/3.2_stack/","title":"A\u00f1adir soporte de core data al proyecto","text":"<p>Vamos a introducir las funcionalidades b\u00e1sicas de Core Data implementando una peque\u00f1a aplicaci\u00f3n para almacenar y listar notas de texto.</p> <p>Lo primero que necesitamos para poder trabajar con Core Data es inicializar su stack, es decir instanciar las clases y crear los archivos de configuraci\u00f3n necesarios para poder almacenar y recuperar objetos persistentes. </p> <p>Salvo que tengamos necesidades especiales no es necesario escribir el c\u00f3digo de inicializaci\u00f3n manualmente, Xcode lo puede hacer por nosotros. Para ello, hay que marcar la casilla de \"Use Core Data\" que aparece al crear un nuevo proyecto de Xcode, tras elegir la plantilla. </p> <p>Crea un nuevo proyecto <code>NotasCoreData</code> usando como plantilla App y aseg\u00farate de que en la segunda pantalla del asistente de creaci\u00f3n en el desplegable de Storage seleccionas la opci\u00f3n de Core Data .</p> <p>Seleccionar esta opci\u00f3n tiene dos efectos:</p> <ul> <li>Crea un archivo con el mismo nombre del proyecto (y extensi\u00f3n <code>.xcdatamodeld</code>) donde se va a almacenar nuestro modelo de datos. En el \"Project Navigator\" de Xcode aparece con el t\u00edpico icono de almacenamiento o base de datos.</li> <li>Incluye una serie de m\u00e9todos auxiliares en la clase <code>AppDelegate</code> para ayudarnos a trabajar con Core Data sin tener que escribir el c\u00f3digo que inicializa el stack desde cero (<code>persistentContainer</code>). Adem\u00e1s nos da un m\u00e9todo auxiliar para guardar datos (<code>saveContext</code>) </li> </ul> <pre><code>lazy var persistentContainer: NSPersistentContainer = {\n   let container = NSPersistentContainer(name: \"PruebaCoreData\")\n    container.loadPersistentStores(completionHandler: { (storeDescription, error) in\n        if let error = error as NSError? {\n             fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")\n        }\n    })\n    return container\n}()\n\n// MARK: - Core Data Saving support\nfunc saveContext () {\n    let context = persistentContainer.viewContext\n    if context.hasChanges {\n        do {\n            try context.save()\n        } catch {\n            let nserror = error as NSError\n            fatalError(\"Unresolved error \\(nserror), \\(nserror.userInfo)\")\n        }\n    }\n}\n</code></pre> <p>El <code>persistentContainer</code> nos permite acceder al <code>NSManagedObjectContext</code>, mediante su propiedad <code>viewContext</code>. Esto, que es lo que se denomina el contexto de persistencia es lo que necesitaremos para guardar y recuperar objetos.</p> <p>Tambi\u00e9n puedes a\u00f1adir soporte de Core Data a cualquier proyecto  ya creado, aunque no lo crearas marcando la casilla \"use core data\". Simplemente se trata de a\u00f1adir manualmente el fichero del modelo de datos y tambi\u00e9n el c\u00f3digo de Core Data en el <code>AppDelegate</code>. Para todos los detalles, puedes seguir por ejemplo las instrucciones de este tutorial. </p>"},{"location":"cap3/3.3_entidades/","title":"Ejercicio parte I. almacenar datos","text":"<p>Info</p> <p>Esta secci\u00f3n es un ejercicio a seguir paso a paso que vale 0.5 puntos de la nota del bloque de iOS</p>"},{"location":"cap3/3.3_entidades/#crear-las-entidades-025-puntos","title":"Crear las entidades (0,25 puntos)","text":"<p>Las entidades son los objetos que queremos hacer persistentes en nuestra aplicaci\u00f3n. Debemos especificar sus propiedades (nombre y tipo) y como veremos en sesiones posteriores podemos establecer relaciones con otros objetos.</p> <p>Para gestionar las entidades debemos editar el archivo <code>xcdatamodeld</code>. En el editor visual de Xcode podemos, entre otras cosas, a\u00f1adir entidades. Vamos a crear la \u00fanica entidad que necesitamos en nuestra aplicaci\u00f3n: <code>Nota</code>. Para ello seguir estos pasos:</p> <ol> <li>Abrir el modelo de datos: por defecto Xcode lo crea con el mismo nombre que el proyecto y extensi\u00f3n <code>xcdatamodeld</code>. </li> <li>A\u00f1adir una entidad pulsando el bot\u00f3n <code>Add Entity</code> de la parte inferior. Crear\u00e1 una nueva entidad llamada por defecto <code>Entity</code>. Podemos cambiarle el nombre haciendo doble clic sobre \u00e9l. Cambiarle el nombre a la entidad a <code>Nota</code> </li> <li>A\u00f1adir los atributos pulsando sobre el bot\u00f3n <code>+</code> de la secci\u00f3n <code>Attributes</code>. Para cada atributo hay que especificar su nombre y tipo. A\u00f1adiremos dos atributos, <code>fecha</code>, de tipo <code>Date</code> y <code>texto</code> de tipo <code>String</code></li> </ol> <p>IMPORTANTE: Los nombres de las entidades deben comenzar por may\u00fascula y los nombres de los atributos por min\u00fascula. El editor no nos dejar\u00e1 hacer lo contrario.</p> <p></p> <p>Selecciona la entidad <code>Nota</code> en el editor y selecciona el <code>Data Model Inspector</code> en el panel de la derecha de Xcode (el cuarto icono ). En el apartado <code>Class</code> ver\u00e1s los datos de la clase Swift que Xcode va a autogenerar para representar a tu entidad. </p> <p>Por defecto:</p> <ul> <li><code>Name</code>: El nombre de la clase va a ser el mismo que la entidad</li> <li><code>Module</code>: por defecto no se crea en un m\u00f3dulo sino en el \"Global Namespace\", lo que quiere decir que no te har\u00e1n falta <code>import</code> para usarla</li> <li><code>Codegen</code>: aqu\u00ed deber\u00eda aparecer seleccionado <code>Class definition</code>, ese es el m\u00e9todo que usa Xcode para generar el c\u00f3digo , lo veremos con m\u00e1s detalle en la siguiente sesi\u00f3n.</li> </ul> <p>Para terminar, aseg\u00farate de guardar el <code>.xcdatamodel</code> (<code>File &gt; Save</code>). Hay veces que no se genera la clase Swift correspondiente a la entidad si no se hace esto</p>"},{"location":"cap3/3.3_entidades/#crear-datos-persistentes-025-puntos","title":"Crear datos persistentes (0,25 puntos)","text":"<p>Aqu\u00ed nos ocuparemos de crear y guardar una nueva nota. Por el momento no se podr\u00e1n editar ni borrar notas, para simplificar la aplicaci\u00f3n, \u00fanicamente crear notas nuevas.</p>"},{"location":"cap3/3.3_entidades/#la-interfaz-de-usuario-para-crear-notas","title":"La interfaz de usuario para crear notas","text":"<p>En la (por el momento) \u00fanica pantalla de la aplicaci\u00f3n a\u00f1adir los siguientes componentes:</p> <ul> <li>Un campo de texto de varias l\u00edneas (<code>text view</code>) para escribir la nota en s\u00ed.</li> <li>Una etiqueta (<code>label</code>) para mostrar la fecha y hora de la nota </li> <li>Un par de botones, uno para crear una nueva nota en blanco y otro para guardar la nota actual</li> </ul> <p>Una vez a\u00f1adidos los componentes, hay que crear un outlet para la  etiqueta y el campo de texto y as\u00ed poder acceder a/cambiar su contenido por c\u00f3digo. Recordad que hay que hacer <code>Ctrl+Arrastrar</code> desde el componente hasta el archivo donde queremos crear la propiedad (en nuestro caso <code>ViewController.swift</code>).</p> <p>Adem\u00e1s hay que crear un action para cada bot\u00f3n, para poder ejecutar nuestro c\u00f3digo cuando se pulsen (con <code>Ctrl+Arrastrar</code> igual que antes). Debemos vincular los action al evento <code>Touch up inside</code>, que es el que aparece por defecto.</p>"},{"location":"cap3/3.3_entidades/#el-codigo-que-implementa-crear-nueva-nota","title":"El c\u00f3digo que implementa \u201ccrear nueva nota\u201d","text":"<p>Debes implementar el c\u00f3digo del action del bot\u00f3n de \"crear\".  Este c\u00f3digo simplemente limpiar\u00e1 la etiqueta de la fecha y el campo de texto de varias l\u00edneas asign\u00e1ndoles a las tres la cadena vac\u00eda. </p>"},{"location":"cap3/3.3_entidades/#el-codigo-que-implementa-el-guardado","title":"El c\u00f3digo que implementa el guardado","text":"<p>En el c\u00f3digo del action asociado al bot\u00f3n de \u201cguardar\u201d debemos tomar el valor del campo de texto, crear una nueva nota con  este texto y la fecha y hora actual y hacerla persistente. Adem\u00e1s actualizaremos la etiqueta con la fecha y hora actual para que muestre cu\u00e1ndo se ha guardado la nota. Vamos a verlo paso a paso.</p> <p>Para crear un nuevo objeto persistente debemos solicit\u00e1rselo al contexto, ya que este debe gestionar su ciclo de vida y si lo cre\u00e1ramos nosotros llamando al inicializador el contexto desconocer\u00eda de su existencia.</p> <p>Lo primero por tanto es obtener la referencia al contexto de persistencia. Como hemos visto en la secci\u00f3n anterior, en la plantilla de Xcode se guarda todo lo de Core Data en el application delegate, por lo que vamos a obtenerlo de ah\u00ed</p> <p>En el action asociado al bot\u00f3n de \"guardar\" a\u00f1ade el siguiente c\u00f3digo:</p> <pre><code>//No te olvides de a\u00f1adir este import AL PRINCIPIO DEL ARCHIVO      \nimport CoreData\n\n//obtenemos una referencia al \"application delegate\" de la aplicaci\u00f3n\n//En nuestro caso es de la clase AppDelegate\n//si esto fallara no tiene sentido continuar, de ah\u00ed el guard...else return\nguard let miDelegate = UIApplication.shared.delegate as? AppDelegate else {\n    return\n}\n//el acceso al API de core data nos lo da el persistent container\n//Lo que m\u00e1s usaremos (con mucho) es el contexto de persistencia\nlet miContexto = miDelegate.persistentContainer.viewContext\n</code></pre> <p>Hay que recalcar de nuevo que el hecho de que el <code>persistentContainer</code> est\u00e9 dentro del  delegate no es propio de Core Data en s\u00ed, sino de la plantilla generada por Xcode para inicializar el stack.</p> <p>Para crear un nuevo objeto necesitamos relacionarlo con el contexto de persistencia. La clase <code>Nota</code> generada por Xcode tendr\u00e1 un inicializador que acepta como par\u00e1metro el contexto:</p> <pre><code>let nuevaNota = Nota(context:miContexto)\nnuevaNota.fecha = Date()\nnuevaNota.texto = \"&lt;asignar aqu\u00ed el contenido del text view&gt;\"\n</code></pre> <p>Si Xcode da error con el c\u00f3digo anterior y no reconoce la clase <code>Nota</code> puedes probar a recompilar el proyecto con <code>Product &gt; Clean Build Folder</code> y luego <code>Product &gt; Build</code>. A veces se genera el c\u00f3digo para <code>Nota</code> pero no se compila o a veces no se ha generado. Tambi\u00e9n ayuda a veces ir al <code>.xcdatamodel</code> y guardarlo: (<code>File &gt; Save</code>). Como \u00faltimo recurso puedes salir de Xcode y volver a entrar (<code>Xcode &gt; Quit Xcode</code>).</p> <p>Finalmente guardamos el objeto en el almacenamiento persistente. Esto se hace guardando el contexto, que guardar\u00e1 todos los objetos pendientes. El m\u00e9todo <code>save</code> puede lanzar una excepci\u00f3n que debemos tratar de alg\u00fan modo, en este ejemplo usamos un <code>do...catch</code></p> <pre><code>do {\n   try miContexto.save()\n} catch {\n   print(\"Error al guardar el contexto: \\(error)\")\n}\n</code></pre> <p>El m\u00e9todo de utilidad llamado <code>saveContext</code> de la plantilla generada por Xcode hace algo muy similar a lo anterior, aunque si falla genera un error fatal que causa la terminaci\u00f3n inmediata de la aplicaci\u00f3n.</p> <p>Faltar\u00eda actualizar la etiqueta con la fecha y hora de la nota para que refleje la fecha asignada, y tambi\u00e9n mostrar un mensaje al usuario indicando que la nota se ha guardado. Escribe el c\u00f3digo necesario para hacer esto:</p> <ul> <li>Puedes convertir la fecha a texto de modo simple con el m\u00e9todo de la clase <code>Date</code> llamado <code>formatted()</code> (si quisieras m\u00e1s control sobre el formato, que aqu\u00ed no es necesario, podr\u00edas usar la clase <code>DateFormatter</code>).</li> <li>Puedes mostrar un mensaje al usuario con un <code>UIAlertController</code></li> </ul> <pre><code>//En el view controller\nlet alerta = UIAlertController(title: \"T\u00edtulo\", message: \"Mensaje\", preferredStyle: .alert)\nalerta.addAction(UIAlertAction(title: \"Aceptar\", style: .default))\npresent(alerta, animated: true)\n</code></pre> <p>Tal y como est\u00e1 ahora el c\u00f3digo, cada vez que pulses sobre <code>Guardar</code> se crear\u00e1 una nueva nota, as\u00ed que aunque no modifiques el texto si pulsas varias veces tendr\u00e1s varias notas, que ser\u00e1n iguales en contenido, aunque no con la misma fecha/hora). No es necesario que soluciones esto, d\u00e9jalo as\u00ed por el momento.</p>"},{"location":"cap3/3.4_recuperar_datos/","title":"Ejercicio parte II. recuperar los datos","text":"<p>Info</p> <p>Esta secci\u00f3n es un ejercicio a seguir paso a paso que vale 0,5 puntos de la nota del bloque de iOS</p> <p>Vamos a a\u00f1adir una pantalla donde se puedan consultar las notas que tenemos almacenadas. Las listaremos en una table view y por el momento se ver\u00e1n todas, no se podr\u00e1n filtrar (a\u00f1adiremos esa posibilidad cuando veamos la sintaxis de las \"consultas\" o fetch requests).</p> <p>Para recuperar todas las instancias de una entidad como un array debemos crear y ejecutar una fetch request sin \"predicado\" (sin condiciones, como si fuera un <code>SELECT</code> sin <code>WHERE</code>), por ejemplo para listar todas las <code>Nota</code>s har\u00edamos algo como:</p> <pre><code>//IMPORTANTE: estamos poniendo los tipos de request y results para que se vea cu\u00e1les son\n//pero el compilador no nos obligar\u00e1 a ponerlos\nlet request : NSFetchRequest&lt;Nota&gt; = Nota.fetchRequest()\n//la l\u00ednea anterior la podr\u00edamos poner tambi\u00e9n como\n//let request = NSFetchRequest(entityName:\"Nota\")\n//es probable que lo ve\u00e1is as\u00ed en muchos libros/ejemplos de c\u00f3digo\n\n//ejecutamos la query\n//suponiendo que \"miContexto\" sea el contexto de persistencia\nlet results : [Nota] = try! miContexto.fetch(request)\n</code></pre> <p>Vamos a hacer esto en nuestra app, aunque necesitaremos enlazar este c\u00f3digo con la parte de UI.</p>"},{"location":"cap3/3.4_recuperar_datos/#la-interfaz-de-usuario","title":"La interfaz de usuario","text":"<p>Sigue estos pasos:</p> <ul> <li>Crear el Tab Bar Controller: teniendo seleccionada la \u00fanica pantalla de la aplicaci\u00f3n, ve al men\u00fa y selecciona <code>Editor &gt; Embed In &gt; Tab Bar Controller</code>. Se crear\u00e1 el tab bar controller, por el momento con una \u00fanica \"solapa\" que ser\u00e1 la pantalla de creaci\u00f3n de notas</li> <li>En la pantalla de creaci\u00f3n de notas, pulsa sobre el item de la barra inferior para editarlo, y ponle como <code>Title</code> por ejemplo <code>Nueva</code>, para que se vea que es la pantalla de creaci\u00f3n de notas</li> <li>Crear la pantalla para listar notas: Arrastrar al storyboard un <code>Table view controller</code>. Recuerda que es una especie de tabla a \u201cpantalla completa\u201d.</li> <li>Vincular la nueva pantalla al tab bar controller: hacer <code>Ctrl+Arrastrar</code> desde la pantalla del tab bar hasta la de listado de notas. En el men\u00fa contextual elegir como tipo del segue el de, <code>View Controllers</code> (bajo <code>Relationship Segue</code>).<ul> <li>Cambia el t\u00edtulo del item de la barra inferior para que ponga \"Lista\" o algo similar. </li> </ul> </li> <li>Vamos a configurar la interfaz de la nueva pantalla<ul> <li>Cambia el aspecto del prototipo de la tabla: pulsa sobre la celda prototipo de la tabla, y en las propiedades cambia el <code>Style</code> a `Basic </li> <li>Pon un reuse identifier: pon alg\u00fan <code>Identifier</code> por ejemplo <code>MiCelda</code> (recuerda que este identificador se emplea luego en el c\u00f3digo para solicitar al sistema instancias reutilizables de celdas)</li> </ul> </li> <li>Ahora vamos a configurar el controlador de la pantalla<ul> <li>Primero tenemos que crear un controlador (<code>File&gt;New&gt;File...</code>). De las plantillas que aparecen usa <code>Cocoa Touch Class</code>, as\u00ed Xcode generar\u00e1 c\u00f3digo por nosotros. La clase  se debe llamar <code>ListaNotasController</code> y heredar\u00e1 de <code>UITableViewController</code>. </li> </ul> </li> </ul> <p></p> <ul> <li>Ahora hacer que la nueva clase sea el controlador de la pantalla de listado de notas: <ul> <li>en el storyboard tienes que seleccionar la pantalla de listado de notas (primero de los iconos de la barra superior, el de fondo amarillo) </li> <li>En el Identity Inspector (cuarto de los iconos del panel de la derecha de Xcode, ), como <code>Class</code> poner <code>ListaNotasController</code></li> </ul> </li> </ul> <p>Pon un <code>print(\"hola soy ListaNotasController\")</code>  en el <code>viewDidLoad</code> del <code>ListaNotasController</code> para comprobar que efectivamente se usa esta clase como controlador de la nueva pantalla.</p> <p>Prueba  a ejecutar el proyecto para ver que funciona el cambio de pantallas en el tab bar controller y que efectivamente en la pantalla de lista aparece el <code>print</code> hecho por  <code>ListaNotasController</code>.</p>"},{"location":"cap3/3.4_recuperar_datos/#el-codigo-de-la-pantalla-de-listado","title":"El c\u00f3digo de la pantalla de listado","text":"<p>En la tabla vamos a mostrar un array de notas. Lo primero ser\u00e1 definir una propiedad para almacenarlas en la clase <code>ListaNotasController</code></p> <pre><code>//RECUERDA que hace falta este import al principio del archivo\nimport CoreData\n\nclass ListaNotasController: UITableViewController {\n   var listaNotas : [Nota]!\n\n}\n</code></pre> <p>Solo nos queda rellenar el array de notas. En <code>ListaNotasController</code> crea un m\u00e9todo</p> <pre><code>override func viewWillAppear(_ animated: Bool) {\n\n}\n</code></pre> <p>Vamos a rellenarlo de c\u00f3digo. Para recuperar datos de Core Data se usa un fetch request, que ser\u00eda algo as\u00ed como una consulta. para crearlo, inicializamos una instancia pas\u00e1ndole el nombre de la entidad resultado de la consulta. Para ejecutarlo, llamamos al m\u00e9todo <code>fetch</code> del contexto. Veamos un ejemplo. Escribe el siguiente c\u00f3digo en el <code>viewWillAppear</code> (Recuerda que debes sacar de alg\u00fan lado el contexto de Core Data (<code>miContexto</code>)). Este c\u00f3digo todav\u00eda no mostrar\u00e1 las notas en la tabla pero al menos s\u00ed por la consola.</p> <pre><code>let request = Nota.fetchRequest()\n//ACLARACION: \"miContexto\" es el contexto de Core Data \n//FALTA el c\u00f3digo que obtiene \"miContexto\", como se ha hecho en ejemplos anteriores\n//Ejecutamos la \"query\"\nlet notas = try! miContexto.fetch(request) \nfor nota in notas {\n   print(nota.texto!)\n}\n</code></pre> <p>N\u00f3tese que los fetch request usan tipos. Es decir, devuelven un conjunto de elementos de una clase determinada, en nuestro caso <code>Nota</code>.</p> <p>Si pruebas el proyecto, al navegar a la pantalla de lista, los textos de las notas deber\u00edan aparecer en la consola de Xcode (aunque no en la pantalla del simulador).</p> <p>Para que los datos de las notas aparezcan en la tabla, debes:</p> <ul> <li>Asignar el valor devuelto por <code>miContexto.fetch</code> a la propiedad <code>self.listaNotas</code>, que has creado antes</li> <li>Forzar el refresco de la tabla para que aparezcan los datos. Tras asignar el valor a listaNotas, haz <code>self.tableView.reloadData()</code> (En un <code>UITableViewController</code> la propiedad <code>tableView</code> referencia a la tabla, no hace falta crear el outlet)</li> <li>Modificar los m\u00e9todos que ha creado Xcode:<ul> <li><code>numberOfSections</code> debe devolver 1 en vez de 0, ya que la tabla tiene 1 secci\u00f3n</li> <li><code>tableView(_ tableView: UITableView, numberOfRowsInSection section: Int)</code> debe devolver el tama\u00f1o del array <code>listaNotas</code> (propiedad <code>count</code>)</li> <li>El siguiente m\u00e9todo, que est\u00e1 comentado, debes descomentarlo, y hacer un par de modificaciones:</li> <li>Donde hace el <code>dequeReusableCell...</code>, cambia el identificador de la celda por el que hayas elegido t\u00fa antes al crear esta pantalla (aqu\u00ed se suger\u00eda <code>MiCelda</code>)</li> <li>Donde pone el comentario <code>Configure the cell...</code> hacer que como texto de la celda aparezca el texto de la nota correspondiente</li> </ul> </li> </ul> <pre><code>cell.textLabel?.text = self.listaNotas[indexPath.row].texto\n</code></pre>"},{"location":"cap3/apendice_ver_almacenamiento/","title":"Ap\u00e9ndice. C\u00f3mo examinar el almacenamiento persistente","text":"<p>No es necesario que sigas estos pasos en el ejercicio, pero s\u00ed es interesante que los leas para poder entender mejor el funcionamiento interno de Core Data.</p> <p>Podemos examinar el almacenamiento persistente, que como ya hemos visto el c\u00f3digo Swift del delegate, se configura por defecto como una base de datos SQLite con el mismo nombre del proyecto. Podemos localizar el archivo tecleando desde la terminal:</p> <pre><code>find . -name MisNotas.sqlite -print\n</code></pre> <p>o m\u00e1s sencillo, emplear alguna utilidad como SimSim, que ya hemos usado en otras sesiones para localizar el directorio con el sandbox de nuestra aplicaci\u00f3n. La base de datos se crea por defecto en el directorio <code>Library/Application Support</code> del sandbox.</p> <p>Si abrimos la base de datos usando alguna utilidad gr\u00e1fica o bien desde la terminal (movi\u00e9ndose al directorio donde est\u00e1 el <code>MisNotas.sqlite</code> y tecleando:)</p> <pre><code>sqlite3 MisNotas.sqlite\n</code></pre> <p>Deber\u00eda aparecer el prompt de SQLite donde podemos por ejemplo ver la estructura de la BD, tecleando</p> <pre><code>sqlite&gt; .schema\n</code></pre> <p>Aparecer\u00e1 algo como </p> <pre><code>CREATE TABLE ZNOTA ( Z_PK INTEGER PRIMARY KEY, Z_ENT INTEGER, Z_OPT INTEGER,\n  ZFECHA TIMESTAMP, ZTEXTO VARCHAR );\nCREATE TABLE Z_PRIMARYKEY (Z_ENT INTEGER PRIMARY KEY, Z_NAME VARCHAR, Z_SUPER\n  INTEGER, Z_MAX INTEGER);\nCREATE TABLE Z_METADATA (Z_VERSION INTEGER PRIMARY KEY, Z_UUID VARCHAR(255),\n  Z_PLIST BLOB);\n</code></pre> <p>Como se ve, Core Data crea autom\u00e1ticamente una tabla para la entidad <code>Nota</code>, con el mismo nombre (aunque precedida de una curiosa <code>Z</code>, como los nombres de los campos). Crea tambi\u00e9n una columna por cada propiedad, asign\u00e1ndoles el tipo apropiado. Adem\u00e1s autom\u00e1ticamente crea una clave primaria, aunque en la entidad no hemos definido ninguna.</p> <p>Podemos comprobar tambi\u00e9n si se ha guardado la nota ejecutando una sentencia SQL</p> <pre><code>sqlite&gt; select * from ZNOTA;\n</code></pre> <p>Es posible que el <code>select</code> anterior no muestre los registros actualizados, ya que a partir de iOS7 se usa un modo de SQLite que se llama \"Write Ahead Logging\".  En este modo, las transacciones para las que no se ha hecho commit se almacenan en un archivo <code>.wal</code> aparte. </p>"},{"location":"cap3/intro/","title":"Introducci\u00f3n","text":"<p>En este tema nos introduciremos en el API iOS por excelencia para almacenar datos: Core Data. Este es uno de los APIs m\u00e1s complejos de la plataforma, y por eso le vamos a dedicar bastante tiempo. Empezaremos por implementar de manera guiada un ejemplo sencillo: una aplicaci\u00f3n para guardar notas de texto. Esta aplicaci\u00f3n nos servir\u00e1 para irnos familiarizando con los conceptos b\u00e1sicos que hay que conocer para trabajar con Core Data.</p>"},{"location":"cap4/4.1_crear_modelo/","title":"Crear y editar modelos","text":"<p>El modelo de datos ser\u00eda m\u00e1s o menos el equivalente al esquema entidad/relaci\u00f3n en una base de datos relacional. Con la diferencia de que en Core Data tenemos clases Swift y variables miembro en lugar de tablas y claves ajenas. </p> <p>Normalmente en una aplicaci\u00f3n hay un solo modelo de datos, que se almacena en un archivo <code>.xcdatamodeld</code> (aunque no es habitual, nada nos impide crear varios si la aplicaci\u00f3n lo necesitara). </p> <p>En Xcode, al crear el proyecto con la casilla de \"Use Core Data\" marcada, el asistente nos crea un modelo de datos vac\u00edo con el mismo nombre del proyecto. Lo m\u00e1s habitual es editar el modelo con el editor gr\u00e1fico de Xcode, aunque tambi\u00e9n hay un API Swift para crearlo/manipularlo.</p> <p>El editor tiene dos modos, el modo \"tabla\" donde vemos las entidades y atributos como listas de valores, y el modo \"gr\u00e1fico\" donde podemos ver un diagrama con las entidades y las relaciones entre ellas. Estos modos se cambian con los dos iconos de la esquina inferior derecha del editor (Editor Style). </p>"},{"location":"cap4/4.1_crear_modelo/#entidades","title":"Entidades","text":"<p>Las entidades comparten ciertas caracter\u00edsticas con las clases de la POO y otras con las tablas de una base de datos. Por ejemplo pueden ser abstractas y por tanto no directamente instanciables, como las clases de cualquier lenguaje OO.  Por otro lado tienen relaciones con otras entidades (uno-a-uno, uno-a-muchos,...) y se puede especificar qu\u00e9 debe pasar cuando uno de los \"lados\" de la relaci\u00f3n se elimina, como es t\u00edpico de las bases de datos relacionales.</p> <p>Si seleccionamos una entidad podemos ver sus propiedades en el \"Data Model Inspector\", (Cmd+Alt+4 o clic en el cuarto icono del panel de la derecha de la pantalla)</p> <p></p> <ul> <li><code>Abstract entity</code> es an\u00e1logo a las clases abstractas en POO, indica que la entidad no es directamente instanciable y se usa solo para que otras hereden de ella.</li> <li><code>Parent entity</code> indicar\u00eda que esta instancia hereda las propiedades de otra</li> <li><code>Class</code>: por defecto Xcode crear\u00e1 autom\u00e1ticamente una clase Swift para representar la entidad. Posteriormente veremos d\u00f3nde est\u00e1 este c\u00f3digo y qu\u00e9 estructura tiene.</li> </ul> <p>En versiones antiguas de Xcode el IDE no generaba por defecto las clases y hab\u00eda que generarlas manualmente. Todav\u00eda se puede hacer de este modo si queremos personalizar el c\u00f3digo Swift, como veremos posteriormente.</p>"},{"location":"cap4/4.1_crear_modelo/#atributos-de-la-clase","title":"Atributos de la clase","text":"<p>La caracter\u00edstica m\u00e1s destacada de un atributo es el tipo de datos. Podemos elegir de entre una serie de tipos, que pueden verse en la siguiente imagen del editor. </p> <p></p> <p>La mayor\u00eda son bastante autoexplicativos, salvo los dos \u00faltimos. El tipo binario se usa t\u00edpicamente para im\u00e1genes, audio, .... En cuanto a <code>Transformable</code> nos permite almacenar cualquier clase Swift/Obj-C. Se parece al binario en el sentido de que en el fondo, los datos se van a almacenar tambi\u00e9n en binario, pero con <code>Transformable</code> proporcionamos un medio de hacer la conversi\u00f3n y a partir de ah\u00ed nos \"olvidamos\" de que el dato se est\u00e1 convirtiendo, si trabajamos con clases propias solo veremos el tipo original.</p> <p>Cualquier clase (propia o del sistema) que sea conforme al protocolo <code>NSCoding</code> puede usarse como <code>Transformable</code> e iOS se encargar\u00e1 autom\u00e1ticamente de convertirla a/desde <code>NSData</code>. Veremos m\u00e1s detalles posteriormente.</p> <p>Adem\u00e1s del tipo, las propiedades tienen muchas otras caracter\u00edsticas. Podemos verlas en el \"Data Model Inspector\", haciendo clic sobre el atributo y luego con el atajo (Cmd+Alt+4) o con clic en el cuarto icono del panel de la derecha de la pantalla.</p> <p>Veamos algunas de ellas:</p> <ul> <li><code>Transient</code> significa que no queremos que la propiedad sea persistente. Es t\u00edpico de los valores que son calculados a partir de otros y que podemos volver a calcular f\u00e1cilmente (por ejemplo el total de un pedido).</li> <li><code>Derived</code> significa que la propiedad va a ser un valor calculado a partir de otros atributos, hay una serie de primitivas que podemos aplicar, por ejemplo podemos tener un atributo que cuente la cardinalidad de una relaci\u00f3n (ver apartado siguiente para ver c\u00f3mo se modelan las relaciones), que transforme un atributo de tipo <code>String</code> a formatos como \"todo may\u00faculas\", \"todo min\u00fasculas\", y alguna cosa m\u00e1s. Se recomienda consultar la documentaci\u00f3n de Apple sobre la cuesti\u00f3n, aunque no es demasiado detallada.</li> <li><code>Optional</code> es el contrario del t\u00edpico \"not null\" de las bases de datos. Si un atributo es opcional, puede ser <code>nil</code>. </li> </ul> <p>Hay que distinguir entre un atributo opcional en una entidad y una variable opcional en Swift. Que un atributo de una entidad sea no opcional significa que en el momento de guardar el objeto en el almacenamiento persistente \u00e9ste debe tener un valor no nulo pero en memoria puede haber un intervalo de tiempo mientras vamos \"rellenando\" todas las propiedades en que sea <code>nil</code>. Sin embargo una variable Swift no opcional en ning\u00fan momento puede tener <code>nil</code>.</p> <ul> <li><code>Indexed</code> tambi\u00e9n es el mismo concepto que en BD. Un atributo indexado estar\u00e1 optimizado para las b\u00fasquedas que hagamos sobre \u00e9l pero ocupar\u00e1 m\u00e1s espacio de almacenamiento.</li> <li>Reglas de validaci\u00f3n: valor m\u00ednimo y m\u00e1ximo (si es num\u00e9rico), longitud m\u00ednima y m\u00e1xima (si es cadena), <code>Reg Exp</code>, la expresi\u00f3n regular con la que deben encajar los valores del atributo.</li> <li>Valor por defecto (<code>default</code>) que se asignar\u00e1 autom\u00e1ticamente si no le damos un valor expl\u00edcito.</li> </ul>"},{"location":"cap4/4.1_crear_modelo/#restricciones","title":"Restricciones","text":"<p>Las restricciones o constraints nos permiten especificar uno o m\u00e1s campos en los que no  queremos que se puedan repetir valores, es decir la t\u00edpica restricci\u00f3n de unique de las bases de datos relacionales. </p> <p>De momento en Core Data no existe otro tipo de restricci\u00f3n que la de valores \u00fanicos. Se pueden especificar condiciones que deben cumplir los atributos, como por ejemplo longitud m\u00ednima y m\u00e1xima para un <code>String</code>, pero eso es lo que se denominan validaciones y se explica en otro apartado del tema.</p> <p>Para a\u00f1adir restricciones, en el editor del modelo de datos, seleccionar la entidad, y en el recuadro de <code>Constraints</code> del <code>Data model inspector</code> (panel derecho de Xcode):</p> <ol> <li>Pulsar sobre <code>+</code>. Aparecer\u00e1 una l\u00ednea que pone <code>comma, separated, properties</code>, indicando que aqu\u00ed podemos teclear una lista de atributos separados por comas</li> <li>Clicar sobre esa l\u00ednea, y pulsar ENTER para hacerla editable</li> <li>Escribir el atributo o lista de atributos separados por comas</li> </ol> <p>La restricci\u00f3n de valores \u00fanicos se chequea en el momento de guardar el contexto de persistencia, por lo que tenemos que indicar qu\u00e9 suceder\u00e1 si ya hay un objeto persistente con un determinado valor \u00fanico y estamos guardando otro con el mismo valor: \u00bfdeber\u00eda ser un error, el nuevo deber\u00eda sobreescribir al antiguo?... Es decir, debemos definir lo que se conoce como la merge policy de Core Data. Esta pol\u00edtica se define por c\u00f3digo Swift cuando se crea el stack de Core Data, de modo que si usamos la plantilla est\u00e1ndar generada por Xcode, tendremos que irnos al <code>AppDelegate</code> y modificar el m\u00e9todo <code>loadPersistentStores()</code> definiendo una <code>mergePolicy</code>, ya que por defecto no se define ninguna:</p> <pre><code>...\ncontainer.loadPersistentStores(completionHandler: { (storeDescription, error) in\n     container.viewContext.mergePolicy = NSMergePolicy.mergeByPropertyObjectTrump\n...\n</code></pre> <p>en el ejemplo, estamos aplicando la pol\u00edtica de que en caso de conflicto por valores \u00fanicos, el nuevo objeto \"machaca\" el que ya hay en el store. Tambi\u00e9n existe la pol\u00edtica inversa, y algunas otras distintas, se recomienda consultar la documentaci\u00f3n de <code>NSMergePolicy</code> para m\u00e1s informaci\u00f3n.</p>"},{"location":"cap4/4.1_crear_modelo/#relaciones","title":"Relaciones","text":"<p>Las relaciones en Core Data son muy similares al concepto equivalente en BD relacionales: vinculan una entidad con otra u otras, generalmente de otro tipo.</p> <p>Cuando creamos una relaci\u00f3n usando el estilo de \"tabla\" en el editor visual, las tres caracter\u00edsticas directamente editables son:</p> <ul> <li>Nombre: es arbitrario y la \u00fanica condici\u00f3n es que debe comenzar por min\u00fascula, al igual que las propiedades. No obstante, una pr\u00e1ctica com\u00fan es ponerle el mismo nombre que la entidad a la que vincula pero en min\u00fascula. Por ejemplo si tenemos un <code>Mensaje</code> y queremos establecer una relaci\u00f3n con el <code>Usuario</code> que lo ha enviado llamar\u00edamos a la relaci\u00f3n simplemente <code>usuario</code>. Si es una relaci\u00f3n uno a muchos se suele usar el plural. As\u00ed, si tenemos un <code>`Usuario</code> y queremos vincularlo con todos sus mensajes llamar\u00edamos <code>mensajes</code> a la relaci\u00f3n.</li> <li>Destino: la entidad vinculada</li> <li>Inversa: Se recomienda que todo v\u00ednculo entre entidades tenga su relaci\u00f3n inversa, que es la que nos permite \"volver al punto de partida\". En el ejemplo de mensajes/usuarios, la inversa de la relaci\u00f3n <code>usuario</code> ser\u00eda <code>mensajes</code>.</li> </ul> <p>Las relaciones que no tienen inversa generan warnings en Xcode, ya que Core Data usa la bidireccionalidad para poder mantener la consistencia del grafo de objetos cuando se eliminan entidades.</p> <p>Al igual que con las entidades y las propiedades, podemos cambiar los atributos de una relaci\u00f3n seleccion\u00e1ndola y yendo al \u201cData Model Inspector\u201d, (recuerda, Cmd+Alt+4 o clic en el cuarto icono del panel de la derecha de la pantalla).</p> <ul> <li><code>Transient</code> y <code>optional</code> son equivalentes a los atributos del mismo nombre usados en las propiedades.</li> <li><code>Delete rule</code> es la t\u00edpica regla a aplicar cuando se borra la entidad \u201cfuente\u201d de la relaci\u00f3n: por ejemplo con <code>cascade</code> si se borra la entidad, las relacionadas tambi\u00e9n lo hacen autom\u00e1ticamente, con <code>deny</code> no se puede borrar la entidad si hay relacionadas, con <code>nullify</code> la relaci\u00f3n inversa se pone a <code>nil</code> y con <code>no action</code> la relaci\u00f3n inversa queda tal cual (aunque apuntar\u00e1 a un objeto que ya no existe (!))</li> <li>con <code>Type</code> podemos indicar si es una relaci\u00f3n uno a uno o uno a muchos. Las relaciones muchos a muchos las conseguimos poniendo tanto la relaci\u00f3n como la inversa con el tipo \u201ca muchos\u201d.</li> </ul> <p>En Xcode 14 se ha eliminado el modo <code>Graph</code> del editor de data models. En el momento de la redacci\u00f3n de esta nota no est\u00e1 claro si esta eliminaci\u00f3n es o no permanente, por lo que de momento no se ha eliminado la parte de los apuntes que se refiere a este modo de representaci\u00f3n/edici\u00f3n en forma de grafo.</p> <p>En el editor de data models de Xcode, si nos ponemos en modo <code>Graph</code> podemos ver gr\u00e1ficamente las relaciones entre objetos y crearlas con ctrl-click en la entidad \"origen\" y arrastrando hasta la entidad destino. Las relaciones \"uno a uno\" aparecen con una \u00fanica punta de flecha en el destino, y las \"uno a muchos\" con dos.</p> <p></p> <p>En el caso de relaciones \u201ca muchos\u201d podemos especificar: </p> <ul> <li>Si queremos que sean ordenadas (<code>ordered</code>). Por ejemplo nos dar\u00e1 lo mismo el orden para un <code>G\u00e9nero</code> musical que tiene asociados muchos <code>Disco</code>s, pero no es indiferente en el caso de una <code>Conversacion</code> y los <code>Mensaje</code>s que la componen.</li> <li>La cardinalidad m\u00ednima y m\u00e1xima (podemos fijar un l\u00edmite num\u00e9rico o dejarlo vac\u00eda (unbounded)</li> </ul>"},{"location":"cap4/4.1_crear_modelo/#fetched-properties","title":"Fetched properties","text":"<p>Son similares a las relaciones, pero no son bidireccionales. Cada fetched property est\u00e1 basada en una consulta (fetch request). Por ejemplo podr\u00edamos tener una propiedad <code>mensajes_recientes</code> que nos devolviera los mensajes que ha enviado recientemente un usuario.</p> <p>Para crear una fetched property mantenemos pulsado el bot\u00f3n de <code>Add attribute</code> hasta que aparezca el men\u00fa contextual, donde seleccionamos <code>Add fetched property</code>. Tenemos que especificar su nombre y el predicado (la condici\u00f3n de la \u201cconsulta asociada\u201d). Veremos alg\u00fan ejemplo cuando hablemos de consultas en Core Data. </p> <p>Cuidado, las fetched properties no son din\u00e1micas, sino lazy, su valor no se recalcula autom\u00e1ticamente cada vez que accedemos a ellas, hay que recalcularlas expl\u00edcitamente con <code>refreshObject:mergeChanges:</code>.</p>"},{"location":"cap4/4.1_crear_modelo/#fetch-requests","title":"Fetch requests","text":"<p>En el editor podemos crear fetch requests predefinidas. Estas requests son lo que en una base de datos llamar\u00edamos consultas o queries. </p> <p>Si mantenemos pulsado el bot\u00f3n de <code>Add Entity</code> unos segundos aparecer\u00e1 un men\u00fa contextual y en \u00e9l podemos elegir la opci\u00f3n <code>Add fetch request</code>. Podemos a\u00f1adir gr\u00e1ficamente las condiciones deseadas. Veremos la sintaxis de las condiciones y m\u00e1s detalles sobre este tema en la sesi\u00f3n sobre consultas en Core Data.</p>"},{"location":"cap4/4.2_clases_propias/","title":"Modelar las entidades en c\u00f3digo Swift","text":"<p>Desde el punto de vista del c\u00f3digo Swift las entidades del modelo ser\u00e1n instancias de clases Swift. As\u00ed, dada la entidad Usuario con ciertos atributos lo que tendremos en Swift es una clase con el mismo nombre y las correspondientes propiedades.</p>"},{"location":"cap4/4.2_clases_propias/#generacion-automatica-de-las-clases","title":"Generaci\u00f3n autom\u00e1tica de las clases","text":"<p>Las clases de nuestro modelo de datos se pueden generar autom\u00e1ticamente y de modo transparente para el desarrollador cada vez que guardemos el modelo de datos (el <code>.xcdatamodeld</code>). </p> <p>En el editor del modelo de datos, si seleccionamos una entidad y accedemos a sus atributos en el panel de la derecha, veremos que hay una secci\u00f3n titulada <code>Class</code> que se ocupa del c\u00f3digo generado, podemos cambiar:</p> <ul> <li>El nombre de la clase generada (por defecto el de la entidad)</li> <li>El m\u00f3dulo de Swift donde se crea la clase (por defecto pone <code>Global Namespace</code>, lo que significa que no har\u00e1 falta ning\u00fan <code>import</code> para referenciar la clase)</li> <li>La estrategia de generaci\u00f3n de c\u00f3digo o <code>codegen</code>. Aqu\u00ed por defecto aparece seleccionada la opci\u00f3n  <code>Class definition</code>, que indica que Xcode va a generar autom\u00e1ticamente todo el c\u00f3digo asociado a la entidad. Con <code>Manual/None</code> habr\u00eda que generar el c\u00f3digo expl\u00edcitamente. Con <code>Category/Extension</code> parte del c\u00f3digo se generar\u00e1 autom\u00e1ticamente y parte de forma manual.</li> </ul> <p>Las clases se vuelven a generar si ha habido cambios cada vez que guardamos el modelo de datos (<code>File&gt;Save</code> o <code>Cmd-S</code>). No se generan en el directorio del proyecto, de modo que no son visibles directamente, sino en un directorio aparte denominado <code>Derived Data</code>, donde Xcode coloca t\u00edpicamente el c\u00f3digo auxiliar generado por \u00e9l. Este directorio por defecto est\u00e1 en otro lugar totalmente distinto del proyecto, podemos ver d\u00f3nde est\u00e1 en la opci\u00f3n <code>File&gt;Project Settings</code>, aunque no es necesario verlo ni recomendable modificar el contenido generado.</p> <p>Si queremos \"echarle un vistazo\" al fuente de las clases generadas sin tener que ir a la carpeta podemos usar el \"truco\" de hacer <code>Cmd-Click</code> sobre el nombre de una clase que tengamos en el c\u00f3digo. Xcode abre autom\u00e1ticamente el archivo en el que se define. Esto funciona con las clases de nuestro proyecto, con las autogeneradas y almacenadas en <code>Derived Data</code> e incluso con clases del sistema, como por ejemplo <code>UIViewController</code>.</p> <p>Cuando una entidad tiene relaciones a uno o a muchos podemos manipular estas relaciones a trav\u00e9s de propiedades y m\u00e9todos de la clase generada. Veremos esto en la secci\u00f3n dedicada a CRUD.</p>"},{"location":"cap4/4.2_clases_propias/#generacion-manual-de-las-clases","title":"Generaci\u00f3n manual de las clases","text":"<p>Desde la versi\u00f3n 8 de Xcode el modo \"autom\u00e1tico\" es el activo por defecto. No obstante en algunos casos nos interesar\u00e1 personalizar el c\u00f3digo generado por Xcode a\u00f1adiendo m\u00e9todos y/o propiedades, y para esto no podemos usar la generaci\u00f3n autom\u00e1tica, ya que por un lado el c\u00f3digo no es directamente visible en el proyecto y por otro Xcode sobreescribir\u00eda los cambios hechos manualmente.</p> <p>Xcode tiene un asistente que puede crear las clases que representan a las entidades. Teniendo seleccionada una entidad cualquiera en el  editor del modelo de datos, elegimos la opci\u00f3n <code>Editor &gt; Create NSManagedObject Subclass...</code> en el men\u00fa de Xcode. Se activar\u00e1 el asistente, que es bastante sencillo de usar. Solo tenemos que elegir el modelo de datos (si es que tenemos m\u00e1s de uno) y las entidades para las que vamos a generar clases.</p> <p>Por cada entidad Xcode generar\u00e1 dos archivos:</p> <ul> <li>Una clase con el mismo nombre que la entidad (aunque el nombre se puede cambiar). Esta clase se declara como una subclase de <code>NSManagedObject</code>, que es la que proporciona la funcionalidad b\u00e1sica a las entidades</li> <li>Una extensi\u00f3n Swift de esta clase. En \u00e9sta se definen las propiedades de la entidad y un conjunto de m\u00e9todos que nos facilitar\u00e1n el trabajo con las relaciones entre entidades.</li> </ul> <p>IMPORTANTE: En este modo de funcionamiento, Xcode no mantiene autom\u00e1ticamente sincronizado el modelo de datos y el c\u00f3digo Swift. Si tras generar las clases modificamos las entidades, tendremos que borrar las clases generadas y volver a generarlas</p> <p>Vamos a ver un ejemplo del tipo de c\u00f3digo que genera Xcode. Si tuvi\u00e9ramos el modelo de datos de la figura</p> <p></p> <p>Tras generar clases para todas las entidades, acabaremos con 6 archivos fuente nuevos, dos por cada entidad. Para cada entidad, el primero de ellos tiene el mismo nombre que la entidad terminado en <code>+CoreDataClass.swift</code>. Si lo abrimos veremos que es la definici\u00f3n de una clase \"vac\u00eda\", marcada con algunas anotaciones especiales para que funcione correctamente la maquinaria interna de Core Data. Por ejemplo, para la entidad <code>Usuario</code> tendr\u00edamos algo como:</p> <pre><code>//  Usuario+CoreDataClass.swift\nimport Foundation\nimport CoreData\n\n@objc(Usuario)\npublic class Usuario: NSManagedObject {\n\n}\n</code></pre> <p>El segundo de los archivos para cada entidad tiene un nombre terminado en <code>+CoreDataProperties.swift</code>. Este archivo contiene una extensi\u00f3n de la clase anterior. El c\u00f3digo generado tiene dos partes diferenciadas.</p> <p>En primer lugar tenemos la definici\u00f3n de las propiedades, que en el ejemplo ser\u00edan algo como</p> <pre><code>@NSManaged public var login: String?\n@NSManaged public var creditos: Int16\n@NSManaged public var password: String?\n@NSManaged public var mensajes: NSSet?\n@NSManaged public var conversaciones: NSOrderedSet?\n</code></pre> <p>N\u00f3tese que en la definici\u00f3n de la clase tenemos no solo las propiedades de la entidad en s\u00ed sino tambi\u00e9n propiedades que representan las relaciones. Por ejemplo en el diagrama puede verse una relaci\u00f3n uno a muchos entre <code>Usuario</code> y <code>Mensaje</code> llamada <code>mensajes</code>, que representar\u00eda los mensajes enviados por un usuario. Esta relaci\u00f3n se representa en c\u00f3digo con la propiedad del mismo nombre. Esto quiere decir que si tenemos un usuario y vamos imprimiendo los objetos contenidos en la propiedad <code>mensajes</code> en realidad estaremos accediendo a la entidad <code>Mensaje</code>. Esto es mucho m\u00e1s sencillo y \"limpio\" que andar haciendo JOINs en SQL para obtener los datos relacionados.</p> <p>Que las relaciones se vean en c\u00f3digo como propiedades es lo que explica la convenci\u00f3n de darle siempre a una relaci\u00f3n el nombre de la entidad destino en singular si es \"a uno\" y en plural si es \"a muchos\", ya que en c\u00f3digo queda bastante natural. Por ejemplo dado un usuario <code>u</code> sus mensajes ser\u00edan accesibles como <code>u.mensajes</code>, y dado un mensaje <code>m</code> la conversaci\u00f3n a la que pertenece estar\u00eda en <code>m.conversacion</code>. </p> <p>N\u00f3tese que las relaciones \"uno a muchos\" se modelan con <code>NSSet</code> si no son ordenadas. Con esta estructura de datos no se nos garantiza un orden determinado al ir iterando por ella. En el caso de ser una relaci\u00f3n marcada como ordenada Xcode habr\u00eda generado un <code>NSOrderedSet</code>.</p> <p><code>NSSet</code> es el \"equivalente\" al  tipo <code>Set</code> de Swift, pero <code>NSSet</code> est\u00e1 definido en la librer\u00eda <code>Foundation</code> y no en la librer\u00eda est\u00e1ndar de Swift, ya que se desarroll\u00f3 inicialmente para usarse en Objective C, que no tiene un tipo nativo para definir conjuntos. Hay que tener en cuenta que Core Data se desarroll\u00f3 originalmente para Objective C, por lo que la infraestructura para implementarlo se ha \"heredado\" de \u00e9ste.</p> <p><code>NSSet</code> y <code>NSOrderedSet</code> complican un poco el trabajo cuando en lugar de simplemente leer datos queremos modificarlos (a\u00f1adir un nuevo mensaje a una conversaci\u00f3n, por ejemplo), ya que en Objective C se diferencia entre colecciones mutables e inmutables. En Swift lo que hace que una colecci\u00f3n sea mutable o no es si la declaramos con <code>let</code> o con <code>var</code>, como en el resto de tipos, pero en <code>Foundation</code> cada colecci\u00f3n tiene dos variantes, la \"versi\u00f3n\" mutable y la inmutable. As\u00ed , los <code>NSSet</code> son inmutables, de modo que no podr\u00edamos a\u00f1adir m\u00e1s elementos a la relaci\u00f3n usando directamente la variable. Tendr\u00edamos que obtener una copia mutable de la colecci\u00f3n y trabajar con ella. Una posibilidad para hacer esto es llamar al m\u00e9todo <code>mutableSetValueForKey</code> de <code>NSManagedObject</code>, que nos devolver\u00e1 un conjunto mutable para una propiedad determinada.</p> <p>Para facilitar el trabajo con las relaciones \"a muchos\" Xcode tambi\u00e9n genera m\u00e9todos de acceso para las colecciones, o accesores. Estos accesores nos permiten a\u00f1adir/eliminar elementos de la colecci\u00f3n. En el caso del <code>Usuario</code>, generar\u00e1 algo como:</p> <pre><code>// MARK: Generated accessors for mensajes\nextension Usuario {\n\n    @objc(addMensajesObject:)\n    @NSManaged public func addToMensajes(_ value: Mensaje)\n\n    @objc(removeMensajesObject:)\n    @NSManaged public func removeFromMensajes(_ value: Mensaje)\n\n    @objc(addMensajes:)\n    @NSManaged public func addToMensajes(_ values: NSSet)\n\n    @objc(removeMensajes:)\n    @NSManaged public func removeFromMensajes(_ values: NSSet)\n}\n</code></pre> <p>De este modo en nuestro c\u00f3digo podemos establecer una relaci\u00f3n entre un determinado usuario y un determinado mensaje sin m\u00e1s que llamar al m\u00e9todo <code>addToMensajes</code>. Por ejemplo podr\u00edamos hacer algo como:</p> <pre><code>//omitimos la parte en la que obtenemos una referencia al contexto de Core Data\nlet u = Usuario(context:miContexto)\nu.login = \"Pepe\"\nu.password = \"123456\"\nlet m = Mensaje(context:miContexto)\nu.addToMensajes(m)\ntry! miContexto.save() \n</code></pre>"},{"location":"cap4/4.2_clases_propias/#generacion-semi-automatica-de-las-clases","title":"Generaci\u00f3n \"semi-autom\u00e1tica\" de las clases","text":"<p>En este modo se generar\u00eda autom\u00e1ticamente solo la extensi\u00f3n Swift donde se definen las propiedades y las relaciones, permitiendo que se mantenga una sincronizaci\u00f3n autom\u00e1tica entre los atributos del modelo de datos y el c\u00f3digo Swift. </p> <p>Por otro lado la clase \"principal\" que hereda de <code>NSManagedObject</code> debemos generarla manualmente como en el apartado anterior, lo que nos permite a\u00f1adir c\u00f3digo propio a la clase (por ejemplo m\u00e9todos de l\u00f3gica de negocio o m\u00e9todos auxiliares) sin problemas de que Xcode nos sobreescriba el c\u00f3digo.</p> <p>Este modo se elige en el editor del modelo de datos yendo a las propiedades de la entidad y seleccionando la opci\u00f3n <code>Category/Extension</code> del desplegable <code>Codegen</code>.</p>"},{"location":"cap4/4.3_CRUD/","title":"CRUD en Core Data","text":"<p>Las operaciones m\u00e1s b\u00e1sicas con Core Data van a ser las de crear, obtener, actualizar y borrar objetos persistentes, es decir operaciones del tipo <code>Create/Read/Update/Delete</code> o CRUD. Aunque ya hemos explicado algo de esto, vamos a verlo aqu\u00ed de modo m\u00e1s sistem\u00e1tico.</p>"},{"location":"cap4/4.3_CRUD/#creacion","title":"Creaci\u00f3n","text":"<p>En nuestro c\u00f3digo Swift estamos acostumbrados a crear objetos llamando simplemente al inicializador correspondiente, y podr\u00edamos estar tentados de hacer algo parecido con los objetos de Core Data, por ejemplo</p> <pre><code>var u = Usuario()\nu.login = \"Pepe\"\n...\n</code></pre> <p>Pero esto no lo podemos hacer con los objetos persistentes, porque Core Data es quien debe gestionar su ciclo de vida y por tanto los debe \"tener controlados\" en todo momento, desde su creaci\u00f3n. Lo adecuado es pedirle a Core Data que cree el objeto para nosotros. Esto lo hacemos llamando al inicializador que recibe el contexto de persistencia como par\u00e1metro: <code>init(context:)</code></p> <pre><code>//para insertar un objeto, recordar que necesitamos el contexto de Core Data\nlet u = Usuario(context:miContexto)\n//tambi\u00e9n se podr\u00eda hacer con\n//let u = NSEntityDescription.insertNewObject(forEntityName: \"Usuario\", into: miContexto) as! Usuario\nu.login = \"Pepe\"\n</code></pre>"},{"location":"cap4/4.3_CRUD/#actualizacion","title":"Actualizaci\u00f3n","text":"<p>Una vez tenemos un objeto gestionado (sea creado con <code>init(context:)</code> o ya existente y recuperado con una fetch request) podemos cambiar sus propiedades y establecer relaciones con otros objetos. No obstante los cambios solo se har\u00e1n persistentes cuando guardemos el contexto de persistencia con <code>save</code>:</p> <pre><code>//suponemos \"usuario\" objeto gestionado por Core Data\n//es decir, se ha obtenido con `init(context:)` o una fetch request\nusuario.login=\"mastermoviles\";\nusuario.password=\"123456\";\n\n//AHORA es cuando se guardan las modificaciones de modo persistente\ntry! miContexto.save() \n</code></pre> <p>Dicho de otro modo, los cambios que hacemos en los objetos son cambios \u00fanicamente dentro del contexto (o si se quiere decir as\u00ed, \u201cen la memoria\u201d). Cuando usamos <code>save</code> los cambios se hacen tambi\u00e9n en el almacenamiento (store).</p>"},{"location":"cap4/4.3_CRUD/#relaciones-a-uno","title":"Relaciones \"a uno\"","text":"<p>Las relaciones \"uno a uno\" se representan con propiedades que son objetos \"individuales\". Por ejemplo un <code>Mensaje</code> pertenece a un <code>Usuario</code> a trav\u00e9s de la relaci\u00f3n <code>usuario</code>. De este modo, podemos tratar la relaci\u00f3n simplemente como una propiedad m\u00e1s.</p> <pre><code>mensaje.usuario = nuevoUsuario\n</code></pre> <p>Recordemos que normalmente las relaciones son bidireccionales. Si establecemos una relaci\u00f3n entre objetos, Core Data se encargar\u00e1 autom\u00e1ticamente de actualizar la inversa. </p> <pre><code>let m = Mensaje(context:miContexto) \nm.texto = \"hola amigos\"\nm.fecha = Date()\n//Supongamos \"u\" un objeto Usuario gestionado por Core Data\n//Establecemos una relaci\u00f3n Mensaje-&gt;Usuario\nm.usuario = u;\n//Core Data hace lo propio con Usuario-&gt;&gt;Mensaje (1 a N)\nprint(\"Mensajes del usuario \\(u.login)\")\nfor mensaje in u.mensajes {\n    print(\"\\(mensaje.fecha) \\(mensaje.texto)\")\n}\n</code></pre> <p>En el ejemplo anterior decimos que un mensaje pertenece a un determinado usuario estableciendo la relaci\u00f3n que va de Mensaje-&gt;Usuario. Core Data hace lo propio con la inversa, que va de Usuario-&gt;&gt;Mensaje, de modo que si accedemos al usuario e iteramos por los mensajes, veremos el nuevo mensaje que hemos a\u00f1adido.</p>"},{"location":"cap4/4.3_CRUD/#relaciones-a-muchos","title":"Relaciones \u201ca muchos\u201d","text":"<p>Como ya vimos al crear el modelo de datos, si usamos clases propias en el modelo, por cada relaci\u00f3n del tipo \"a muchos\" se genera una propiedad del tipo <code>NSSet</code> (<code>NSOrderedSet</code> si la relaci\u00f3n es ordenada). N\u00f3tese que son clases inmutables. Si queremos a\u00f1adir o eliminar elementos a la relaci\u00f3n tendremos que copiar la propiedad en un <code>NSMutableSet</code> o <code>NSMutableOrderedSet</code>, hacer la modificaci\u00f3n y luego asignar el nuevo conjunto a la propiedad.</p> <p>Afortunadamente hay una forma mucho m\u00e1s sencilla de a\u00f1adir/eliminar elementos, usar los m\u00e9todos <code>addToXXX</code> y <code>removeFromXXX</code> obtenidos al generar las clases del modelo.  Por ejemplo:</p> <pre><code>//c1 y u son objetos gestionados por Core Data\nvar c1 : Conversacion\nvar u : Usuario\n//Supongamos que aqu\u00ed los creamos en el contexto de persistencia\n...\n//c1 es un objeto gestionado por Core Data\nc1.comienzo = Date();\n//El usuario empieza a participar en una conversaci\u00f3n\n//Usamos el m\u00e9todo de acceso generado por Core Data\nu.addToConversaciones(c1);\n...\n</code></pre>"},{"location":"cap4/4.3_CRUD/#lectura","title":"Lectura","text":"<p>Para recuperar un objeto gestionado por Core Data normalmente se usan fetch requests, que en un entorno de BD se corresponder\u00eda con las consultas. En la siguiente sesi\u00f3n veremos con m\u00e1s detalle la sintaxis, pero por ejemplo obtener todas las instancias de una determinada entidad es sencillo, ya que no hay que especificar condici\u00f3n alguna, solo crear y ejecutar una fetch request del tipo deseado:</p> <pre><code>//Creamos la fetch request y decimos que devuelve usuarios\nlet request : NSFetchRequest&lt;Usuario&gt; = NSFetchRequest(entityName:\"Usuario\")\n//La ejecutamos (deber\u00edamos detectar errores con do...catch, es para acortar el ejemplo)\nlet usuarios = try! miContexto.fetch(request)\n//recorremos los resultados\nfor usuario in usuarios {\n    print(usuario.login!)\n}\n</code></pre> <p>En las clases generadas por Xcode tenemos un m\u00e9todo de utilidad llamado <code>fetchRequest</code> que simplifica el trabajo de la primera l\u00ednea del ejemplo anterior. As\u00ed, podemos hacer simplemente <code>let request = Usuario.fetchRequest()</code></p>"},{"location":"cap4/4.3_CRUD/#borrado","title":"Borrado","text":"<p>Podemos eliminar un objeto del contexto llamando a <code>delete</code> sobre el contexto y pas\u00e1ndole el objeto a eliminar</p> <pre><code>miContexto.delete(usuario)\n</code></pre> <p>Cuidado, <code>delete</code> no elimina el objeto del almac\u00e9n persistente. Para eso tendremos que ejecutar <code>save</code>, como cuando modificamos el objeto y queremos guardar los cambios.</p> <p>Eliminar el objeto del contexto implica que se ejecuten las reglas de borrado. As\u00ed, si por ejemplo hubi\u00e9ramos usado la regla <code>Cascade</code> para la relaci\u00f3n que va desde <code>Conversacion</code> a <code>Mensaje</code> esto implicar\u00eda que al borrar una conversaci\u00f3n del contexto tambi\u00e9n se eliminar\u00edan todos sus mensajes. </p> <p>No obstante, es posible que tras ejecutar <code>delete</code> las actualizaciones no se propaguen de manera inmediata por el grafo de objetos del contexto. Para forzar esta propagaci\u00f3n simplemente hay que llamar al m\u00e9todo <code>processPendingChanges()</code> del contexto.</p>"},{"location":"cap4/4.4_validaciones/","title":"Validaciones","text":"<p>Como ya hemos visto, cuando definimos el modelo de datos, para cada entidad podemos especificar una serie de reglas de validaci\u00f3n, que var\u00edan seg\u00fan el tipo de datos: por ejemplo para cadenas podemos indicar una longitud m\u00ednima y m\u00e1xima o una expresi\u00f3n regular, para fechas un rango de fechas v\u00e1lidas, para enteros tambi\u00e9n un rango, etc.</p> <p>Eso no quiere decir que no podamos tener un objeto gestionado por Core Data con valores inv\u00e1lidos, ya que de lo \u00fanico que se asegura el framework es que un objeto no v\u00e1lido no se puede guardar en el almacenamiento persistente. Es decir, los errores se disparan al hacer <code>save</code> del contexto.</p> <p>Por ejemplo supongamos que hemos especificado que un <code>Usuario</code> debe tener un \"nivel de usuario\" como m\u00ednimo de 0, y supongamos que intentamos guardar un usuario con \"nivel\" negativo. Al hacer <code>save()</code> se disparar\u00e1 el error. </p> <pre><code>let miDelegate = UIApplication.shared.delegate as! AppDelegate\nlet miContexto = miDelegate.persistentContainer.viewContext\nlet usuario = NSEntityDescription.insertNewObject(forEntityName: \"Usuario\", into: miContexto) as! Usuario\nusuario.nivel = -1\ndo {\n  try miContexto.save()\n} catch let miError as NSError {\n   if (miError.code == NSValidationNumberTooSmallError) {\n        print(\"El nivel de usuario no es v\u00e1lido\")\n   }\n}\n</code></pre> <p>El objeto <code>error</code> contiene bastante informaci\u00f3n sobre el error producido: un c\u00f3digo de error que en este caso ser\u00e1 el 1670 (indicando \"n\u00famero demasiado peque\u00f1o\") y adem\u00e1s un diccionario (propiedad <code>userInfo</code>) con m\u00faltiples datos sobre el error. En lugar de usar los c\u00f3digos num\u00e9ricos de error podemos usar una serie de constantes que comienzan por <code>NSValidation</code>, en este caso <code>NSValidationNumberTooSmallError</code> indica que es un valor demasiado peque\u00f1o.</p> <p>Podemos escribir nuestros propios validadores a\u00f1adi\u00e9ndole a la clase de la entidad un m\u00e9todo <code>validate&lt;nombre_del_atributo&gt;</code>, o sea si el atributo se llama <code>texto</code> el m\u00e9todo ser\u00eda <code>validateTexto</code>. Este m\u00e9todo debe lanzar una excepci\u00f3n si el objeto no es v\u00e1lido. Pod\u00e9is ver un ejemplo de este tipo de validaci\u00f3n en este tutorial.</p>"},{"location":"cap4/4.5_otros_tipos/","title":"Otros tipos de datos","text":"<p>Hasta el momento hemos visto que en una entidad de Core Data puede haber atributos de diversos tipos: enteros, reales, cadenas, fechas y alg\u00fan tipo m\u00e1s como URLs, pero es un n\u00famero de tipos limitado. </p> <p>\u00bfY si queremos almacenar un atributo de otro tipo, por ejemplo un array, una imagen o una instancia de cualquier otra clase no contemplada en los casos anteriores?. Si es una clase propia siempre podemos convertirla en otra entidad, pero puede haber casos en los que no tenga mucho sentido complicar el modelo de este modo. </p> <p>Podemos distinguir dos casos: el caso de datos binarios \"puros\" como audio, video o im\u00e1genes, y el de datos que aunque no son binarios son transformables a binarios (como ya vimos en la primera sesi\u00f3n del m\u00f3dulo, <code>Codables</code>).</p> <p>Para el primer caso podemos usar directamente el tipo \"binary data\", en el segundo caso tenemos el tipo transformable, en el que Core Data transformar\u00e1 a binario (<code>NSData</code>) el atributo para hacerlo persistente.</p>"},{"location":"cap4/4.5_otros_tipos/#datos-binarios","title":"Datos binarios","text":"<p>El tipo de datos \"binary data\" se suele usar para im\u00e1genes, audio, video, etc. Por ejemplo supongamos que tenemos la imagen de perfil del usuario y queremos guardarla en un campo \"imagen\" que  hemos definido como de  tipo <code>binary data</code>. Ser\u00eda tan sencillo como:</p> <pre><code>//obtenemos el contexto de persistencia\nlet miDelegate = UIApplication.shared.delegate as! AppDelegate\nlet miContexto = miDelegate.persistentContainer.viewContext\n/creamos el usuario y asignamos algunos campos\nlet usuario = Usuario(context:miContexto)\nusuario.login = \"pepe\"\n//la imagen la tendr\u00edamos que sacar de alg\u00fan lado. Seria un UIImage\nlet imagen_perfil = ...\n///as\u00ed podemos obtener los datos binarios de una UIImage en PNG \n//hay un m\u00e9todo jpgData() que hace lo mismo con JPG\nlet datos = imagen_perfil.pngData()\n//ya lo podemos guardar\nusuario.imagen = datos\n</code></pre> <p>Para recuperar una <code>UIImage</code> a partir de los datos binarios guardados en Core Data bastar\u00eda con llamar al inicializador <code>UIImage(data:)</code> que crea una imagen a partir de datos binarios.</p>"},{"location":"cap4/4.5_otros_tipos/#datos-transformables","title":"Datos transformables","text":"<p>Con los atributos transformables tenemos dos casos posibles: el \"f\u00e1cil\", en el que no tenemos que escribir c\u00f3digo ya que Core Data puede realizar la transformaci\u00f3n autom\u00e1ticamente, y el m\u00e1s complejo, en el que tendremos que implementar nosotros mismos la transformaci\u00f3n. Todo depende de si el dato a almacenar implementa el protocolo <code>NSCoding</code>. Esta es la \"versi\u00f3n antigua\" del <code>Codable</code> de Swift. Las clases que implementan este protocolo son archivables o serializables. As\u00ed que Core Data no hace directamente la transformaci\u00f3n sino que recurre a un mecanismo est\u00e1ndar en iOS para archivar/desarchivar objetos.</p> <p>Por ejemplo supongamos que en una entidad de Core Data quisi\u00e9ramos almacenar un array de String. No podemos crear un atributo de Core Data de este tipo directamente, pero afortunadamente los arrays implementan el protocolo <code>NSCoding</code>, as\u00ed que la transformaci\u00f3n va a ser autom\u00e1tica. Seguir\u00edamos estos pasos</p> <ul> <li>En la entidad, definir el tipo del atributo como <code>Transformable</code>.</li> <li>Generar la clase de la entidad con Xcode de manera manual (con <code>Editor&gt;Create NSManagedObject subclass...</code>)</li> <li>Modificar el archivo fuente generado por Xcode, que habr\u00e1 puesto la propiedad como <code>NSObject</code> y cambiarla por el tipo correspondiente. En este caso <code>[String]</code>. De este modo nos ahorraremos el cast hacia y desde <code>NSObject</code>. La contrapartida es que si volvemos a generar la clase nos tocar\u00e1 volver a editar el archivo.</li> </ul> <p>Ya no hay que hacer nada m\u00e1s. Nosotros trataremos con la propiedad como un array de <code>String</code> y autom\u00e1ticamente se har\u00e1 la transformaci\u00f3n hacia y desde binario, que es como se almacenan los datos.</p> <p>En caso de que el tipo de datos del atributo no sea conforme al protocolo <code>NSCoding</code> tendremos que escribir una clase propia que haga la transformaci\u00f3n a y desde binario. Esto se hace implementando una clase que herede de <code>ValueTransformer</code>, e implementando en ella la l\u00f3gica de transformaci\u00f3n. Para ver un ejemplo concreto pod\u00e9is consultar por ejemplo este tutorial.</p>"},{"location":"cap4/4.6_ejercicios/","title":"Ejercicios de modelos de datos","text":"<p>En esta sesi\u00f3n vamos a continuar trabajando sobre la aplicaci\u00f3n de notas de la primera sesi\u00f3n de Core Data. Necesitar\u00e1s que la sesi\u00f3n anterior est\u00e9 terminada para poder continuar con esta.</p> <p>Vamos a ampliar el modelo de datos a\u00f1adiendo una nueva entidad, \"Libreta\", que tendr\u00e1 una relaci\u00f3n de uno a muchos con \"Nota\". Cada libreta contendr\u00e1 muchas notas, pero cada nota solo puede estar en una libreta.</p>"},{"location":"cap4/4.6_ejercicios/#anadir-la-entidad-libreta-025-puntos","title":"A\u00f1adir la entidad <code>Libreta</code> (0,25 puntos)","text":"<ul> <li>A\u00f1adir la entidad Libreta, con un atributo llamado <code>nombre</code> de tipo String</li> <li>Crear una relaci\u00f3n \"a muchos\" de <code>Libreta</code> a <code>Nota</code> y \"a uno\" de <code>Nota</code> a <code>Libreta</code> (la inversa)</li> </ul> <p>Recuerda que seg\u00fan las convenciones de Core Data, la relaci\u00f3n de Libreta a Nota se deber\u00eda llamar \"notas\" y la de nota a libreta, \"libreta\". As\u00ed, por ejemplo luego podr\u00edamos acceder a las notas de una libreta <code>miLibreta</code> con <code>miLibreta.notas</code>, lo que resulta intuitivo en el c\u00f3digo.</p>"},{"location":"cap4/4.6_ejercicios/#crear-libretas-025-puntos","title":"Crear libretas (0,25 puntos)","text":"<p>Para simplificar ser\u00e1 un bot\u00f3n \"nueva libreta\" en la pantalla inicial, que al pulsarlo debe mostrar un alert con un campo de texto para escribir el nombre. Tendr\u00e1s que definirte el action correspondiente para detectar que se ha pulsado el bot\u00f3n. En el action puedes llamar al siguiente c\u00f3digo para mostrar el alert:</p> <pre><code>func nuevaLibreta() {\n    let alert = UIAlertController(title: \"Nueva libreta\",\n                                  message: \"Escribe el nombre para la nueva libreta\",\n                                  preferredStyle: .alert)\n    let crear = UIAlertAction(title: \"Crear\", style: .default) {\n        action in\n        let nombre = alert.textFields![0].text!\n        //AQUI FALTA GUARDAR LA LIBRETA CON CORE DATA\n    }\n    let cancelar = UIAlertAction(title: \"Cancelar\", style: .cancel) {\n        action in\n    }\n    alert.addAction(crear)\n    alert.addAction(cancelar)\n    alert.addTextField() { $0.placeholder = \"Nombre\"}\n    self.present(alert, animated: true)\n}\n</code></pre> <ul> <li>En el c\u00f3digo anterior falta guardar la libreta usando Core Data, implementa esta funcionalidad</li> </ul>"},{"location":"cap4/4.6_ejercicios/#listar-libretas-025-puntos","title":"Listar libretas (0,25 puntos)","text":"<p>Antes de empezar con esto aseg\u00farate de que las libretas se est\u00e1n creando correctamente en la base de datos. En el <code>viewWillAppear</code> de la pantalla de lista de notas puedes poner provisionalmente una consulta que las imprima en la consola (luego acu\u00e9rdate de quitarlo)</p> <pre><code>override func viewWillAppear(_ animated: Bool) {\n    let queryLibretas = NSFetchRequest&lt;Libreta&gt;(entityName:\"Libreta\")\n    guard let miDelegate = UIApplication.shared.delegate as? AppDelegate else {\n        return\n    }\n    let miContexto = miDelegate.persistentContainer.viewContext\n    let libretas = try! miContexto.fetch(queryLibretas)\n    for libreta in libretas {\n        print(libreta.nombre)\n    }\n}\n</code></pre> <p>Para que el usuario pueda seleccionar la libreta en la pantalla de creaci\u00f3n de notas vamos a usar un picker view, la t\u00edpica \"rueda\" para seleccionar valores de una lista.</p> <ul> <li>A\u00f1ade un componente picker view a la pantalla de creaci\u00f3n de notas. Crea un outlet para poder acceder a \u00e9l desde Swift. Dale el nombre que quieras.</li> <li>Desde el punto de vista del c\u00f3digo, un picker view requiere de un delegate y de un datasource (m\u00e1s o menos como las tablas). Crea una nueva clase <code>GestorPicker</code> en un archivo del mismo nombre, as\u00ed no llenamos de tanto c\u00f3digo el <code>ViewController</code></li> </ul> <pre><code>import Foundation\nimport UIKit\nimport CoreData\n\n\nclass GestorPicker : NSObject, UIPickerViewDelegate, UIPickerViewDataSource {\n    var libretas = [Libreta]()\n\n    //devuelve el n\u00famero de columnas del picker. En nuestro caso solo 1\n    func numberOfComponents(in pickerView: UIPickerView) -&gt; Int {\n        return 1\n    }\n\n    //devuelve el n\u00famero de filas del picker (== n\u00famero de libretas)\n    func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -&gt; Int {\n        return self.libretas.count\n    }\n\n    //devuelve el t\u00edtulo de una fila determinada\n    func pickerView(_ pickerView: UIPickerView, titleForRow row: Int, forComponent component: Int) -&gt; String? {\n        return self.libretas[row].nombre\n    }\n\n    //para cargar la lista de libretas desde Core Data\n    func cargarLista() {\n        let miDelegate = UIApplication.shared.delegate as! AppDelegate\n        let miContexto = miDelegate.persistentContainer.viewContext\n        let request = NSFetchRequest&lt;Libreta&gt;(entityName:\"Libreta\")\n        self.libretas = try! miContexto.fetch(request)\n    }\n}\n</code></pre> <p>Ahora en el <code>ViewController</code> a\u00f1ade una nueva propiedad , una instancia de la clase anterior</p> <pre><code>//Esto es una propiedad del ViewController, va dentro de la clase y FUERA de los m\u00e9todos\nlet miGestorPicker = GestorPicker()\n</code></pre> <p>y en el <code>viewDidLoad</code> del <code>ViewController</code> conectamos el picker con su delegate/datasource y cargamos la lista de libretas con Core Data</p> <pre><code>//Aqu\u00ed, \"picker\" es el outlet que representa al \"picker view\"\n//CAMBIALO por el nombre que le hayas dado\nself.picker.delegate = self.miGestorPicker\nself.picker.dataSource = self.miGestorPicker\n//cargamos las libretas con Core Data\nself.miGestorPicker.cargarLista()\n</code></pre> <p>Tal como est\u00e1 ahora la aplicaci\u00f3n la lista de libretas debe aparecer cuando se arranca, pero si se a\u00f1ade una nueva libreta no aparecer\u00e1 en el picker hasta que se pare la app y se vuelva a arrancar (que es cuando se llama a <code>cargarLista()</code>). Puedes arreglarlo haciendo dos cosas justo despu\u00e9s de guardar la nueva libreta con core data (en la funci\u00f3n <code>nuevaLibreta</code> de antes):</p> <ul> <li>A\u00f1adir la nueva libreta a la lista que tiene dentro el <code>miGestorPicker</code>: </li> </ul> <pre><code>self.miGestorPicker.libretas.append(libreta)\n</code></pre> <ul> <li>Decirle al componente picker view que se repinte recargando los datos</li> </ul> <pre><code>//de nuevo, \"picker\" es el outlet del \"picker view\". C\u00c1MBIALO POR EL TUYO\nself.picker.reloadAllComponents()\n</code></pre>"},{"location":"cap4/4.6_ejercicios/#asociar-una-libreta-a-la-nota-actual-025-puntos","title":"Asociar una libreta a la nota actual (0,25 puntos)","text":"<p>Falta que cuando se guarde la nota, se le asocie la libreta que aparece seleccionada en el picker view. Igual que asignas el \"texto\" y la \"fecha\" de la nota, as\u00edgnale tambi\u00e9n el objeto libreta usando la relaci\u00f3n \"a uno\" entre <code>Nota</code> y <code>Libreta</code>. Para saber qu\u00e9 n\u00famero de opci\u00f3n est\u00e1 seleccionado actualmente en un picker puedes usar su m\u00e9todo <code>selectedRow</code>:</p> <pre><code>//de nuevo, \"picker\" es el outlet del \"picker view\". C\u00c1MBIALO POR EL TUYO\nlet numLibreta = self.picker.selectedRow(inComponent: 0)\n</code></pre> <p>El objeto <code>Libreta</code> en esa posici\u00f3n ser\u00e1 la misma posici\u00f3n del array <code>libretas</code> del <code>self.miGestorPicker</code>.</p>"},{"location":"cap4/4.6_ejercicios/#mostrar-la-libreta-al-listar-las-notas","title":"Mostrar la libreta al listar las notas","text":"<p>Puedes mostrar el nombre de la libreta en la parte del texto de detalle de la celda (es la propiedad <code>detailTextLabel</code> de la celda). Primero tendr\u00e1s que cambiar el tipo de celda de <code>Basic</code> a <code>Left detail</code> o <code>Right detail</code>, seg\u00fan donde quieras que aparezca el nombre.</p>"},{"location":"cap4/intro/","title":"Introducci\u00f3n","text":"<p>En este tema veremos la parte central de Core Data: el modelo de datos. El modelo de datos es el grafo de objetos (entidades) que implementan nuestra l\u00f3gica de negocio y que queremos que sean persistentes. Ya hemos visto c\u00f3mo definir estas entidades a nivel b\u00e1sico. </p> <p>Veremos c\u00f3mo personalizar las clases de las entidades, lo que simplificar\u00e1 nuestro c\u00f3digo y adem\u00e1s nos permitir\u00e1 a\u00f1adir m\u00e9todos propios a los objetos persistentes. Veremos tambi\u00e9n c\u00f3mo relacionar las entidades entre s\u00ed, ya que como hemos dicho formar\u00e1n un grafo de objetos.</p> <p>Una vez definido el modelo veremos que con Core Data podemos hacer operaciones de tipo CRUD (Create/Read/Update/Delete) de modo sencillo, con una entidad y con las entidades relacionadas. Finalmente veremos un par de funcionalidades que implementa Core Data y que van a ser muy \u00fatiles en nuestras aplicaciones: la validaci\u00f3n de datos y la posibilidad de deshacer/rehacer operaciones.</p>"},{"location":"cap5/3_ciclo_de_vida/","title":"3 ciclo de vida","text":""},{"location":"cap5/3_ciclo_de_vida/#notificaciones-del-ciclo-de-vida","title":"Notificaciones del ciclo de vida","text":"<p>Los objetos gestionados van pasando por distintos cambios. Primero son creados u obtenidos de la base de datos con un fetch, luego se modifican sus valores y en alg\u00fan momento se guardan. En muchos casos nos interesar\u00e1 enterarnos de cu\u00e1ndo se realizan estas operaciones. Por ejemplo saber cu\u00e1ndo se crea un objeto puede ser \u00fatil para inicializar valores por defecto, o saber cu\u00e1ndo se modifica un atributo para actualizar la interfaz de usuario.</p> <p>Cuando se crea un nuevo objeto gestionado, Core Data llama a su m\u00e9todo <code>awakeFromInsert</code>. El uso t\u00edpico de este m\u00e9todo, como ya hemos comentado, es el de fijar valores por defecto que no se pueden fijar a trav\u00e9s de la interfaz gr\u00e1fica de Xcode, ya que esta solo permite especificar valores constantes. Por ejemplo, vamos a ver c\u00f3mo har\u00edamos para asignar la fecha actual a un <code>Mensaje</code> al crearlo.</p> <p>Para no tocar las clases de entidades generadas por Xcode, y que podr\u00eda ser necesario borrar y volver a crear, lo hacemos en una extensi\u00f3n propia a la clase <code>Mensaje</code>. El nombre del archivo es arbitrario.</p> <pre><code>//Archivo Mensaje+Custom.swift\nimport Foundation\nimport CoreData\n\nextension Mensaje {\n    override public func awakeFromInsert() {\n        self.fecha = Date() as NSDate\n    }\n}\n</code></pre> <p>El cast con <code>as NSDate</code> lo usamos porque al generar las clases para las entidades con Xcode es el tipo que usa por defecto para fechas. Podr\u00edamos modificar manualmente el archivo <code>Mensaje+CoreDataProperties.swift</code> y cambiar el <code>NSDate</code> por un <code>Date</code> para ahorrarnos el cast, pero tendr\u00edamos que hacer el cambio cada vez que gener\u00e1ramos la clase.</p> <p>Aunque suele ser menos \u00fatil que el anterior, tambi\u00e9n podemos enterarnos de cu\u00e1ndo se ha instanciado un objeto a trav\u00e9s de un fetch sobreescribiendo el m\u00e9todo <code>awakeFromFetch()</code>.</p> <p>Core Data propiamente dicho no incorpora ning\u00fan mecanismo para saber cu\u00e1ndo se ha modificado un atributo de un objeto gestionado, pero no lo necesita, porque iOS ya tiene un mecanismo gen\u00e9rico: el KVO o Key Value Observing. Con este mecanismo podemos detectar cambios en las propiedades de cualquier objeto que herede de <code>NSObject</code>. Adem\u00e1s las propiedades a observar deben estar marcadas como <code>dynamic</code> (explicaci\u00f3n en la documentaci\u00f3n de Apple. Estos son requerimientos que limita su utilidad para trabajar con objetos gen\u00e9ricos Swift. Como <code>NSManagedObject</code> ya hereda de \u00e9ste y sus propiedades son <code>dynamic</code>, no tenemos que hacer ning\u00fan esfuerzo adicional para usar KVO con objetos gestionados.</p> <p>KVO es una implementaci\u00f3n del patr\u00f3n de dise\u00f1o Observer. Para usar KVO necesitamos un objeto que pueda ser observado (el objeto gestionado) y otro que act\u00fae como observador. El observador est\u00e1 \"suscrito\" a cambios en una propiedad del objeto observado.</p> <pre><code>//decimos que queremos observar al objeto gestionado\nusuario.addObserver(self, forKeyPath:\"password\", options: .new, context:nil)\n</code></pre> <p>Los par\u00e1metros indican lo siguiente:</p> <ul> <li>El primero es el objeto que va a actuar de observador. En el ejemplo anterior, <code>self</code>, o sea el objeto donde reside este c\u00f3digo que se estaba ejecutando. Aunque puede ser cualquiera</li> <li>El segundo indica la propiedad que queremos observar</li> <li>El tercero es un conjunto de flags que se pueden combinar con <code>|</code> y que indican qu\u00e9 valores quiere recibir el observador. En el ejemplo estamos diciendo que solo queremos conocer el nuevo <code>password</code>, pero ya no sabremos cu\u00e1l era el antiguo. Si por ejemplo quisi\u00e9ramos ambos podr\u00edamos pasar <code>.old | .new</code></li> <li>El \u00faltimo par\u00e1metro se usa raras veces. Se recomienda consultar la documentaci\u00f3n de Apple.</li> </ul> <p>El objeto observador debe tambi\u00e9n heredar de <code>NSObject</code>. Los eventos observables los recibir\u00e1 como llamadas al m\u00e9todo <code>observeValue(forKeyPath:of:change:context:)</code>.</p> <ul> <li>El primer par\u00e1metro es la propiedad que ha cambiado</li> <li>El segundo el objeto para el que ha cambiado la propiedad. Estos datos son necesarios porque un mismo observador podr\u00eda estar observando varios objetos, y varias propiedades de cada uno</li> <li>El tercero es el m\u00e1s complejo, y es un diccionario con los valores del cambio. Las claves son constantes que indican el tipo de valor. Por ejemplo, <code>NSKeyValueChangeKey.newKey</code> indica el nuevo valor de la propiedad, y <code>NSKeyValueChangeKey.oldKey</code> indica el antiguo. Los valores que tengamos o no en el diccionario depender\u00e1n de lo que hab\u00edamos especificado en el par\u00e1metro <code>options</code> al suscribirnos.</li> </ul> <p>Por ejemplo:</p> <pre><code>override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {\n    if keyPath == \"password\" {\n        let nuevoPassword = change?[.newKey]\n        print(\"El nuevo password es \\(nuevoPassword)\")\n    }\n}\n</code></pre> <p>Otra posibilidad para observar el ciclo de vida de los objetos gestionados es usar notificaciones. Por ejemplo, cada vez que un objeto se inserta, actualiza o borra en un contexto de persistencia, emite una notificaci\u00f3n de tipo <code>NSManagedObjectContextObjectsDidChangeNotification</code>. M\u00e1s sobre esto en este tutorial.</p>"},{"location":"cap5/4_undo/","title":"4 undo","text":""},{"location":"cap5/4_undo/#deshacer-y-rehacer","title":"Deshacer y rehacer","text":"<p>Core Data nos ofrece la posibilidad de deshacer y rehacer las operaciones con objetos gestionados. As\u00ed por ejemplo aunque hayamos borrado un objeto con <code>delete</code>, por ejemplo, podemos deshacer de modo muy sencillo el borrado. De esto se encarga el undo manager, un objeto de la clase <code>UndoManager</code>. En principio es algo tan simple como llamar a los m\u00e9todos <code>undo</code> y <code>redo</code> de este objeto. El undo manager es accesible a trav\u00e9s de la propiedad <code>undoManager</code> del contexto</p> <pre><code>//suponiendo que hayamos obtenido el contexto\nlet miContexto = ...\n//deshacemos la \u00faltima operaci\u00f3n realizada\nmiContexto.undoManager?.undo()\n</code></pre> <p>De hecho, podr\u00edamos simplificar todav\u00eda m\u00e1s el c\u00f3digo llamando a <code>miContexto.undo()</code>, que lo que hace en realidad es llamar al undo manager</p> <p>En iOS el undo manager no est\u00e1 activado por defecto, de modo que inicialmente es <code>nil</code>. De ah\u00ed que al acceder a la propiedad <code>undoManager</code> obtengamos un opcional. Justo desp\u00faes de crear el contexto podemos instanciar un <code>UndoManager</code> y pas\u00e1rselo a \u00e9ste. Si estamos usando el c\u00f3digo que genera Xcode 8 para iOS10 al marcar la casilla \"use core data\", el lugar apropiado es tras crear el persistent container, justo antes del <code>return</code>:</p> <pre><code>container.viewContext.undoManager = UndoManager()\nreturn container\n</code></pre> <p>Si generamos c\u00f3digo para iOS&lt;10, el lugar apropiado es donde se crea el contexto de persistencia.</p> <p>Una vez activado el undo manager, cuando llamamos a <code>undo</code> por defecto se deshacen las operaciones efectuadas en la \u00faltima ejecuci\u00f3n de c\u00f3digo por parte de la aplicaci\u00f3n (es decir, desde que el sistema \u201ccede el control\u201d a la aplicaci\u00f3n - por ejemplo en un manejador de evento - hasta que la aplicaci\u00f3n vuelve a \u201cpasarle el testigo\u201d al sistema). As\u00ed por ejemplo si al pulsar un bot\u00f3n del interfaz se ejecuta c\u00f3digo que borra una lista de objetos, al  deshacer se podr\u00eda recuperar la lista entera, pero no cada objeto individual. No obstante, podemos llamar a <code>beginUndoGrouping</code> y <code>endUndoGrouping</code> para gestionar nosotros mismos la \u201catomicidad\u201d del <code>undo</code>.</p> <p>Por defecto con el undo manager podemos deshacer un n\u00famero ilimitado de operaciones, lo que puede ser problem\u00e1tico con la memoria, ya que hay que \u201cllevar la pista\u201d de todos los cambios que se van haciendo. Para fijar el n\u00famero m\u00e1ximo de operaciones que se puedan deshacer se puede cambiar el valor de la propiedad <code>levelsOfUndo:</code>.</p>"},{"location":"cap5/intro/","title":"Intro","text":""},{"location":"cap5/intro/#introduccion","title":"Introducci\u00f3n","text":"<p>En este tema seguiremos viendo algunas posibilidades adicionales que nos ofrece el modelo de datos. En primer lugar veremos c\u00f3mo solucionar el problema que se da cuando queremos almacenar datos que no se corresponden con ninguno de los tipos por defecto. Luego veremos c\u00f3mo se validan los datos en Core Data, cu\u00e1l es el ciclo de vida de los objetos gestionados, y finalmente c\u00f3mo deshacer operaciones, caracter\u00edstica muy necesaria para permitir al usuario corregir sus errores si por ejemplo ha borrado alg\u00fan dato sin querer.</p>"},{"location":"cap6/1_predicados/","title":"Predicados","text":"<p>Hasta ahora hemos visto solo como crear fetch request que devuelvan todas las instancias de una entidad, lo que ser\u00eda el equivalente a un <code>SELECT</code> sin <code>WHERE</code> en SQL. Por supuesto podemos filtrar los resultados de una fetch request, y esto lo haremos con predicados, que en el API se representan con la clase <code>NSPredicate</code>. Los predicados son un mecanismo gen\u00e9rico de Cocoa para filtrar colecciones de datos y pueden usarse no solo en Core Data, sino tambi\u00e9n para filtrar arrays o para buscar en spotlight, el mecanismo de b\u00fasqueda est\u00e1ndar de aplicaciones/contactos/documentos dentro de los dispositivos iOS.</p> <p>Veamos un ejemplo de fetch request con predicado:</p> <pre><code>let miDelegate = UIApplication.shared.delegate as! AppDelegate \nlet miContexto = miDelegate.persistentContainer.viewContext\nlet request = NSFetchRequest&lt;Mensaje&gt;(entityName: \"Mensaje\")\nlet pred = NSPredicate(format: \"texto CONTAINS 'iOS'\")\nrequest.predicate = pred\nlet resultados = try! miContexto.fetch(request)\nprint(\"Hay \\(resultados.count) resultados\")\nfor mensaje in resultados {\n    print(mensaje.texto!)\n}\n</code></pre> <p>Como vemos, la \u00fanica diferencia es que instanciamos un <code>NSPredicate</code> con la condici\u00f3n a cumplir y lo asociamos a la propiedad <code>predicate</code> del fetch request.</p> <p>Podemos crear <code>NSPredicate</code> de tres formas distintas:</p> <ul> <li>Defini\u00e9ndolo como una cadena, que se parsear\u00e1 y ejecutar\u00e1 como hemos hecho en el ejemplo anterior. En el ejemplo la consulta era \"fija\" pero tambi\u00e9n podemos pasar argumentos.</li> <li>Con un template, que b\u00e1sicamente es un predicado en forma de cadena en el que se incluyen variables, algo as\u00ed como los par\u00e1metros de las queries en SQL. En Core Data podemos crear este tipo de predicados directamente desde el editor del modelo de datos, son las fetch request templates que ya comentamos.</li> <li>Directamente en c\u00f3digo. Tenemos una serie de clases que representan diversas partes del predicado. Por ejemplo un <code>NSComparisonPredicate</code> nos permite representar un operador de comparaci\u00f3n, un <code>NSExpression</code> una expresi\u00f3n (por ejemplo, como expresiones sencillas tendr\u00edamos una variable, un valor constante,\u2026). Con un operador de comparaci\u00f3n que una dos expresiones podemos conseguir algo como lo que hemos hecho en el ejemplo de la localidad. Esta forma de trabajar es engorrosa pero tiene su utilidad en algunos casos, por ejemplo cuando queremos generar din\u00e1micamente una consulta partiendo de cero.</li> </ul>"},{"location":"cap6/1_predicados/#predicados-como-cadenas","title":"Predicados como cadenas","text":"<p>Esta es la forma m\u00e1s habitual de definir predicados. El problema es que la cadena se interpreta en tiempo de ejecuci\u00f3n, as\u00ed que los errores de sintaxis no los vamos a detectar hasta entonces. Es algo muy similar a cuando ejecutamos sentencias SQL en nuestro c\u00f3digo.</p>"},{"location":"cap6/1_predicados/#operadores","title":"Operadores","text":"<p>Los predicados aceptan diversos tipos de operadores y funciones:</p> <ul> <li>Los t\u00edpicos operadores de comparaci\u00f3n: <code>=</code> (o <code>==</code>) <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>!=</code> \u2026</li> <li>Operadores l\u00f3gicos: <code>AND</code>, <code>OR</code>, <code>NOT</code> (o tambi\u00e9n al estilo C, <code>&amp;&amp;</code>, <code>||</code>, <code>!</code>).<ul> <li>Operadores de comparaci\u00f3n de cadenas: <code>BEGINSWITH</code>, <code>ENDSWITH</code>, <code>CONTAINS</code>, <code>LIKE</code> (como <code>CONTAINS</code> pero admite comodines <code>?</code> o <code>*</code>), <code>MATCHES</code> (comprueba si la cadena encaja con una expresi\u00f3n regular en formato ICU). Estos operadores por defecto distinguen entre may\u00fasculas/min\u00fasculas y s\u00edmbolos diacr\u00edticos (acentos, circunflejos, etc). Si despu\u00e9s del operador ponemos un s\u00edmbolo <code>c</code> entre corchetes indicamos que no queremos distinguir may\u00fasculas/min\u00fasculas, y <code>d</code> hace lo propio con los diacr\u00edticos. Por ejemplo</li> </ul> </li> </ul> <pre><code>localidad CONTAINS[c] 'san'\n</code></pre> <p>Encajar\u00eda con \u201cSan vicente\u201d, \u201cFuensanta\u201d, \u201cMassanassa\u201d,\u2026</p> <p>Pod\u00e9is consultar una referencia m\u00e1s completa en el apartado \u201cPredicate Format String Syntax\u201d de la  \u201cPredicate Programming Guide\u201d de Apple. </p>"},{"location":"cap6/1_predicados/#caracteres-de-formato","title":"Caracteres de formato","text":"<p>En la cadena de la fetch request podemos emplear caracteres de formato al estilo de los que se usan en el <code>printf</code> de C, lo que nos permite pasarle par\u00e1metros. Por ejemplo:</p> <pre><code>NSPredicate(format: \"texto CONTAINS %@ AND fecha&lt;%@\", argumentArray: [\"iOS\", Date()])\n</code></pre> <p>Los caracteres de formato son placeholders donde se van colocando los argumentos que se pasan en forma de array. Los caracteres <code>%@</code> en concreto representan un objeto (en este caso un <code>String</code>). Al igual que en el <code>printf</code> de C podemos usar <code>%i</code> para enteros, <code>%f</code> para n\u00fameros reales, etc.</p> <p>N\u00f3tese que, como hab\u00edamos visto en la secci\u00f3n anterior, las cadenas buscadas hay que ponerlas entre comillas (sean simples o dobles). El formateo tiene esto en cuenta y cuando un par\u00e1metro es de tipo <code>String</code> las inserta autom\u00e1ticamente. Esto, que es adecuado para los valores de las propiedades, no lo ser\u00eda si queremos especificar din\u00e1micamente la propiedad. Por ejemplo, el siguiente c\u00f3digo</p> <pre><code>let atributo = \"login\";\nlet subcadena = \"pep\";\nlet pred = NSPredicate(format:\"%@ CONTAINS[c] %@\", argumentArray:[atributo, subcadena]);\n</code></pre> <p>generar\u00eda el predicado</p> <pre><code>'login' CONTAINS[c] 'usu'\n</code></pre> <p>que no es correcto porque los atributos no se ponen entre comillas. Para especificar que estamos poniendo un nombre de propiedad podemos usar el car\u00e1cter de formato <code>%K</code>, y as\u00ed el formateador no pondr\u00e1 las comillas alrededor. La versi\u00f3n correcta del ejemplo anterior ser\u00eda</p> <pre><code>let pred = NSPredicate(format:\"%K CONTAINS[c] %@\", argumentArray:[atributo, subcadena]);\n</code></pre>"},{"location":"cap6/1_predicados/#templates","title":"Templates","text":"<p>Como comentamos en sesiones anteriores, en el editor del modelo de datos de Xcode se pueden crear \u201cfetch request templates\u201d o dicho de otro modo, consultas \u201cpredefinidas\u201d. Estas templates tambi\u00e9n se pueden crear por c\u00f3digo, y la diferencia fundamental con las cadenas de formato es que en lugar de usar caracteres gen\u00e9ricos de formato emplean variables, lo que oficialmente se denominan variable expressions (un poco como la diferencia entre los par\u00e1metros por posici\u00f3n y con nombre en SQL).</p> <p>En el editor del modelo podemos crear un fetch request template pulsando unos segundos (sin soltar) sobre el bot\u00f3n de <code>Add entity</code> para que aparezca el men\u00fa contextual, y elegir <code>Add fetch request</code>. El editor permite construir predicados m\u00e1s o menos de forma visual, o tecleando la expresi\u00f3n, que como hemos dicho puede contener variables. Las variables deben ir precedidas del s\u00edmbolo <code>$</code> (<code>$cadena</code>, <code>$NOMBRE</code>,\u2026)</p> <p></p> <p>El editor visual de templates introduce comillas de m\u00e1s en los nombres de las variables, quedando expresiones como <code>nombre BEGINS WITH \"$cadena\"</code>. En este caso la variable no se reconocer\u00eda como tal al estar entre comillas. Si vamos a usar variables es mejor usar el editor en modo texto. Podemos pasar a este modo pulsando el segundo de los botones que aparecen en la parte superior derecha del editor. </p> <p>Para ejecutar la template en nuestro c\u00f3digo tenemos que recuperarla por nombre a partir del modelo de datos (el <code>NSManagedObjectModel</code>). Este modelo es accesible en la propiedad <code>managedObjectModel</code> del <code>PersistentContainer</code>. Adem\u00e1s necesitaremos un diccionario que especifique nombre y valor para cada variable. Para el ejemplo de la figura anterior:</p> <pre><code>let miDelegate = UIApplication.shared.delegate as! AppDelegate\nlet miModelo = miDelegate.persistentContainer.managedObjectModel \nlet dictVars = [\"cadena\":\"iOS\"]\nif let queryTmpl = miModelo.fetchRequestFromTemplate(withName: \"textoContiene\", substitutionVariables: dictVars) {\n    let results = try! miContexto.fetch(queryTmpl) as! [Mensaje]\n    print(\"Hay \\(results.count) resultados en la template\")\n    for mensaje in results {\n        print(mensaje.texto!)\n    }\n}\n</code></pre>"},{"location":"cap6/1_predicados/#predicados-sobre-relaciones","title":"Predicados sobre relaciones","text":"<p>En los predicados podemos incluir no solo los atributos \u201csimples\u201d, sino tambi\u00e9n los que representan relaciones entre objetos. As\u00ed, buscar en una relaci\u00f3n \u201ca uno\u201d es pr\u00e1cticamente igual que buscar en una propiedad convencional. Por ejemplo, vamos a buscar todos los mensajes enviados por un usuario cuyo login comience por <code>m</code> (relaci\u00f3n <code>Mensaje</code>-&gt; <code>Usuario</code>). Para ello usar\u00edamos un predicado como el que sigue:</p> <pre><code>let pred = NSPredicate(format:\"usuario.login BEGINSWITH[c] 'm'\")\n</code></pre> <p>Buscar en una relaci\u00f3n \u201ca muchos\u201d es ligeramente m\u00e1s complicado, ya que estamos buscando en una colecci\u00f3n. Podemos usar el operador <code>ANY</code> para verificar que alg\u00fan valor de la colecci\u00f3n cumple la condici\u00f3n. Por ejemplo podemos buscar todos los usuarios que han participado en alguna conversaci\u00f3n en la \u00faltima hora:</p> <pre><code>let haceUnaHora  = Date(timeIntervalSinceNow: -60*60)\nlet predicado = NSPredicate(format: \"ANY conversaciones.comienzo&gt;%@\", argumentArray: [haceUnaHora])\n</code></pre>"},{"location":"cap6/2_ordenacion/","title":"Ordenaci\u00f3n","text":"<p>Hasta el momento hemos obtenido los resultados en el orden en que nos los da Core Data, que salvo para las relaciones ordenadas no asegura ning\u00fan orden espec\u00edfico. Podemos especificar diversos criterios de ordenaci\u00f3n usando la clase <code>NSSortDescriptor</code>. Al igual que <code>NSPredicate</code>, esta clase no es propia de Core Data sino de oundation, as\u00ed que se puede usar tambi\u00e9n para ordenar colecciones en memoria.</p> <pre><code>let credSort = NSSortDescriptor(key:\"creditos\", ascending:false)\nlet loginSort = NSSortDescriptor(key:\"login\" ascending:true)\nmiFetchRequest.sortDescriptors = [credSort, loginSort]\n</code></pre> <p>Como se ve, cada <code>NSSortDescriptor</code> referencia la propiedad por la que ordenar y si debe o no ser un orden ascendente. Para usar el sort descriptor, asignamos un array de ellos a la propiedad <code>sortDescriptors</code> de la fetch request.  El orden en el array especificar\u00e1 la prioridad en la ordenaci\u00f3n. En este caso se ordenar\u00e1 por orden descendente de cr\u00e9ditos y para los que tengan los mismos cr\u00e9ditos por orden ascendente de login. </p>"},{"location":"cap6/3_ejercicios/","title":"Ejercicios","text":"<p>Vamos a implementar una b\u00fasqueda por texto en la aplicaci\u00f3n de notas sobre la que est\u00e1is trabajando en estas sesiones.</p> <p>Antes de ponerte a hacer las modificaciones de esta sesi\u00f3n aseg\u00farate de que has hecho un <code>commit</code> con el mensaje <code>terminada sesi\u00f3n 2</code>. Tambi\u00e9n puedes hacer un <code>.zip</code> con el proyecto, llamarlo <code>notas_sesion_2.zip</code> y adjuntarlo en las entregas de la asignatura. As\u00ed cuando se eval\u00fae el ejercicio el profesor podr\u00e1 consultar el estado que ten\u00eda la aplicaci\u00f3n antes de estos ejercicios.</p>"},{"location":"cap6/3_ejercicios/#preparacion-de-la-interfaz-025-puntos","title":"Preparaci\u00f3n de la interfaz (0.25 puntos)","text":"<p>Necesitamos una barra de b\u00fasqueda para poder introducir la cadena de texto a buscar. Usaremos un <code>UISearchController</code>. Este componente incluye la search bar. </p> <p>En <code>ListaNotasController</code>:</p> <ol> <li>Define una propiedad que ser\u00e1 el <code>UISearchController</code></li> </ol> <pre><code>//esto debe ser una variable miembro de ListaNotasController\nlet searchController = UISearchController(searchResultsController: nil)\n</code></pre> <ol> <li>En el <code>viewDidLoad</code> introduce el siguiente c\u00f3digo, que configura e inicializa el <code>UISearchController</code></li> </ol> <pre><code>//iOS intentar\u00e1 pintar la tabla, hay que inicializarla aunque sea vac\u00eda\nself.listaNotas = []\n//ListaNotasController recibir\u00e1 lo que se est\u00e1 escribiendo en la barra de b\u00fasqueda \nsearchController.searchResultsUpdater = self\n//Configuramos el search controller\nsearchController.obscuresBackgroundDuringPresentation = false\nsearchController.searchBar.placeholder = \"Buscar texto\"\n//Lo a\u00f1adimos a la tabla\nsearchController.searchBar.sizeToFit()\nself.tableView.tableHeaderView = searchController.searchBar\n</code></pre> <ol> <li>La propiedad <code>searchResultsUpdater</code> indica qui\u00e9n es el delegate del <code>UISearchController</code>, en este caso <code>ListaNotasViewController</code>. El delegate debe ser conforme al protocolo <code>UISearchResultsUpdating</code>, que requiere que se implemente un m\u00e9todo llamado <code>updateSearchResults(for:)</code>.</li> </ol> <p>Cambia la cabecera de <code>ListaNotasViewController</code> para declarar que es conforme al protocolo <code>UISearchResultsUpdating</code>:</p> <p><pre><code>class ListaViewController: UITableViewController, UISearchResultsUpdating {\n  ...\n}  \n</code></pre> Define en la clase el m\u00e9todo <code>updateSearchResults(for:)</code></p> <pre><code>func updateSearchResults(for searchController: UISearchController) {\n    let texto = searchController.searchBar.text!\n    print(\"Buscando \\(texto)\")\n}\n</code></pre> <p>Prueba la aplicaci\u00f3n para comprobar que todo est\u00e1 correcto, y deber\u00edas ver que cada vez que se escribe en la barra de b\u00fasqueda se llama a este m\u00e9todo y se imprime en la consola la cadena buscada.</p>"},{"location":"cap6/3_ejercicios/#implementacion-del-codigo-de-busqueda-05-puntos","title":"Implementaci\u00f3n del c\u00f3digo de b\u00fasqueda (0.5 puntos)","text":"<p><code>updateSearchResults</code> se llama por cada nuevo car\u00e1cter escrito en la barra de b\u00fasquedas, lo que permite actualizar los datos en \"tiempo real\" pero es muy ineficiente. Veremos c\u00f3mo solucionarlo en el siguiente apartado, de momento dispararemos una nueva b\u00fasqueda por cada pulsaci\u00f3n</p> <p>Hecha la preparaci\u00f3n de la interfaz, falta implementar la b\u00fasqueda en s\u00ed. En el m\u00e9todo <code>updateSearchResults</code> debes crear una fetch request que busque las notas cuyo texto contenga el texto escrito en la barra de b\u00fasqueda, sin distinguir may\u00fasculas/min\u00fasculas o caracteres diacr\u00edticos. </p> <p>Recuerda que para que se actualicen los datos visibles debes llamar a <code>tableView.reloadData()</code></p> <p>Una vez comprobado que funciona, mejora la fetch request para que las notas aparezcan en orden inverso por fecha, de m\u00e1s reciente a m\u00e1s antigua.</p>"},{"location":"cap6/3_ejercicios/#throttling-de-las-busquedas-025-puntos","title":"Throttling de las b\u00fasquedas (0.25 puntos)","text":"<p>Lanzar una nueva fetch request por cada car\u00e1cter tecleado es muy ineficiente, sobre todo si el usuario teclea r\u00e1pido y ni siquiera da tiempo a ver los resultados intermedios. Una implementaci\u00f3n mejor har\u00eda throttling de la b\u00fasqueda, es decir, impedir\u00eda que se repita la operaci\u00f3n si todav\u00eda no ha pasado un m\u00ednimo de tiempo desde la anterior.</p> <p>La idea es que si se intenta repetir la operaci\u00f3n y todav\u00eda no ha pasado un tiempo prefijado por nosotros, la nueva operaci\u00f3n se retrase hasta que pase el intervalo de tiempo. Esto no est\u00e1 implementado en los APIs de iOS pero en Internet pod\u00e9is encontrar diversas implementaciones. La siguiente clase, tomada de este tutorial, implementa esta funcionalidad.</p> <pre><code>import Foundation\n\n//De https://www.craftappco.com/blog/2018/5/30/simple-throttling-in-swift\nclass Throttler {\n    private var workItem: DispatchWorkItem = DispatchWorkItem(block: {})\n    private var previousRun: Date = Date.distantPast\n    private let queue: DispatchQueue\n    private let minimumDelay: TimeInterval\n\n    init(minimumDelay: TimeInterval, queue: DispatchQueue = DispatchQueue.main) {\n        self.minimumDelay = minimumDelay\n        self.queue = queue\n    }\n\n    func throttle(_ block: @escaping () -&gt; Void) {\n        // Cancel any existing work item if it has not yet executed\n        workItem.cancel()\n\n        // Re-assign workItem with the new block task, resetting the previousRun time when it executes\n        workItem = DispatchWorkItem() {\n            [weak self] in\n            self?.previousRun = Date()\n            block()\n        }\n\n        // If the time since the previous run is more than the required minimum delay\n        // =&gt; execute the workItem immediately\n        // else\n        // =&gt; delay the workItem execution by the minimum delay time\n        let delay = previousRun.timeIntervalSinceNow &gt; minimumDelay ? 0 : minimumDelay\n        queue.asyncAfter(deadline: .now() + Double(delay), execute: workItem)\n    }\n}\n</code></pre> <p>Crea un nuevo fichero Swift en tu proyecto con esta clase. Para usarlo en <code>ListaNotasViewController</code>:</p> <ol> <li>Define una variable miembro de tipo <code>Throttler</code> con el intervalo de tiempo deseado, por ejemplo 0.5 segundos (no queremos repetir b\u00fasquedas con m\u00e1s frecuencia)</li> </ol> <pre><code>let throttler = Throttler(minimumDelay: 0.5)\n</code></pre> <ol> <li>En el <code>updateSearchResults</code> \"envuelve\" tu c\u00f3digo de b\u00fasqueda en un <code>throttle</code>. Autom\u00e1ticamente la clase <code>Throttler</code> se encargar\u00e1 de que el c\u00f3digo no se ejecute m\u00e1s de 1 vez por cada 0.5 segundos (o el intervalo que hayas elegido)</li> </ol> <pre><code>func updateSearchResults(for searchController: UISearchController) {\n    throttler.throttle {\n        let texto = searchController.searchBar.text!\n        //Aqu\u00ed ir\u00eda tu c\u00f3digo de b\u00fasqueda\n    }\n}\n</code></pre>"},{"location":"cap6/intro/","title":"Intro","text":""},{"location":"cap6/intro/#introduccion","title":"Introducci\u00f3n","text":"<p>Hasta ahora solo hemos visto c\u00f3mo recuperar todas las instancias de una clase, pero en cualquier aplicaci\u00f3n medianamente compleja vamos a necesitar hacer b\u00fasquedas sobre el almacenamiento persistente. En esta sesi\u00f3n veremos m\u00e1s detalles sobre c\u00f3mo funcionan las fetch requests y c\u00f3mo filtrar y ordenar los datos para obtener solo los que queremos y en el orden que queremos. </p>"},{"location":"cap7/1_el_frc/","title":"El \"fetched results controller\"","text":"<p>Hasta ahora hemos obtenido los datos de Core Data con fetch requests. En principio no es complicado mostrar estos datos en una tabla, ya que como ya hemos visto, al ejecutar una fetch request obtenemos un array. A lo largo del curso hemos usado m\u00faltiples veces arrays como fuentes de datos para vistas de tabla. Pero hacer esto presenta una serie de dificultades:</p> <p>En primer lugar, se pueden dar problemas de rendimiento. Si hay muchos datos, tenerlos todos en un array ocupar\u00e1 demasiada memoria. Una estrategia m\u00e1s inteligente es ir carg\u00e1ndolos a medida que los vamos necesitando (conforme nos vamos desplazando por la tabla), pero vamos a emplear mucho tiempo implementando esta funcionalidad, que no es trivial.</p> <p>Adem\u00e1s, hay que tener en cuenta que los datos pueden cambiar. Cada vez que cambie un dato tenemos que actualizar manualmente la tabla, lo que es tedioso.</p> <p>La clase <code>FetchedResultsController</code> viene a solucionar todos estos problemas. Por un lado, va a ir obteniendo los datos a medida que sean necesarios, por lotes, o batches. Adem\u00e1s los guardar\u00e1 autom\u00e1ticamente en una cache para aumentar la eficiencia. Y por otro se suscribe a los cambios en el contexto para que cuando cambie un objeto lo podamos reflejar de forma sencilla en la tabla. Trabajar con un fetched results controller no va a ser trivial, pero s\u00ed mucho m\u00e1s sencillo que si tuvi\u00e9ramos que implementar todas estas funcionalidades nosotros mismos.</p>"},{"location":"cap7/2_configuracion_basica/","title":"Inicializar el \"fetched results controller\"","text":"<p>Vamos a empezar con un fetched results controller \"m\u00ednimo\". Supondremos que estamos usando un view controller que hereda de <code>UITableViewController</code> (aunque no va a haber gran diferencia si no usamos esta clase).</p> <p>Lo primero es crear el <code>NSFetchedResultsController</code>. Para ello necesitamos como m\u00ednimo dos cosas:</p> <ul> <li>Asociarle una fetch request, que devuelva los datos que queramos mostrar en la tabla.</li> <li>Que dicha request est\u00e9 ordenada. Ya hemos visto que Core Data no asegura por defecto un orden determinado al obtener los resultados de una fetch request, pero las filas de la tabla s\u00ed tienen un orden definido, por lo que necesitamos que los resultados tambi\u00e9n lo tengan. O sea, necesitamos que la request use <code>NSSortDescriptor</code>.</li> </ul> <p>Adem\u00e1s podemos crear una cache para que sea m\u00e1s eficiente. Como veremos es muy sencillo y no requiere casi trabajo por nuestra parte. </p> <p>Continuaremos con el ejemplo de los usuarios, las conversaciones y los mensajes. Vamos a hacer por ejemplo una tabla que muestre los mensajes (entidad y clase <code>Mensaje</code>). Para simplificar el c\u00f3digo, gestionaremos el <code>NSFetchedResultsController</code> en el controller de la pantalla con la tabla. Lo primero es definirnos una propiedad para almacenarlo, ya que lo usaremos en diversos m\u00e9todos:</p> <pre><code>import UIKit\nimport CoreData\n\nclass MiController : UITableViewController {\n  var frc : NSFetchedResultsController&lt;Mensaje&gt;! \n\n  ...\n}\n</code></pre> <p>En el ejemplo hemos usado un <code>UITableViewController</code>, pero nos servir\u00eda cualquier <code>ViewController</code>.</p> <p>Ahora podemos inicializar el fetched results controller en el <code>viewDidLoad</code></p> <pre><code>override func viewDidLoad() {\n    super.viewDidLoad()\n\n    let miDelegate = UIApplication.shared.delegate! as! AppDelegate\n    let miContexto = miDelegate.persistentContainer.viewContext\n\n    let consulta = NSFetchRequest&lt;Mensaje&gt;(entityName: \"Mensaje\")\n    let sortDescriptors = [NSSortDescriptor(key:\"fecha\", ascending:false)]\n    consulta.sortDescriptors = sortDescriptors\n    self.frc = NSFetchedResultsController&lt;Mensaje&gt;(fetchRequest: consulta, managedObjectContext: miContexto, sectionNameKeyPath: nil, cacheName: \"miCache\")\n\n    //ejecutamos el fetch\n    try! self.frc.performFetch()\n}\n</code></pre> <p>N\u00f3tese que al inicializador debemos pasarle cuatro par\u00e1metros:</p> <ul> <li>La fetch request para filtrar los datos, que adem\u00e1s debe estar ordenada con <code>sortDescriptors</code></li> <li>El contexto de persistencia</li> <li>Un sitio de donde sacar c\u00f3mo se divide la tabla en secciones. Por el momento generamos una \u00fanica secci\u00f3n por lo que ponemos esto a <code>nil</code></li> <li>Una cache a usar. Aunque hablaremos luego de ella, es tan sencillo crearla que ya lo hemos hecho aqu\u00ed. Basta con elegir un nombre que no usemos para otro fetched results controller.</li> </ul> <p>Una vez inicializado el controller llamamos a <code>performFetch</code> para que se ejecute la consulta.</p> <p>Para comprobar que funciona podemos imprimir provisionalmente los datos en la consola:</p> <pre><code>//Esto vendr\u00eda tambi\u00e9n dentro del viewDidLoad, a continuaci\u00f3n de lo anterior\nif let resultados = frc.fetchedObjects {\n    print(\"Hay \\(resultados.count) mensajes\")\n    for mensaje in resultados {\n        print (mensaje.texto!)\n    }\n}\n</code></pre> <p>Como puede verse, para ejecutar la query hay que llamar a <code>performFetch()</code>. Los resultados estar\u00e1n accesibles en forma de array en <code>fetchedObjects</code>. No obstante esta no es la forma t\u00edpica de obtener los resultados, para eso hubi\u00e9ramos ejecutado el fetch directamente. En la siguiente secci\u00f3n vamos a \"comunicar\" el fetched results controller con la tabla para que sea ella la que le pida los datos conforme los vaya necesitando. </p>"},{"location":"cap7/3_tabla/","title":"Mostrar los datos en la tabla","text":"<p>Recordemos que las tablas toman los datos de su datasource, un objeto que debe implementar una serie de m\u00e9todos que sirven para devolver el contenido: devolver el n\u00famero de secciones, devolver el n\u00famero de filas en una secci\u00f3n y devolver una fila en concreto. El API de fetched results controller tiene m\u00e9todos para hacer precisamente esto, as\u00ed que en nuestro c\u00f3digo nos limitaremos m\u00e1s o menos a \"pasarle la pelota\".</p> <p>Para simplificar el ejemplo haremos que el datasource de la tabla sea el view controller. Vamos a implementar en \u00e9l los m\u00e9todos necesarios.</p> <p>Si usamos un <code>UITableViewController</code>, Xcode habr\u00e1 generado para nosotros el esqueleto de estos m\u00e9todos. Por otro lado, autom\u00e1ticamente el view controller es el datasource de la tabla, conexi\u00f3n que tendr\u00edamos que hacer de modo manual si usamos otro tipo de view controller.</p> <p>Primero vamos a ocuparnos del n\u00famero de secciones. La propiedad <code>sections</code> del fetched results controller, es un array con las secciones de la tabla, as\u00ed que basta con devolver el tama\u00f1o de este array. En realidad por el momento podr\u00edamos devolver simplemente <code>1</code>, ya que hemos dicho que no tenemos secciones en la tabla, pero vamos a dejar el c\u00f3digo preparado para no tener que modificarlo luego.</p> <pre><code>override func numberOfSections(in tableView: UITableView) -&gt; Int {\n    return self.frc.sections!.count\n}\n</code></pre> <p>Recordemos que <code>frc</code> es una propiedad que hemos definido en el view controller y que referencia al fetched results controller.</p> <p>El m\u00e9todo que devuelve el n\u00famero de filas en la secci\u00f3n actual es solo un poco m\u00e1s complicado</p> <pre><code>override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {\n    return self.frc.sections![section].numberOfObjects\n}\n</code></pre> <p>Simplemente accedemos a la secci\u00f3n en cuesti\u00f3n y devolvemos su propiedad <code>numberOfObjects</code>, que es el n\u00famero de filas en la secci\u00f3n.</p> <p>Ya solo nos falta el m\u00e9todo m\u00e1s complicado, el que devuelve una fila dada su posici\u00f3n o index path. En realidad es sencillo de implementar, porque el m\u00e9todo <code>object(at:)</code> del fetched results controller nos devuelve un dato dado su index path. Solo tenemos que \"empaquetar\" la informaci\u00f3n en una celda.</p> <pre><code>override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {\n    //recordar que el prototipo de celda tiene un \"reuse identifier\"\n    //que hay que asignar en el storyboard\n    let cell = tableView.dequeueReusableCell(withIdentifier: \"miCelda\", for: indexPath)\n\n    let mensaje = self.frc.object(at: indexPath)\n    cell.textLabel?.text = mensaje.texto!\n    return cell\n}\n</code></pre> <p>N\u00f3tese que cuando inicializamos el fetched results controller lo hacemos con el tipo <code>Mensaje</code> (como <code>NSFetchedResultsController&lt;Mensaje&gt;</code>). As\u00ed que cuando obtenemos un objeto con <code>object(at:)</code> Swift \"sabe\" que es un <code>Mensaje</code> y no es necesario hacer el cast.</p> <p>Con todo esto ya tenemos la misma funcionalidad que ten\u00edamos cuando us\u00e1bamos arrays para almacenar los datos de la tabla, a partir de ahora vamos a ver qu\u00e9 ventajas adicionales nos da el fetched results controller frente a la versi\u00f3n anterior.</p>"},{"location":"cap7/4_refrescar_tabla/","title":"Refrescar la tabla","text":"<p>Tal y como est\u00e1 ahora el c\u00f3digo si creamos un nuevo mensaje este no aparece en la tabla. Pero podemos resolverlo de forma sencilla con el fetched results controller, ya que este est\u00e1 \u201csuscrito\u201d a los cambios que se producen en el contexto de persistencia, siempre que afecten a los contenidos en su fetch request. </p> <p>El fetched results controller avisar\u00e1 a su vez de estos cambios a su delegate. Para simplificar, haremos que este sea el view controller, aunque podr\u00eda ser cualquier clase.</p> <pre><code>//En el viewDidLoad, tras crear el fetched results controller\nself.frc.delegate = self;\n</code></pre> <p>Lo anterior, en lugar de por c\u00f3digo, se puede hacer gr\u00e1ficamente en Xcode con el connections inspector.</p> <p>Por tanto tendremos que pasar a implementar el protocolo correspondiente, ya que el fetched results controller llamar\u00e1 a una serie de m\u00e9todos cuando se modifique el contexto. Lo primero es indicarlo en la cabecera de la clase:</p> <pre><code>import UIKit\nimport CoreData\n\nclass MiController : UITableViewController, NSFetchedResultsControllerDelegate {\n ...\n}\n</code></pre> <p>El protocolo tiene cuatro m\u00e9todos que vamos a ver a continuaci\u00f3n.</p> <p>Cuando se van a modificar los datos y cuando ya se han modificado el fetched results controller avisar\u00e1 a su delegate llamando a <code>controllerWillChangeContent</code> y <code>controllerDidChangeContent</code>, respectivamente. Podemos aprovechar estos dos m\u00e9todos para llamar al <code>beginUpdates()</code> y <code>endUpdates</code> de la tabla. De este modo si se modifican varias filas \"de golpe\" la animaci\u00f3n se har\u00e1 de forma conjunta.</p> <pre><code>func controllerWillChangeContent(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;) {\n    self.tableView.beginUpdates()\n}\n\nfunc controllerDidChangeContent(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;) {\n    self.tableView.endUpdates()\n}\n</code></pre> <p>Cuando se ha modificado alg\u00fan objeto del contexto y esta modificaci\u00f3n afecte a los resultados del fetched results controller se llamar\u00e1 al m\u00e9todo m\u00e1s complejo del protocolo: <code>controller(_:didChange:at:for:newIndexPath:)</code>. El c\u00f3digo del m\u00e9todo va a ser algo largo porque aqu\u00ed tenemos que tratar con los cuatro tipos de modificaciones posibles: <code>.insert</code>, <code>.move</code>, <code>.delete</code> y <code>.update</code>.</p> <pre><code>func controller(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;, didChange anObject: Any, at indexPath: IndexPath?, for type: NSFetchedResultsChangeType, newIndexPath: IndexPath?) {\n    switch type {\n    case .insert:\n        self.tableView.insertRows(at: [newIndexPath!], with:.automatic )\n    case .update:\n        self.tableView.reloadRows(at: [indexPath!], with: .automatic)\n    case .delete:\n        self.tableView.deleteRows(at: [indexPath!], with: .automatic)\n    case .move:\n        self.tableView.deleteRows(at: [indexPath!], with: .automatic)\n        self.tableView.insertRows(at: [newIndexPath!], with:.automatic )\n    }\n}\n</code></pre> <p>Como vemos, el c\u00f3digo es bastante directo, simplemente hay que trasladar a la vista de tabla lo que nos est\u00e1 diciendo el fetched results controller: si se ha insertado un dato insertamos una fila, si se ha borrado la borramos, etc. </p> <p>El \u00faltimo de los m\u00e9todos del protocolo se usa cuando se modifican las secciones de la tabla. Todav\u00eda no hemos visto c\u00f3mo decirle al fetched results controller que cree una tabla con secciones, pero no lo necesitamos para ver ya c\u00f3mo se modifican.</p> <pre><code>func controller(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;, didChange sectionInfo: NSFetchedResultsSectionInfo, atSectionIndex sectionIndex: Int, for type: NSFetchedResultsChangeType) {\n    switch(type) {\n    case .insert:\n        self.tableView.insertSections(IndexSet(integer:sectionIndex), with: .automatic)\n    case .delete:\n        self.tableView.deleteSections(IndexSet(integer:sectionIndex), with: .automatic)\n    default: break\n    }\n}\n</code></pre>"},{"location":"cap7/5_secciones/","title":"Secciones de tabla autom\u00e1ticas","text":"<p>Podemos conseguir generar secciones de modo autom\u00e1tico bas\u00e1ndonos en alguna propiedad de la entidad sobre la que se hace la fetch request. Tiene que ser la misma propiedad que se usa para ordenar o alguna basada en ella, ya que elementos que siguen el orden del listado no pueden ir alternando de secci\u00f3n (las secciones no se repiten).</p> <p>Al crear el fetched results controller especificamos  en el par\u00e1metro <code>sectionNameKeyPath</code> la propiedad a usar para generar secciones. Por ejemplo, podr\u00edamos agrupar los mensajes por el t\u00edtulo de la conversaci\u00f3n a la que pertenecen.</p> <pre><code>self.frc = NSFetchedResultsController&lt;Mensaje&gt;(fetchRequest: consulta, managedObjectContext: miContexto, sectionNameKeyPath: \"conversacion.titulo\", cacheName: \"miCache\")\n</code></pre> <p>En el datasource de la tabla tenemos tambi\u00e9n que implementar algunos m\u00e9todos relativos al manejo de secciones. El fetched results controller es el que se ocupa de ello, por lo que delegaremos en \u00e9l. En la clase que act\u00fae como datasource de la tabla har\u00edamos:</p> <pre><code>/* obtener el t\u00edtulo de una secci\u00f3n dada */\nfunc tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {\n        return self.frc.sections?[section].name\n}\n\n/* obtener el n\u00famero de secciones de la tabla */    \nfunc numberOfSections(in tableView: UITableView) -&gt; Int {\n        return frc.sections!.count\n}\n</code></pre>"},{"location":"cap7/6_ejercicios/","title":"Ejercicios","text":"<p>Las modificaciones de estos ejercicios no afectan al c\u00f3digo de las sesiones anteriores, as\u00ed que no es necesario que hagas ninguna copia del estado del proyecto antes de empezar con esta sesi\u00f3n.</p> <p>Vamos a ampliar la dichosa aplicaci\u00f3n de notas para que use un fetched results controller. Para no afectar a lo ya hecho, haremos una tercera pantalla con un listado de todas las notas usando un <code>FetchedResultsController</code> (no es necesario implementar b\u00fasqueda como tienes en el otro listado)</p>"},{"location":"cap7/6_ejercicios/#interfaz-grafico","title":"Interfaz gr\u00e1fico","text":"<p>Crea una nueva pantalla de tipo <code>Table View Controller</code>. Conecta la primera pantalla a esta (<code>Ctrl+Arrastrar</code> y elegir como tipo de segue <code>View Controllers</code>). Al final en la aplicaci\u00f3n tendr\u00e1s un tab bar con tres opciones.</p> <p>Haz una tercera pantalla, no cambies la que ten\u00edas para que no se pierda el c\u00f3digo que hiciste en la sesi\u00f3n anterior. Evidentemente en una aplicaci\u00f3n \"normal\" no tendr\u00eda sentido tener dos pantallas con la lista de notas.</p> <p>Para esta pantalla, crea una nueva clase <code>ListaNotasCDController</code> (\"CD\" de \u201cCore Data\u201d) que herede de <code>UITableViewController</code>. Recuerda que para que tu clase herede de una de iOS lo m\u00e1s sencillo es usar la plantilla \"Cocoa Touch Class\". </p> <p>Recuerda hacer en el storyboard que esta clase sea el controller de esta pantalla. Para ello, selecciona la pantalla de listado de notas (clic en el primero de los iconos de la barra superior, el de fondo amarillo)  y en el Identity Inspector ( tercero de los iconos del \u00e1rea de la derecha), como \"Custom Class\" elige <code>ListaNotasCDController</code>.</p> <p></p>"},{"location":"cap7/6_ejercicios/#listar-notas-025-puntos","title":"Listar notas (0.25 puntos)","text":""},{"location":"cap7/6_ejercicios/#listar-provisionalmente-en-la-consola","title":"Listar provisionalmente en la consola","text":"<p>Siguiendo el c\u00f3digo de los apuntes y las transparencias usa un fetched results controller para mostrar todas las notas en la tabla. De momento cuando se inserten notas nuevas la lista no se actualizar\u00e1. Primero simplemente haz que los datos aparezcan en la consola (consulta el apartado \"inicializar el fetched results...\"). </p>"},{"location":"cap7/6_ejercicios/#listar-notas-en-la-tabla","title":"Listar notas en la tabla","text":"<p>Una vez hecho esto, ya puedes listar las notas en la tabla. Consulta la secci\u00f3n mostrar los datos en la tabla. El problema es que cuando insertes una nueva nota esta no se reflejar\u00e1 en la tabla, solo ver\u00e1s las que hab\u00eda al arrancar la app.</p>"},{"location":"cap7/6_ejercicios/#refrescar-las-notas-de-la-tabla-025-puntos","title":"Refrescar las notas de la tabla (0.25 puntos)","text":"<p>Para esto hay que implementar lo que aparece en la secci\u00f3n \"Refrescar la tabla\" de los apuntes. Una vez hecho, comprueba que cuando insertamos una nota nueva en la pantalla de notas se muestra en la lista del fetched results controller</p>"},{"location":"cap7/6_ejercicios/#eliminar-filas-025-puntos","title":"Eliminar filas (0.25 puntos)","text":"<p>Para ver c\u00f3mo se modifican las filas \"en directo\", haz que se puedan borrar notas haciendo swipe to delete en la tabla. Para que funcione este gesto, hay que implementar el m\u00e9todo:</p> <pre><code>override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) {\n        if editingStyle == .delete {\n            let miDelegate = UIApplication.shared.delegate as! AppDelegate\n            let miContexto = miDelegate.persistentContainer.viewContext\n            //FALTA: eliminar del contexto el objeto en la posici\u00f3n indexPath\n            //Ten\u00e9is que obtenerlo del fetched results controller\n            //parecido a como se hace para pintar la celda\n            ...\n            //guardamos el contexto\n            try! miContexto.save()\n        }\n}\n</code></pre> <p>Ahora puedes probar a borrar una celda haciendo sobre ella el gesto de swipe a la izquierda y ver que se actualiza la lista.</p>"},{"location":"cap7/6_ejercicios/#secciones-de-tabla-025-puntos","title":"Secciones de tabla (0.25 puntos)","text":"<p>Finalmente, haz que la tabla tenga secciones autom\u00e1ticas seg\u00fan la primera letra del texto de cada nota. Para ello:</p> <ul> <li>Crea una extensi\u00f3n de la clase <code>Nota</code> y a\u00f1\u00e1dele una propiedad calculada llamada <code>inicial</code> que devuelva solo esta:</li> </ul> <pre><code>//Archivo Nota+Custom.swift\nimport Foundation\n\nextension Nota {\n    //Devuelve una subcadena solo con la primera letra del texto\n    @objc var inicial: String? {\n        if let textoNoNil = self.texto {\n            return String(textoNoNil.first!)\n        }\n        else {\n            return nil\n        }\n    }\n}\n</code></pre> <ul> <li>Cuando creas el fetched results controller hay que especificar en el par\u00e1metro <code>sectionNameKeyPath</code> la propiedad usada para dividir en secciones: \"inicial\".</li> <li>En el datasource de la tabla (en nuestro caso el controller) tienes tambi\u00e9n que implementar el m\u00e9todo que genera los t\u00edtulos de las secciones (<code>tableView(_:,titleForHeaderInSection)</code>). </li> <li>Finalmente tendr\u00e1s que cambiar el <code>NSSortDescriptor</code> con el que se crea el fetched results controller para que asegure que las notas no se \"crucen\" de secci\u00f3n. Ten en cuenta que si las sigues ordenando por fecha podr\u00eda haber una que comience por \"a\", otra por \"b\" y luego otra por \"a\" otra vez, y eso no tendr\u00eda sentido de cara a las secciones. Puedes conseguir que no haya problema si ordenas por texto en vez de por fecha.</li> </ul>"},{"location":"cap7/intro/","title":"Intro","text":""},{"location":"cap7/intro/#introduccion","title":"Introducci\u00f3n","text":"<p>Siendo las tablas la forma m\u00e1s t\u00edpica de mostrar listas de datos en pantalla, es natural que en una aplicaci\u00f3n con Core Data mostremos los datos de las entidades en tablas. Para ayudarnos a gestionar la conjunci\u00f3n de tablas y Core Data, iOS nos da el llamado fetched results controller, que simplificar\u00e1 algunos aspectos del desarrollo, asegur\u00e1ndose a la vez de que el rendimiento es lo mejor posible sin que tengamos que preocuparnos de estos aspectos de manera \"manual\". </p>"},{"location":"cap8/1_intro/","title":"Qu\u00e9 son las migraciones de datos","text":"<p>A lo largo del ciclo de desarrollo de una aplicaci\u00f3n, conforme le vayamos a\u00f1adiendo funcionalidades es habitual que el modelo de datos vaya creciendo: iremos a\u00f1adiendo entidades y/o relaciones, o atributos a entidades. En otros casos tendremos que refactorizar el modelo porque nos habremos dado cuenta de que hay ciertas cosas mejorables: quiz\u00e1 tenemos que eliminar atributos, o renombrarlos, o fusionar o dividir entidades, ... Es decir, el modelo de datos va a ir evolucionando en el proceso de desarrollo, incluso despu\u00e9s de lanzar la primera versi\u00f3n de la aplicaci\u00f3n en la App Store. </p> <p>El problema que se plantea al cambiar el modelo de datos existente es qu\u00e9 hacer con los datos que ya tenemos. Por ejemplo si decidimos a\u00f1adir un nuevo atributo debemos pensar qu\u00e9 hacer con los datos que ya existen y que no tienen valor asignado para \u00e9l. Una soluci\u00f3n dr\u00e1stica ser\u00eda comenzar de cero, borrar todos los datos y empezar de nuevo. En desarrollo basta con ir al directorio donde Core Data guarda la base de datos SQLite y eliminarla manualmente (en el directorio <code>Library/Application Support</code> donde reside la aplicaci\u00f3n). Pero evidentemente no podemos decirle a un usuario que al instalar la versi\u00f3n 2.0 de nuestra app va a perder todos sus datos. Hay que definir alg\u00fan procedimiento para transformar los datos ya existentes a la nueva versi\u00f3n del modelo. A este procedimiento de \"traslado\" se le llama migraci\u00f3n de datos. Por ejemplo en el caso del nuevo atributo el procedimiento podr\u00eda ser tan simple como dar un valor por defecto a los datos antiguos, o dejarlo vac\u00edo, dependiendo de los requerimientos de la aplicaci\u00f3n.</p> <p>En la documentaci\u00f3n de Apple se distinguen dos tipos de migraciones: las migraciones ligeras (lightweight) y las migraciones \"a secas\" o manuales (o en algunos sitios llamadas pesadas por contraposici\u00f3n a las ligeras). Las primeras son autom\u00e1ticas o semiautom\u00e1ticas, requiriendo en general poco trabajo por nuestra parte o ninguno. Para las segundas vamos a tener que realizar la transformaci\u00f3n de datos de forma manual, generalmente escribiendo c\u00f3digo que indique c\u00f3mo transformar los datos antiguos al nuevo \"formato\".</p> <p>En esta sesi\u00f3n vamos a ver c\u00f3mo hacer migraciones de los dos tipos, pero antes vamos a ver c\u00f3mo \"decirle\" a Core Data que queremos modificar el modelo.</p>"},{"location":"cap8/2_versiones/","title":"Versiones del modelo de datos","text":"<p>Siendo la evoluci\u00f3n progresiva del modelo de datos algo tan com\u00fan en cualquier desarrollo de aplicaci\u00f3n iOS es l\u00f3gico que Core Data tenga alg\u00fan mecanismo de control de versiones, para que sea accesible el historial de los sucesivos cambios. No estamos hablando del control de versiones general del proyecto, (<code>git</code> o el que sea que usemos), ya que con el \"tradicional\" Core Data no tiene acceso m\u00e1s que a la \u00faltima versi\u00f3n del modelo.</p> <p>Hasta ahora cuando hemos hecho cualquier modificaci\u00f3n del modelo en nuestros proyectos simplemente la hemos hecho sin m\u00e1s y en su caso hemos guardado los cambios con <code>Cmd-S</code>. Pero esta no es la forma m\u00e1s adecuada de hacerlo. Lo que debemos hacer es especificar que queremos crear una nueva versi\u00f3n del modelo.</p> <p>Migraciones sin versionado</p> <p>En realidad, hasta el momento la estrategia de ir modificando el modelo de datos \"sobre la marcha\" nos ha funcionado porque el stack de Core Data que crea la plantilla por defecto de Xcode usa la clase <code>NSPersistentContainer</code> que al arrancar la app verifica que el modelo de datos sea el mismo que el usado para crear la BD actual, y si no lo es, efect\u00faa autom\u00e1ticamente la migraci\u00f3n.  Si estuvi\u00e9ramos usando una inicializaci\u00f3n del stack de Core Data propia que no usara <code>NSPersistentContainer</code> es posible que al cambiar el modelo y arrancar la app nos encontr\u00e1ramos con un error que dice <code>\"The model used to open the store is incompatible with the one used to create the store\"</code>. Para resolverlo tendr\u00edamos que cambiar a <code>NSPersistentContainer</code> o bien borrar manualmente la base de datos para forzar a Core Data a crearla de cero (en este caso perder\u00edamos todos los datos).</p> <p>En cualquier momento dado podemos crear una nueva versi\u00f3n del modelo de datos y tener varias almacenadas en nuestro proyecto (varios archivos <code>xcdatamodeld</code>) aunque en cada momento solo una de ellas se tomar\u00e1 como la \u201cactual\u201d.</p> <p>Para crear una nueva versi\u00f3n, seleccionar el <code>.xcdatamodeld</code> y en el men\u00fa de Xcode elegir <code>Editor &gt; Add Model Version</code>. Aparecer\u00e1 un cuadro de di\u00e1logo que nos pedir\u00e1 el nombre para la nueva versi\u00f3n y qu\u00e9 versi\u00f3n actual toma como base. A partir de este momento podremos ver en el \u00e1rbol de ficheros del proyecto una especie de sub\u00e1rbol con todas las versiones del <code>.xcdatamodeld</code>. La versi\u00f3n actual o activa en este momento aparece con una peque\u00f1a marca verde de verificaci\u00f3n.</p> <p></p> <p>Para cambiar de versi\u00f3n activa, en el panel de la derecha, pulsar sobre el primer icono (<code>Identity and type</code>), y en la parte inferior del panel elegir la versi\u00f3n en el desplegable <code>Model Version</code>.</p> <p></p>"},{"location":"cap8/3_migraciones_ligeras/","title":"Migraciones ligeras","text":"<p>Se conocen como migraciones ligeras aquellas en las que Core Data se puede encargar de manera pr\u00e1cticamente autom\u00e1tica de migrar los datos a la nueva versi\u00f3n del modelo. T\u00edpicamente comprenden estas operaciones:</p> <ul> <li>A\u00f1adir o eliminar un atributo o relaci\u00f3n</li> <li>Convertir en opcional un atributo requerido</li> <li>Convertir en requerido un atributo opcional, siempre que se d\u00e9 un valor por defecto</li> <li>A\u00f1adir o eliminar una entidad</li> <li>Renombrar un atributo o relaci\u00f3n</li> <li>Renombrar una entidad</li> </ul> <p>Hasta iOS9 inclusive, el stack de Core Data que creaba Xcode marcando la casilla <code>Use Core Data</code> al crear un proyecto no ten\u00eda activadas las migraciones ligeras por defecto. As\u00ed, cualquier cambio en el modelo llevaba a que la aplicaci\u00f3n dejara de funcionar, generando un error, y tuvi\u00e9ramos que borrar la base de datos manualmente para que volviera a hacerlo. Para averiguar c\u00f3mo activar las migraciones ligeras en iOS&lt;=9 se puede consultar el \u00faltimo punto de los apuntes de esta sesi\u00f3n.</p> <p>A partir de iOS10, si se usa la clase <code>NSPersistentContainer</code> para inicializar el stack de Core Data no hay que hacer nada especial para activar las migraciones ligeras. ya que vienen activadas por defecto. Recordemos que el c\u00f3digo de la plantilla de Xcode usa esta clase, as\u00ed que normalmente no tendremos que hacer nada.</p> <p>Esto quiere decir que podemos hacer cualquier modificaci\u00f3n de las listadas antes sin m\u00e1s, aunque se recomienda no modificar el modelo de datos directamente sino crear una nueva versi\u00f3n cada vez que cambiemos algo, como se explica en el apartado anterior.</p> <p>Para algunos tipos de modificaci\u00f3n la migraci\u00f3n autom\u00e1tica que hace por defecto Core Data es apropiada en la mayor\u00eda de casos, pero en otros tendremos que \"ayudarle\" algo, aunque siempre de modo sencillo.</p> <p>Por ejemplo, en caso de a\u00f1adir un atributo a una entidad existente, si especificamos un valor por defecto, Core Data lo fijar\u00e1 tambi\u00e9n para los datos que ya exist\u00edan, lo que es generalmente la mejor soluci\u00f3n.</p> <p>Sin embargo, al renombrar un atributo o entidad Core Data no detecta autom\u00e1ticamente que es un renombrado sino que lo interpreta por defecto como una eliminaci\u00f3n del antiguo y la creaci\u00f3n del nuevo, de modo que los antiguos valores se perder\u00e1n. Esto tiene sentido si pensamos que Core Data solo tiene acceso al estado actual del modelo, y no al proceso de edici\u00f3n en s\u00ed. Para indicarle a Core Data que no es un nuevo atributo sino el antiguo renombrado, vamos al panel de la derecha, y habiendo pulsado el tercero de los iconos (<code>`Data Model Inspector), en el cuadro de texto llamado</code>Renaming ID` tecleamos el nombre antiguo. Si hacemos esto, al migrar los datos se renombrar\u00e1 la columna de la tabla en lugar de crear una.</p> <p></p> <p>En todos los lugares donde antes se hiciera referencia al atributo con el nombre antiguo habr\u00e1 que cambiar  el c\u00f3digo para que reflejen el nuevo nombre. Por desgracia Xcode no nos va a ayudar en esta tarea.</p> <p>La configuraci\u00f3n que hemos hecho en el editor del modelo indicando cu\u00e1l era el nombre antiguo es lo que en Core Data se llama un mapping model, es decir una asociaci\u00f3n de elementos que permite pasar del modelo antiguo al nuevo. Veremos otras formas de especificar mapping models, bien sea gr\u00e1ficamente o por c\u00f3digo.</p>"},{"location":"cap8/4_migraciones_pesadas/","title":"Migraciones pesadas","text":"<p>Hay muchos cambios que no encajan en las operaciones previstas en las migraciones \u201cligeras\u201d. Por ejemplo supongamos que tenemos el nombre y apellidos en un campo <code>nombre_completo</code> en el t\u00edpico formato de apellido_1 apellido_2, nombre y queremos dividirlo en dos campos: <code>apellidos</code>  y <code>nombre</code> (o al contrario, partimos de dos y los queremos fusionar). En estos casos Core Data no puede inferir autom\u00e1ticamente la forma de transformar el modelo origen al modelo objetivo, y tenemos que especificar \u201cmanualmente\u201d c\u00f3mo hacer la transformaci\u00f3n.</p> <p>Como hemos dicho, la transformaci\u00f3n entre un modelo y otro se representa en iOS mediante un mapping model, y es lo que tenemos que darle a Core Data para que pueda actualizar los datos al nuevo modelo.</p> <p>Lo que har\u00e1 Core Data durante el proceso de migraci\u00f3n es cargar cada entidad en memoria, convertirla del modelo actual al nuevo ayud\u00e1ndose del mapping model y guardarla de nuevo en el almacenamiento persistente. Y hemos dicho Core Data, pero en realidad lo que tendremos que hacer ser\u00e1 escribir nosotros c\u00f3digo que haga esta tarea. Adem\u00e1s del trabajo para nosotros, las migraciones de este tipo son mucho m\u00e1s costosas en tiempo y capacidad de procesamiento que las ligeras. Normalmente la aplicaci\u00f3n necesitar\u00e1 mostrar al usuario un cuadro de di\u00e1logo o similar que le indique que se est\u00e1 realizando la operaci\u00f3n.</p> <p>Vamos a ver c\u00f3mo se implementar\u00eda una migraci\u00f3n \u201cpesada\u201d con un ejemplo concreto. Supongamos que en la aplicaci\u00f3n de notas nos hemos dado cuenta de que el campo \u201ccategoria\u201d no est\u00e1 del todo bien, ya que as\u00ed solo podemos hacer que una nota pertenezca a una \u00fanica categor\u00eda, y adem\u00e1s cuando varias notas tienen la misma categor\u00eda cada una debe repetir el valor. Ser\u00eda mejor tener una entidad \u201ccategor\u00eda\u201d aparte y establecer una relaci\u00f3n \u201cuno a muchos\u201d en ambas direcciones.</p> <p>Lo primero es crear una nueva versi\u00f3n del modelo de datos con este cambio.</p>"},{"location":"cap8/4_migraciones_pesadas/#crear-el-mapping-model","title":"Crear el \u201cmapping model\u201d","text":"<p>El nuevo modelo de datos tendr\u00e1 el aspecto de la siguiente figura:</p> <p></p> <p>ahora tenemos que crear el mapping model que nos transforme el modelo actual en el nuevo modelo. En <code>File &gt; New</code> seleccionamos la categor\u00eda <code>Core Data</code> y elegimos la plantilla <code>Mapping Model</code>. El asistente nos preguntar\u00e1 cu\u00e1l es el modelo origen, cu\u00e1l el destino, y nos pedir\u00e1 un nombre para el nuevo archivo <code>.xcmappingmodel</code> que crear\u00e1.</p> <p>Si abrimos el archivo creado, veremos que Xcode ha intentado deducir la correspondencia entre el modelo origen y el destino. </p> <p></p> <p>A la izquierda veremos los Entity Mappings (c\u00f3mo pasar de una entidad antigua a una nueva). T\u00edpicamente a estos los llama con el nombre de la entidad antigua y la nueva, algo como <code>NotaToNota</code>. Para las entidades nuevas pone simplemente el nombre de la entidad. </p> <p>Para cada Entity Mapping tenemos los Attribute Mappings y los Relationship mappings correspondientes. Se usa un conjunto de variables predefinido para expresarlos. Por ejemplo, <code>$source</code> indica la entidad origen. De modo que si en un atributo vemos <code>$source.texto</code> indica que Xcode ha deducido que para generar este atributo tenemos que copiar el valor del atributo <code>texto</code> de la entidad original. Para una lista de variables se recomienda consultar la secci\u00f3n correspondiente de la \u201cCore Data Model Versioning and Data Migration Programming Guide\u201d.</p>"},{"location":"cap8/4_migraciones_pesadas/#crear-la-migration-policy","title":"Crear la \u201cmigration policy\u201d","text":"<p>De la migraci\u00f3n entre entidades del modelo \u201cantiguo\u201d y del \u201cnuevo\u201d se encarga la clase <code>NSEntityMigrationPolicy</code>. Si queremos personalizar la migraci\u00f3n, como es nuestro caso para generar la nueva entidad <code>Categoria</code> a partir de los valores del antiguo atributo <code>categoria</code>, tendremos que crear una clase propia que herede de ella:</p> <p></p> <p>Tendremos tambi\u00e9n que especificar en el Mapping Model que vamos a usar esta clase para hacer una migraci\u00f3n de entidad determinada. Seleccionamos la migraci\u00f3n <code>NotaToNota</code> y en las propiedades escribimos el nombre de la nueva clase en el campo <code>Custom Policy</code>.</p> <p></p> <p>En la clase hay una serie de m\u00e9todos que podemos sobreescribir para adaptar la migraci\u00f3n a nuestras necesidades, pero el \u00fanico que suele ser necesario es <code>createDestinationInstances(forSource:in:manager:)</code>, que se debe encargar de crear a partir de una instancia de la antigua entidad, la nueva entidad (o nuevas, si debe haber m\u00e1s de una). Este m\u00e9todo se ir\u00e1 llamando para cada una de las entidades actualmente en el almac\u00e9n persistente, para irlas migrando una a una. </p> <p>Para nuestro problema particular, lo que debemos hacer en este m\u00e9todo es obtener la categor\u00eda a la que pertenece la nota y crear una nueva entidad <code>Categoria</code> basada en ella. Despu\u00e9s establecemos la relaci\u00f3n entre la nota y su por ahora \u00fanica categor\u00eda. Hay un peque\u00f1o problema a tener en cuenta: como habr\u00e1 varias notas de la misma categor\u00eda no podemos crear directamente la entidad <code>Categoria</code>, solo la crearemos si no existe ya. Vamos a guardar las <code>Categoria</code> que creamos en un diccionario para poder saber las que ya hemos creado</p> <pre><code>var categorias : [String : NSManagedObject] = [:]\n</code></pre> <p>Aqu\u00ed tenemos el c\u00f3digo de la clase que hace la migraci\u00f3n</p> <pre><code>import UIKit\nimport CoreData\n\nclass CrearCategoriasMigrationPolicy: NSEntityMigrationPolicy {\n    //instancias de categor\u00edas que existen ya\n    var categorias : [String : NSManagedObject] = [:]\n\n    override func createDestinationInstances(forSource sInstance: NSManagedObject, in mapping: NSEntityMapping, manager: NSMigrationManager) throws {\n        let notaOrigen = sInstance as! Nota\n        let notaDestino = NSEntityDescription.insertNewObject(forEntityName: \"Nota\", into: manager.destinationContext) as! Nota\n        //copiar propiedades b\u00e1sicas\n        notaDestino.contenido = notaOrigen.contenido\n        notaDestino.fecha = notaOrigen.fecha\n        notaDestino.etiquetas = notaOrigen.etiquetas\n        //si la nota tiene una categor\u00eda\n        if let nombreCategoria = notaOrigen.categoria {\n           //miramos si la categor\u00eda ya existe como entidad\n           var categoria = categorias[nombreCategoria]\n           //si no existe, creamos la instancia de la entidad\n           if categoria==nil {\n              categoria = NSEntityDescription.insertNewObject(forEntityName: \"Categoria\", into: manager.destinationContext)\n              categoria?.setValue(nombreCategoria, forKey: \"nombre\")\n              categorias[nombreCategoria] = categoria\n           }\n           //asociamos la entidad nota con la entidad categor\u00eda\n           //como es una relaci\u00f3n 1-&gt;N es un conjunto por ahora de un \u00fanico elemento\n           var catsDeNota = Set&lt;NSManagedObject&gt;()\n           catsDeNota.insert(categoria!)\n           notaDestino.setValue(catsDeNota, forKey: \"categorias\")\n        }\n        //Al final siempre hay que llamar a este m\u00e9todo para establecer una correspondencia\n        //entre entidad en el modelo actual y entidad en el nuevo\n        manager.associate(sourceInstance: notaOrigen, withDestinationInstance: notaDestino, for: mapping)      \n    }\n}\n</code></pre> <p>Lo \u00fanico que nos falta es configurar el persistent store coordinator para especificar que necesitamos una migraci\u00f3n \u201cpesada\u201d. Tendremos que modificar el c\u00f3digo de inicializaci\u00f3n del stack de Core Data que se crea en la plantilla de Xcode al marcar <code>Use Core Data</code>: en el caso de estar usando la plantilla para iOS10 tendremos que modificar el c\u00f3digo como sigue:</p> <pre><code>//En el AppDelegate\n//Esta l\u00ednea queda tal cual, las modificaciones vienen a partir de ella\n//CUIDADO: el name cambia, seg\u00fan el nombre del proyecto\nlet container = NSPersistentContainer(name: \"PruebaMigraciones\")\n\nlet urls = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask)\n//CUIDADO: la cadena cambia, seg\u00fan el nombre del proyecto\nlet urlBD = urls[0].appendingPathComponent(\"PruebaMigraciones.sqlite\")\nlet psd = NSPersistentStoreDescription(url: urlBD)\n//que no se intente automatizar la migraci\u00f3n\npsd.shouldInferMappingModelAutomatically = false\npsd.type = NSSQLiteStoreType\n\ncontainer.persistentStoreDescriptions = [psd]\n</code></pre> <p>Y ya est\u00e1. Solo nos falta en el editor del modelo de datos establecer como versi\u00f3n actual del modelo de datos la nueva versi\u00f3n</p> <p></p> <p>Cuando arranque la aplicaci\u00f3n iOS detectar\u00e1 que el modelo de datos actual es incompatible con el almac\u00e9n persistente y ver\u00e1 que en las opciones se especifica que no se debe inferir autom\u00e1ticamente el \u201cmapping model\u201d. Por tanto buscar\u00e1 un \u201cmapping model\u201d compatible con la versi\u00f3n origen y destino del modelo de datos y lo aplicar\u00e1.</p>"},{"location":"cap8/5_ejercicios/","title":"Ejercicio de migraciones de datos (0,5 puntos)","text":"<p>Vamos a hacer un par de modificaciones sobre el modelo de datos de (\u00a1c\u00f3mo no!) la aplicaci\u00f3n de notas</p> <ul> <li>Ve al modelo de datos y crea una nueva versi\u00f3n con <code>Editor &gt; Add model version...</code>. Ponle el nombre que quieras.</li> <li>Edita esta nueva versi\u00f3n y en ella cambia de nombre el campo \u201ctexto\u201d por \u201ccontenido\u201d. </li> <li>Tendr\u00e1s que indicar que esto es un cambio de nombre y no un campo nuevo. Selecciona el atributo y en sus propiedades en el panel de la derecha pon el nombre antiguo como <code>renaming ID</code>. </li> </ul> <p></p> <ul> <li>Fija la nueva versi\u00f3n del modelo como la versi\u00f3n actual: <ul> <li>Estando editando el <code>xcdatamodeld</code>, selecciona el <code>File Inspector</code> en el panel de la derecha (primero de los iconos, 1\ufe0f\u20e3 en la siguiente figura)</li> <li>Al final del panel de la derecha cambia la versi\u00f3n del modelo de datos a la nueva que has creado, en el desplegable de la secci\u00f3n <code>Model Version</code> (2\ufe0f\u20e3 en la figura)</li> </ul> </li> </ul> <p></p> <ul> <li>Tendr\u00e1s que modificar tambi\u00e9n el c\u00f3digo fuente. Donde salga alguna referencia a la propiedad <code>texto</code> de la entidad <code>Nota</code>:<ol> <li>Selecciona la propiedad</li> <li>Pulsa bot\u00f3n derecho del rat\u00f3n</li> <li>En el men\u00fa flotante, selecciona <code>Refactor &gt; Rename...</code></li> <li>Xcode deber\u00eda detectar y mostrar todas las referencias a la misma propiedad en el archivo que est\u00e1s editando y en el resto de archivos. Si pulsas sobre el bot\u00f3n azul <code>Rename</code> se har\u00e1 el cambio en todos ellos.</li> </ol> </li> </ul> <p>Ejecuta la aplicaci\u00f3n y comprueba que todo sigue funcionando. Si accedes a la carpeta con la base de datos podr\u00e1s comprobar que en la tabla <code>ZNOTA</code> se ha cambiado la columna <code>texto</code> por <code>contenido</code></p>"},{"location":"cap8/apendice_migraciones_ios9/","title":"Apendice migraciones ios9","text":"<p>Como vimos en la primera sesi\u00f3n de Core Data, el stack se gestiona con la clase <code>NSPersistentContainer</code>. Esta clase tiene activadas por defecto las migraciones autom\u00e1ticas, y por eso en iOS10 podemos hacer modificaciones al modelo de datos sin causar errores en tiempo de ejecuci\u00f3n. No obstante esta clase es nueva de la versi\u00f3n 10. \u00bfQu\u00e9 ocurre si necesitamos generar c\u00f3digo compatible con versiones anteriores, o tenemos un proyecto \"heredado\" de esas versiones?.</p> <p>Las clases que gestionan el stack de Core Data en iOS9 y versiones anteriores no tienen activadas las migraciones por defecto, y si en el proceso de desarrollo modificamos el modelo de datos nos encontraremos con que al ejecutar la aplicaci\u00f3n se genera un mensaje de error:</p> <pre><code>The model used to open the store is incompatible with the one used to create the store\n</code></pre> <p>Para activar las migraciones autom\u00e1ticas en iOS&lt;=9 tenemos que pasarle un par\u00e1metro adicional al persistent store coordinator cuando vamos a\u00f1adiendo almacenamientos persistentes. Las opciones que indican si hay que intentar la migraci\u00f3n autom\u00e1tica van asociadas a la configuraci\u00f3n del almacenamiento persistente. En concreto, en la plantilla que generan las versiones de Xcode anteriores a la 8 hay que hacer el siguiente cambio:</p> <pre><code>//ESTO SE A\u00d1ADE\nlet opciones = [\n      NSInferMappingModelAutomaticallyOption : true,\n      NSMigratePersistentStoresAutomaticallyOption : true\n]\n//ESTO YA ESTABA, pero antes con el options a nil\ndo {\n    try coordinator.addPersistentStore(ofType: NSSQLiteStoreType, configurationName: nil, at: url, options: opciones)\n} catch {\n</code></pre> <ul> <li><code>NSInferMappingModelAutomaticallyOption</code> indica que Core Data intente inferir el mapping model autom\u00e1ticamente. Esto es necesario para las migraciones ligeras, pero para las \"pesadas\" habr\u00e1 que ponerlo a <code>false</code>, para que tome el modelo que nosotros le damos.</li> <li><code>NSMigratePersistentStoresAutomaticallyOption</code> indica que se debe intentar hacer la migraci\u00f3n. Cuando este valor est\u00e1 a <code>false</code> es cuando al detectar un cambio en el modelo de datos se genera un error en tiempo de ejecuci\u00f3n.</li> </ul>"},{"location":"cap8/intro/","title":"Intro","text":""},{"location":"cap8/intro/#introduccion","title":"Introducci\u00f3n","text":"<p>En esta sesi\u00f3n veremos c\u00f3mo podemos ir cambiando el modelo de datos sin perder los datos que ya tenemos almacenados. Para esto habr\u00e1 que \"exportarlos\" al nuevo formato. Veremos que en la mayor\u00eda de los casos Core Data puede hacer este cambio de formato de modo autom\u00e1tico pero en ciertos casos m\u00e1s complicados vamos a tener que escribir nosotros c\u00f3digo para hacer la transformaci\u00f3n.</p>"},{"location":"cap8/restos/","title":"Restos","text":""},{"location":"cap8/restos/#apendice-migraciones-ligeras-en-ios10","title":"Ap\u00e9ndice: migraciones ligeras en iOS&lt;10","text":"<p>Hay una serie de migraciones que Core Data puede hacer de forma m\u00e1s o menos autom\u00e1tica. Por ejemplo al a\u00f1adir un atributo se a\u00f1adir\u00e1 la nueva columna y simplemente los datos antiguos tendr\u00e1n valor <code>nil</code> para la propiedad. O al cambiar una entidad de nombre se cambiar\u00e1 autom\u00e1ticamente el nombre de la tabla en la base de datos.</p> <p><code>The model used to open the store is incompatible with the one used to create the store.</code></p> <p>Este error es f\u00e1cilmente subsanable yendo al directorio <code>Documents</code> de la aplicaci\u00f3n y eliminando los ficheros del almacenamiento persistente (si es una BD SQLite, desde iOS7 hay 3 ficheros, un <code>.sqlite</code>, un <code>.sqlite-wal</code> y un <code>.sqlite-shm</code>). Si volvemos a arrancar la aplicaci\u00f3n ya no habr\u00e1 problema ya que no hay almacenamiento persistente y Core Data lo puede generar partiendo de cero. Pero evidentemente esto implica perder todos los datos que ten\u00edamos guardados. </p> <p>En desarrollo perder los datos no tiene la menor importancia si tenemos el t\u00edpico c\u00f3digo de prueba que podemos volver a ejecutar para rellenar la BD. Pero si ya hemos distribuido la aplicaci\u00f3n en la App Store y sacamos una nueva versi\u00f3n con el modelo de datos modificado, en principio todos los usuarios tendr\u00edan que borrar todos los datos para que les funcionara la nueva versi\u00f3n (!). Evidentemente esto no tiene sentido, tiene que haber alguna forma de que el modelo de datos pueda ir cambiando y los datos se vayan traspasando de una versi\u00f3n a otra. Este \u201ctraspaso\u201d de los datos es lo que se conoce como una migraci\u00f3n.</p>"},{"location":"cap8/restos/#versiones-del-modelo-de-datos","title":"Versiones del modelo de datos","text":""},{"location":"cap8/restos/#migraciones-ligeras","title":"Migraciones \u201cligeras\u201d","text":"<p>Las buenas noticias son que si los cambios en el modelo de datos no son demasiados, el propio Core Data puede hacer una migraci\u00f3n autom\u00e1tica, o como la llama Apple, \u201cligera\u201d (lightweight migration).</p> <p>Este tipo de migraci\u00f3n se corresponde con estas operaciones:</p> <ul> <li>A\u00f1adir o eliminar un atributo o relaci\u00f3n</li> <li>Convertir en opcional un atributo requerido</li> <li>Convertir en requerido un atributo opcional, siempre que se d\u00e9 un valor por defecto</li> <li>A\u00f1adir o eliminar una entidad</li> <li>Renombrar un atributo o relaci\u00f3n</li> <li>Renombrar una entidad</li> </ul> <p>Si hemos hecho alguno/s de los cambios anteriores que no implican renombrado, la migraci\u00f3n ligera es especialmente sencilla. Lo \u00fanico que tenemos que hacer es modificar el c\u00f3digo de inicializaci\u00f3n del <code>NSPersistentStoreCoordinator</code>. En el <code>addPersistentStoreWithType</code> , hay que pasar un par de opciones en el  par\u00e1metro <code>options</code> que indican que queremos una migraci\u00f3n totalmente autom\u00e1tica:</p> <pre><code>NSDictionary *opts = @{\n      NSMigratePersistentStoresAutomaticallyOption: @YES,\n      NSInferMappingModelAutomaticallyOption: @YES\n};\n[persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType\nconfiguration:nil URL:storeURL \noptions:opts error:&amp;error]\n</code></pre> <p>Ahora cuando ejecutemos la aplicaci\u00f3n se detectar\u00e1 que la versi\u00f3n actual del modelo de datos es posterior a la que se us\u00f3 para generar la base de datos. En consecuencia, tal y como acabamos de configurar en el c\u00f3digo, los datos se migrar\u00e1n autom\u00e1ticamente a la nueva versi\u00f3n de la BD.</p> <p>Si renombramos algo el proceso es solo un poco m\u00e1s laborioso. Por ejemplo supongamos que en la aplicaci\u00f3n de notas cambiamos el atributo <code>fecha</code>por <code>momento</code>. Habiendo cambiado el nombre, mantenemos seleccionado el atributo y en el panel de la derecha, tercer icono (Data Model Inspector), en el cuadro de texto llamado <code>Renaming ID</code> tecleamos el nombre antiguo. Con esto estamos especificando lo que en Core Data se llama un mapping model, es decir una asociaci\u00f3n de elementos que permite pasar del modelo antiguo al nuevo.</p> <p></p> <p>Por supuesto, todos los lugares del c\u00f3digo donde antes se hiciera referencia al atributo <code>fecha</code> ahora habr\u00e1 que cambiarlos para que reflejen el nuevo nombre. Core Data no va a ayudarnos en esto. </p>"},{"location":"cap8/restos/#migraciones-pesadas","title":"Migraciones \u201cpesadas\u201d","text":"<p>Puede haber cambios que no encajen en las operaciones previstas en las migraciones \u201cligeras\u201d. Por ejemplo supongamos que queremos dividir un campo <code>apellidos</code> en <code>apellido1</code>y <code>apellido2</code> (o al contrario, partimos de dos y los queremos fusionar). En estos casos Core Data no puede inferir autom\u00e1ticamente la forma de transformar el modelo origen al modelo objetivo, y tenemos que especificar \u201cmanualmente\u201d c\u00f3mo hacer la transformaci\u00f3n.</p> <p>La transformaci\u00f3n entre un modelo y otro se representa en iOS mediante un mapping model, y es lo que tenemos que proporcionarle a Core Data para que pueda actualizar los datos al nuevo modelo.</p> <p>Lo que har\u00e1 Core Data durante el proceso de migraci\u00f3n es cargar cada entidad en memoria, convertirla del modelo actual al nuevo ayud\u00e1ndose del mapping model y guardarla de nuevo en el almacenamiento persistente. Y hemos dicho Core Data, pero en realidad lo que tendremos que hacer ser\u00e1 escribir nosotros c\u00f3digo que haga esta tarea. Adem\u00e1s del trabajo para nosotros, las migraciones de este tipo son mucho m\u00e1s costosas en tiempo y capacidad de procesamiento que las ligeras. Normalmente la aplicaci\u00f3n necesitar\u00e1 mostrar al usuario un cuadro de di\u00e1logo que le indique que se est\u00e1 realizando la operaci\u00f3n.</p> <p>Vamos a ver c\u00f3mo se implementar\u00eda una migraci\u00f3n \u201cpesada\u201d con un ejemplo concreto. Supongamos que en la aplicaci\u00f3n de notas nos hemos dado cuenta de que el campo \u201ccategoria\u201d no est\u00e1 del todo bien, ya que as\u00ed solo podemos hacer que una nota pertenezca a una \u00fanica categor\u00eda, y adem\u00e1s cuando varias notas tienen la misma categor\u00eda cada una debe repetir el valor. Ser\u00eda mejor tener una entidad \u201ccategor\u00eda\u201d aparte y establecer una relaci\u00f3n \u201cuno a muchos\u201d en ambas direcciones.</p> <p>Lo primero es crear una nueva versi\u00f3n del modelo de datos con este cambio.</p>"},{"location":"cap8/restos/#crear-el-mapping-model","title":"Crear el \u201cmapping model\u201d","text":"<p>El nuevo modelo de datos tendr\u00e1 el aspecto de la siguiente figura:</p> <p></p> <p>ahora tenemos que crear el mapping model que nos transforme el modelo actual en el nuevo modelo. En <code>File &gt; New</code> seleccionamos la categor\u00eda <code>Core Data</code> y elegimos la plantilla <code>Mapping Model</code>. El asistente nos preguntar\u00e1 cu\u00e1l es el modelo origen, cu\u00e1l el destino, y nos pedir\u00e1 un nombre para el nuevo archivo <code>.xcmappingmodel</code> que crear\u00e1.</p> <p>Si abrimos el archivo creado, veremos que Xcode ha intentado deducir la correspondencia entre el modelo origen y el destino. </p> <p></p> <p>A la izquierda veremos los Entity Mappings (c\u00f3mo pasar de una entidad antigua a una nueva). T\u00edpicamente a estos los llama con el nombre de la entidad antigua y la nueva, algo como <code>NotaToNota</code>. Para las entidades nuevas pone simplemente el nombre de la entidad. </p> <p>Para cada Entity Mapping tenemos los Attribute Mappings y los Relationship mappings correspondientes. Se usa un conjunto de variables predefinido para expresarlos. Por ejemplo, <code>$source</code> indica la entidad origen. De modo que si en un atributo vemos <code>$source.texto</code> indica que Xcode ha deducido que para generar este atributo tenemos que copiar el valor del atributo <code>texto</code> de la entidad original. Para una lista de variables se recomienda consultar la secci\u00f3n correspondiente de la \u201cCore Data Model Versioning and Data Migration Programming Guide\u201d.</p>"},{"location":"cap8/restos/#crear-la-migration-policy","title":"Crear la \u201cmigration policy\u201d","text":"<p>De la migraci\u00f3n entre entidades del modelo \u201cantiguo\u201d y del \u201cnuevo\u201d se encarga la clase <code>NSEntityMigrationPolicy</code>. Si queremos personalizar la migraci\u00f3n, como es nuestro caso para generar la nueva entidad <code>Categoria</code> a partir de los valores del antiguo atributo <code>categoria</code>, tendremos que crear una clase propia que herede de ella:</p> <p></p> <p>Tendremos tambi\u00e9n que especificar en el Mapping Model que vamos a usar esta clase para hacer una migraci\u00f3n de entidad determinada. Seleccionamos la migraci\u00f3n <code>NotaToNota</code> y en las propiedades escribimos el nombre de la nueva clase en el campo <code>Custom Policy</code>.</p> <p></p> <p>En la clase hay una serie de m\u00e9todos que podemos sobreescribir para adaptar la migraci\u00f3n a nuestras necesidades, pero el \u00fanico que suele ser necesario es <code>createDestinationInstancesForSourceInstance:entityMapping:manager:error:</code>, que se encargar\u00eda de crear a partir de una instancia de la antigua entidad, la nueva entidad (o nuevas, si debe haber m\u00e1s de una). Este m\u00e9todo se ir\u00e1 llamando para cada una de las entidades actualmente en el almac\u00e9n persistente, para irlas migrando una a una. </p> <p>Para nuestro problema particular, lo que debemos hacer en este m\u00e9todo es obtener la categor\u00eda a la que pertenece la nota y crear una nueva entidad <code>Categoria</code> basada en ella. Despu\u00e9s establecemos la relaci\u00f3n entre la nota y su por ahora \u00fanica categor\u00eda. Hay un peque\u00f1o problema a tener en cuenta: como habr\u00e1 varias notas de la misma categor\u00eda no podemos crear directamente la entidad <code>Categoria</code>, solo la crearemos si no existe ya. Vamos a guardar las <code>Categoria</code> que creamos en un <code>NSMutableDictionary</code> para poder saber las que ya hemos creado. En nuestra clase definir\u00edamos una variable <code>static</code>:</p> <pre><code>static NSMutableDictionary *categorias;\n</code></pre> <p>y para inicializarla usaremos el m\u00e9todo <code>initialize</code>, que se llama cuando se inicializa la clase propiamente dicha, antes de que exista todav\u00eda ninguna instancia de ella, momento apropiado para inicializar variables <code>static</code>:</p> <pre><code>+ (void)initialize {\n    categorias = [[NSMutableDictionary alloc] init];\n}\n</code></pre> <p>Finalmente aqu\u00ed tenemos el c\u00f3digo que hace la migraci\u00f3n en s\u00ed</p> <pre><code>- (BOOL) createDestinationInstancesForSourceInstance:(NSManagedObject *)sInstance entityMapping:(NSEntityMapping *)mapping manager:(NSMigrationManager *)manager error:(NSError *__autoreleasing *)error {\n\n    //Crea una nueva nota en el \"nuevo modelo\" con las mismas propiedades que la nota actual\n    NSManagedObject *notaDestino = [NSEntityDescription insertNewObjectForEntityForName:@\"Nota\" inManagedObjectContext:manager.destinationContext];\n    [notaDestino setValue:[sInstance valueForKey:@\"texto\"] forKey:@\"texto\"];\n    [notaDestino setValue:[sInstance valueForKey:@\"momento\"] forKey:@\"momento\"];\n\n    //Miramos si ya hemos creado una entidad Categoria para la categoria de la nota\n    NSString *nombreCategoria = [sInstance valueForKey:@\"categoria\"];\n    NSManagedObject *categoria = [categorias objectForKey:nombreCategoria];\n\n    //Si no la hemos encontrado, la creamos\n    if (!categoria) {\n        categoria = [NSEntityDescription insertNewObjectForEntityForName:@\"Categoria\" inManagedObjectContext:manager.destinationContext];\n        [categoria setValue:nombreCategoria forKey:@\"nombre\"];\n        [categorias setObject:categoria forKey:nombreCategoria];\n    }\n\n    //Asociamos la nota con su por ahora \u00fanica categor\u00eda\n    //Como es una relaci\u00f3n 1-&gt;N es un NSSet que por ahora tendr\u00e1 un \u00fanico elemento\n    NSSet *categoriasDeNota = [[NSSet alloc]initWithObjects:categoria, nil];\n    [notaDestino setValue:categoriasDeNota forKey:@\"categorias\"];\n\n\n    //Al final siempre hay que llamar a este m\u00e9todo para establecer correspondencia\n    //entre entidad en el modelo actual y entidad en el nuevo\n    [manager associateSourceInstance:sInstance withDestinationInstance:notaDestino forEntityMapping:mapping];\n\n\n    return YES;\n\n}\n</code></pre> <p>Lo \u00fanico que nos falta es configurar el persistent store coordinator para especificar que necesitamos una migraci\u00f3n \u201cpesada\u201d. Al igual que en el caso de las migraciones \u201cligeras\u201d, esto se hace con un diccionario de opciones. La diferencia es que en este caso indicamos que no se intente inferir autom\u00e1ticamente el \u201cmapping model\u201d</p> <pre><code>NSDictionary *opts = @{\n      NSMigratePersistentStoresAutomaticallyOption: @YES,\n      NSInferMappingModelAutomaticallyOption: @NO\n};\n</code></pre> <p>Y ya est\u00e1. Solo nos falta en el editor del modelo de datos establecer como versi\u00f3n actual del modelo de datos la nueva versi\u00f3n</p> <p></p> <p>Cuando arranque la aplicaci\u00f3n iOS detectar\u00e1 que el modelo de datos actual es incompatible con el almac\u00e9n persistente y ver\u00e1 que en las opciones se especifica que no se debe inferir autom\u00e1ticamente el \u201cmapping model\u201d. Por tanto buscar\u00e1 un \u201cmapping model\u201d compatible con la versi\u00f3n origen y destino del modelo de datos y lo aplicar\u00e1.</p>"},{"location":"cap9/1_background/","title":"M\u00faltiples contextos para trabajos en background","text":"<p>Algunas operaciones con Core Data pueden ser bastante costosas en tiempo: por ejemplo una b\u00fasqueda en una base de datos con muchos registros, o la sincronizaci\u00f3n de los datos con un servicio web. Si efectuamos la operaci\u00f3n en el hilo principal de la aplicaci\u00f3n, donde trabajamos normalmente, la interfaz de usuario se quedar\u00e1 paralizada durante ese tiempo y la aplicaci\u00f3n no responder\u00e1 a los eventos, ya que la interfaz corre en ese hilo.</p> <p>En la asignatura de introducci\u00f3n a iOS y a Swift ya vimos una soluci\u00f3n a ese problema: las colas de operaciones, que b\u00e1sicamente son una forma de crear y gestionar operaciones concurrentes mucho m\u00e1s sencilla para el desarrollador que trabajar directamente con el API de threads. Por desgracia, los <code>NSManagedObjects</code> no son thread-safe, es decir, no se asegura que no se vayan a dar inconsistencias y problemas al acceder a un <code>NSManagedObject</code> desde distintos hilos. As\u00ed que en principio esta soluci\u00f3n no es directamente aplicable.</p> <p>Sin embargo, hay otra posibilidad que s\u00ed nos permitir\u00eda usar varios hilos: tener varios contextos de persistencia, cada uno en un hilo distinto. Un <code>NSManagedObject</code> pertenece solo a un contexto de persistencia, as\u00ed que no habr\u00e1 ning\u00fan problema si siempre para acceder a \u00e9l usamos el thread asociado a su contexto. </p> <p>Lo \u00fanico que necesitamos para solucionar el problema de las operaciones que bloquean la interfaz es un contexto adicional que funcione en un hilo secundario, y realizar la operaci\u00f3n costosa con Core Data en este hilo. </p> <p>El contexto que crea el stack de Core Data por defecto est\u00e1 asociado al hilo principal de la aplicaci\u00f3n, as\u00ed que ese no nos sirve. En iOS el API para crear un nuevo contexto asociado a otro hilo es bastante sencillo, pero con la introducci\u00f3n del <code>NSPersistentContainer</code> en iOS10 ni siquiera es necesario que creemos nosotros mismos el contexto, el container lo hace por nosotros. Todo lo que tenemos que hacer es pasarle al m\u00e9todo <code>performBackgroundTask()</code> el c\u00f3digo a ejecutar en background en forma de clausura:</p> <pre><code>let miDelegate = UIApplication.shared.delegate as! AppDelegate\nmiDelegate.persistentContainer.performBackgroundTask() {\n   contextoBG in\n    let request = NSFetchRequest&lt;Nota&gt;(entityName: \"Nota\")  \n    let lista = try! contextoBG.fetch(request)\n    for nota in lista {\n        //Aqu\u00ed hacemos una operaci\u00f3n costosa, como exportar cada nota a PDF\n        //o subirlas a un servidor\n    }\n}\n</code></pre> <p>La clausura que se le pasa a <code>performBackgroundTask</code> tiene como par\u00e1metro el contexto de persistencia \"secundario\", creado por el <code>persistentContainer</code>. Este contexto se nos asegura que est\u00e1 asociado a una cola de operaciones distinta a la principal. Es decir, se estar\u00eda creando el stack que se muestra en parte en la siguiente figura.</p> <p></p> <p>En lugar de ejecutar directamente la operaci\u00f3n tambi\u00e9n podemos pedirle al container que cree el contexto \"secundario\", para hacer luego lo que queramos (ejecutar varias operaciones en distintos momentos, por ejemplo) </p> <pre><code>let miDelegate = UIApplication.shared.delegate as! AppDelegate\nlet contextoBG = miDelegate.persistentContainer.newBackgroundContext()\n</code></pre> <p>En versiones anteriores de iOS era necesario crear el contexto directamente (un objeto de la clase <code>NSManagedObjectContext</code>) y en el inicializador indicar que quer\u00edamos asociarlo a una cola de operaciones que no fuera la principal. Una vez creado el contexto, con los m\u00e9todos <code>perform</code> o <code>performAndWait</code> podemos ejecutar una operaci\u00f3n en su cola asociada. El primero es as\u00edncrono y el segundo s\u00edncrono, como su propio nombre indica.</p> <pre><code>let nuevoContexto = NSManagedObjectContext(concurrencyType:.privateQueueConcurrencyType)\n...\nnuevoContexto.perform() {\n   //Aqu\u00ed vendr\u00eda la operaci\u00f3n costosa\n   ...\n}\n</code></pre> <p>Crear el contexto tal cual se ha visto en este \u00faltimo ejemplo no tiene sentido de manera aislada. Para que funcione, el contexto de persistencia tiene que estar conectado a otras \"piezas\" del stack de Core Data, t\u00edpicamente a un <code>NSPersistentStoreCoordinator</code>. Omitiremos esa parte para simplificar, pero para ello podr\u00edas adaptar el c\u00f3digo generado por Xcode en versiones anteriores a la 8 que se vio en la primera sesi\u00f3n de Core Data.</p>"},{"location":"cap9/2_background/","title":"2 background","text":""},{"location":"cap9/2_background/#multiples-contextos-para-trabajos-en-background","title":"M\u00faltiples contextos para trabajos en background","text":"<p>Algunas operaciones con Core Data pueden ser bastante costosas en tiempo: por ejemplo una b\u00fasqueda en una base de datos con muchos registros, o la sincronizaci\u00f3n de los datos con un servicio web. Si efectuamos la operaci\u00f3n en el hilo principal de la aplicaci\u00f3n, donde trabajamos normalmente, la interfaz de usuario se quedar\u00e1 paralizada durante ese tiempo y la aplicaci\u00f3n no responder\u00e1 a los eventos, ya que la interfaz corre en ese hilo.</p> <p>En la asignatura de introducci\u00f3n a iOS y a Swift ya vimos una soluci\u00f3n a ese problema: las colas de operaciones, que b\u00e1sicamente son una forma de crear y gestionar operaciones concurrentes mucho m\u00e1s sencilla para el desarrollador que trabajar directamente con el API de threads. Por desgracia, los <code>NSManagedObjects</code> no son thread-safe, es decir, no se asegura que no se vayan a dar inconsistencias y problemas al acceder a un <code>NSManagedObject</code> desde distintos hilos. As\u00ed que en principio esta soluci\u00f3n no es directamente aplicable.</p> <p>Sin embargo, hay otra posibilidad que s\u00ed nos permitir\u00eda usar varios hilos: tener varios contextos de persistencia, cada uno en un hilo distinto. Un <code>NSManagedObject</code> pertenece solo a un contexto de persistencia, as\u00ed que no habr\u00e1 ning\u00fan problema si siempre para acceder a \u00e9l usamos el thread asociado a su contexto. </p> <p></p> <p>Lo \u00fanico que necesitamos para solucionar el problema de las operaciones que bloquean la interfaz es un contexto adicional que funcione en un hilo secundario, y realizar la operaci\u00f3n costosa con Core Data en este hilo. </p> <p>El contexto que crea el stack de Core Data por defecto est\u00e1 asociado al hilo principal de la aplicaci\u00f3n, as\u00ed que ese no nos sirve. En iOS el API para crear un nuevo contexto asociado a otro hilo es bastante sencillo, pero con la introducci\u00f3n del <code>NSPersistentContainer</code> en iOS10 ni siquiera es necesario que creemos nosotros mismos el contexto, el container lo hace por nosotros. Todo lo que tenemos que hacer es pasarle al m\u00e9todo <code>performBackgroundTask()</code> el c\u00f3digo a ejecutar en background en forma de clausura:</p> <pre><code>let miDelegate = UIApplication.shared.delegate as! AppDelegate\nmiDelegate.persistentContainer.performBackgroundTask() {\n   contextoBG in\n    let request = NSFetchRequest&lt;Nota&gt;(entityName: \"Nota\")  \n    let lista = try! contextoBG.fetch(request)\n    for nota in lista {\n        //Aqu\u00ed hacemos una operaci\u00f3n costosa, como exportar cada nota a PDF\n        //o subirlas a un servidor\n    }\n}\n</code></pre> <p>La clausura que se le pasa a <code>performBackgroundTask</code> tiene como par\u00e1metro el contexto de persistencia \"secundario\", creado por el <code>persistentContainer</code>. Este contexto se nos asegura que est\u00e1 asociado a una cola de operaciones distinta a la principal.</p> <p>En lugar de ejecutar directamente la operaci\u00f3n tambi\u00e9n podemos pedirle directamente al container que cree un nuevo contexto asociado a una cola en background. En iOS10 es sencillo:</p> <pre><code>let miDelegate = UIApplication.shared.delegate as! AppDelegate\nlet contextoBG = miDelegate.persistentContainer.newBackgroundContext()\n</code></pre> <p>En versiones anteriores de iOS era necesario crear el contexto directamente (un objeto de la clase <code>NSManagedObjectContext</code>) y en el inicializador indicar que quer\u00edamos asociarlo a una cola de operaciones que no fuera la principal. Una vez creado el contexto, con el m\u00e9todo <code>perform</code> (antes <code>performBlock</code>) podemos ejecutar una operaci\u00f3n en su cola asociada. Dicho m\u00e9todo admite como par\u00e1metro una funci\u00f3n o clausura con el c\u00f3digo a ejecutar.</p> <pre><code>let nuevoContexto = NSManagedObjectContext(concurrencyType:.privateQueueConcurrencyType)\n...\nnuevoContexto.perform() {\n   //Aqu\u00ed vendr\u00eda la operaci\u00f3n costosa\n   ...\n}\n</code></pre> <p><code>perform</code> es as\u00edncrono. La versi\u00f3n s\u00edncrona es <code>performAndWait</code></p> <p>Crear el contexto tal cual se ha visto en este \u00faltimo ejemplo no tiene sentido de manera aislada. Para que funcione, el contexto de persistencia tiene que estar conectado a otras \"piezas\" del stack de Core Data, t\u00edpicamente a un <code>NSPersistentStoreCoordinator</code>. Omitiremos esa parte para simplificar, pero para ello podr\u00edas adaptar el c\u00f3digo generado por Xcode en versiones anteriores a la 8 que se vio en la primera sesi\u00f3n de Core Data.</p>"},{"location":"cap9/2_comunicacion/","title":"Comunicaci\u00f3n entre contextos","text":"<p>En la secci\u00f3n anterior hemos visto un ejemplo que implicaba una operaci\u00f3n costosa con objetos gestionados, pero esos objetos gestionados se \"quedaban dentro\" del contexto secundario. Las notas que se recuperaban con la fetch request no se usaban en la cola de operaciones principal, se manejaban solo dentro de la otra cola.</p> <p>Supongamos ahora un caso distinto: una b\u00fasqueda muy costosa, que queremos hacer tambi\u00e9n en background para no bloquear mientras tanto la interfaz de usuario, pero cuyos resultados evidentemente queremos mostrar en pantalla, y posiblemente editar o borrar. \u00bfQu\u00e9 problema tenemos aqu\u00ed? que los resultados de la b\u00fasqueda son <code>NSManagedObjects</code> asociados a un contexto distinto al \"principal\", y las otras operaciones las estar\u00edamos realizando en el contexto \"principal\". Con un <code>NSManagedObject</code> solo se puede operar desde el contexto al que pertenece. N\u00f3tese que todas las operaciones del ciclo de vida (<code>insertNewObject</code>, <code>fetch</code>, <code>save</code>, <code>delete</code>), siempre llevan como par\u00e1metro el contexto o directamente se ejecutan sobre el contexto. As\u00ed que no podemos simplemente pasarnos el objeto entre contextos. \u00bfC\u00f3mo podemos resolver esto?.</p> <p>Una forma es usando un identificador \u00fanico que tienen todos los objetos gestionados, que es accesible a trav\u00e9s de la propiedad <code>objectID</code>. Es muy sencillo obtener un objeto a partir de su <code>ID</code> con el m\u00e9todo <code>objectWithID</code> del contexto. Lo interesante es que el <code>ID</code> de un objeto gestionado es el mismo para todos los contextos. La idea entonces ser\u00eda hacer una fetch request en el hilo secundario y \"devolver\" una lista de <code>ID</code>. Desde el contexto principal se \"re-materializar\u00edan\" los objetos gestionados a partir de su <code>ID</code>, pero ahora asociados al contexto \"correcto\".</p> <p>Supongamos otro ejemplo distinto, en el que estar\u00edamos sincronizando los datos con un servicio web, pero no solo enviando datos, sino tambi\u00e9n recibiendo, es decir, modificando objetos persistentes en background. Si los objetos se estuvieran visualizando en el hilo principal necesitar\u00edamos actualizarlos. Por tanto tendr\u00edamos que hacer que el contexto principal se sincronizara con el secundario, no obtener una lista de resultados como en el caso de antes, sino ahora refrescar los datos. Una forma de hacer esto es gracias a las notificaciones que se generan cuando se guarda un objeto gestionado, y que ya comentamos. Afortunadamente, tambi\u00e9n se pueden \"escuchar\" las notificaciones que se emiten desde otro contexto de persistencia. Y tambi\u00e9n afortunadamente hay un m\u00e9todo que \"sincroniza\" un objeto por nosotros, a partir de la notificaci\u00f3n emitida por el objeto que se ha guardado: <code>mergeChanges(fromContextDidSave:)</code></p> <pre><code>let miDelegate = UIApplication.shared.delegate as! AppDelegate\n//El contexto principal, como hasta ahora\nlet miContexto = miDelegate.persistentContainer.viewContext\n//Un contexto secundario\nlet contextoBg = miDelegate.persistentContainer.newBackgroundContext()\n//El \"notification center\" de la aplicaci\u00f3n\nlet nc = NotificationCenter.default\n//Cuando el contextoBg emita una notificaci\u00f3n de este tipo, ejecutamos el c\u00f3digo\nnc.addObserver(forName: .NSManagedObjectContextDidSave,\n               object: contextoBg,\n               queue: nil) {\n     notificacion in\n       miContexto.mergeChanges(fromContextDidSave: notificacion)\n}\n</code></pre>"},{"location":"cap9/3_contextos_anidados/","title":"Contextos anidados","text":"<p>El contexto de persistencia est\u00e1 conectado con un Persistent Store Coordinator, cuyo trabajo, como su propio nombre indica, es el de gestionar el almacenamiento persistente. Cuando almacenamos un objeto haciendo <code>save</code> del contexto, es el store coordinator el que se encarga de \"pelearse\" con la base de datos SQLite (o con el almacenamiento que sea). Cuando tenemos varios contextos, t\u00edpicamente est\u00e1n todos \"conectados\" con el mismo coordinator. Este es el esquema m\u00e1s t\u00edpico en aplicaciones iOS.</p> <p>En iOS5 se introdujo la posibilidad de tener un contexto \"conectado\" con otro en lugar de con un coordinator. Esto se conoce tambi\u00e9n como contexto hijo. El hijo est\u00e1 \"conectado\" con el padre y el padre es el \"conectado\" al coordinator. Cuando desde el hijo se hace un <code>save</code> no se est\u00e1n guardando los datos en el almacenamiento persistente, sino en el contexto padre.  Los objetos guardados desde el contexto hijo son \"pendientes de guardar\" para el padre. Es decir, es una operaci\u00f3n puramente en memoria. Para guardarlos en el almacenamiento persistente el padre tambi\u00e9n tendr\u00eda que hacer <code>save</code>. </p> <p></p> <p>Cuando un contexto est\u00e1 \"conectado\" a un \"persistent store coordinator\" fijamos el valor de su propiedad <code>persistentStoreCoordinator</code>. Para indicar que est\u00e1 conectado a otro contexto \"padre\" fijamos el valor de <code>parent</code></p> <pre><code>let contextoPadre = NSManagedObjectContext(concurrencyType: .mainQueueConcurrencyType)\n//El padre est\u00e1 conectado a un \"persistent store coordinator\"\ncontextoPadre.persistentStoreCoordinator = ...\nlet contextoHijo = NSManagedObjectContext(concurrencyType: .mainQueueConcurrencyType)\n//El hijo est\u00e1 conectado al padre\ncontextoHijo.parent = contextoPadre\n</code></pre> <p>\u00bfPara qu\u00e9 sirve anidar contextos?. T\u00edpicamente se suelen describir dos casos de uso distintos: usar el contexto hijo como un \"borrador\" para realizar operaciones que podemos descartar en cualquier momento, y como una forma de hacer <code>save</code> en background.</p> <p>Veamos el primero de los usos. Pensemos en una aplicaci\u00f3n que tenga una pantalla de edici\u00f3n de datos que implique la creaci\u00f3n y relaci\u00f3n entre s\u00ed de varios objetos. Por ejemplo si estamos editando un pedido de una tienda online tendremos varias entidades implicadas como <code>Pedido</code>, <code>Item</code>, etc. Si en un momento dado el usuario se \"arrepiente\" de hacer el pedido y quiere cancelarlo debemos ser capaces de poder eliminar todas las entidades que hemos creado en el proceso, y los cambios que hayamos hecho en las existentes. Los contextos anidados nos dan la posibilidad de implementar esta funcionalidad de forma muy sencilla: lo \u00fanico que tenemos que hacer es crear todas estas entidades y hacer las modificaciones en un nuevo contexto hijo del principal. Para guardar los cambios que hagamos en ese contexto, haremos <code>save</code> en \u00e9l y luego tambi\u00e9n en el principal. Si por el contrario queremos anular lo hecho en el contexto hijo en realidad no hace falta hacer nada especial. Simplemente no nos molestamos en hacer el <code>save</code> del padre.</p> <p>En el segundo caso, queremos hacer un <code>save</code> de los datos en background. Lo  que tenemos que hacer es tener dos contextos en la aplicaci\u00f3n. El padre usar\u00e1 una cola de operaciones de tipo \"privado\" (es decir, distinta a la principal) mientras que el hijo usar\u00e1 la cola principal de operaciones. Cuando realicemos el <code>save</code> del hijo tendremos que hacer <code>save</code> tambi\u00e9n en el padre, pero el <code>save</code> del hijo no bloquear\u00e1 pr\u00e1cticamente la cola principal ya que se trata de una operaci\u00f3n en memoria. El <code>save</code> del padre ser\u00e1 m\u00e1s costoso en tiempo, pero no habr\u00e1 problema ya que lo har\u00e1 en background.</p>"},{"location":"cap9/4_contextos_anidados/","title":"4 contextos anidados","text":""},{"location":"cap9/4_contextos_anidados/#contextos-anidados","title":"Contextos anidados","text":"<p>El contexto de persistencia est\u00e1 conectado con un Persistent Store Coordinator, cuyo trabajo, como su propio nombre indica, es el de gestionar el almacenamiento persistente. Cuando almacenamos un objeto haciendo <code>save</code> del contexto, es el store coordinator el que se encarga de \"pelearse\" con la base de datos SQLite (o con el almacenamiento que sea). Cuando tenemos varios contextos, t\u00edpicamente est\u00e1n todos \"conectados\" con el mismo coordinator.</p> <p>En iOS5 se introdujo la posibilidad de tener un contexto \"conectado\" con otro en lugar de con un coordinator. Esto se conoce tambi\u00e9n como contexto hijo. El hijo est\u00e1 \"conectado\" con el padre y el padre es el \"conectado\" al coordinator. Cuando desde el hijo se hace un <code>save</code> no se est\u00e1n guardando los datos en el almacenamiento persistente, sino en el contexto padre. Es decir, los <code>save</code> del hijo representan modificaciones pendientes de almacenar para el padre. Para guardarlos en el almacenamiento persistente el padre tambi\u00e9n tendr\u00eda que hacer <code>save</code>. </p> <p></p> <p>N\u00f3tese que el <code>save</code> del hijo es una operaci\u00f3n puramente en memoria, lo que implica dos cosas: es r\u00e1pida y no es persistente. Precisamente estas dos caracter\u00edsticas van a ser las que nos dar\u00e1n dos casos de uso para esta funcionalidad.</p> <p>Vamos primero con el hecho de que el <code>save</code> del hijo no es una operaci\u00f3n persistente. \u00bfQu\u00e9 utilidad puede tener esto?. Pensemos en una aplicaci\u00f3n que tenga una pantalla de edici\u00f3n de datos que implique la creaci\u00f3n y relaci\u00f3n entre s\u00ed de varios objetos. Por ejemplo si estamos editando un pedido de una tienda online tendremos varias entidades implicadas como <code>Pedido</code>, <code>Item</code>, etc. Si en un momento dado el usuario se \"arrepiente\" de hacer el pedido y quiere cancelarlo debemos ser capaces de poder eliminar todas las entidades que hemos creado en el proceso, y los cambios que hayamos hecho en las existentes. Los contextos anidados nos dan la posibilidad de implementar esta funcionalidad de forma muy sencilla: lo \u00fanico que tenemos que hacer es crear todas estas entidades y hacer las modificaciones en un nuevo contexto hijo del principal. Para guardar los cambios que hagamos en ese contexto, haremos <code>save</code> en \u00e9l y luego tambi\u00e9n en el principal. Si por el contrario queremos anular lo hecho en el contexto hijo en realidad no hace falta hacer nada especial. Simplemente no nos molestamos en hacer el <code>save</code> del hijo y seguimos trabajando con el padre.</p> <p>Por otro lado podemos aprovechar que el <code>save</code> del padre es r\u00e1pido al ser solo en memoria para implementar una funcionalidad de \"guardar en background\" de un modo alternativo a como vimos en el primer apartado de la sesi\u00f3n. La idea es tener un contexto hijo que funcione en la cola principal y uno padre en una cola en background. Este \u00faltimo est\u00e1 conectado al persistent store coordinator. El hijo es el contexto \"principal\", en el que vamos a trabajar todo el rato. Cuando tengamos que hacer alguna operaci\u00f3n costosa de guardado de datos hacemos el <code>save</code> en el padre, que ser\u00e1 muy r\u00e1pido ya que es en memoria. El <code>save</code> del padre en el almacenamiento persistente ya no ser\u00e1 tan r\u00e1pido, pero al estar en una cola en background no va a afectar a la fluidez de la interfaz de usuario.</p>"},{"location":"cap9/4_ejercicios/","title":"Ejercicio","text":""},{"location":"cap9/4_ejercicios/#ejercicio-contextos-multiples-para-operaciones-en-background-1-punto","title":"Ejercicio: contextos m\u00faltiples para operaciones en background (1 punto)","text":"<p>En el moodle de la sesi\u00f3n hay un proyecto llamado <code>PruebaContextosMultiples</code> que servir\u00e1 como base para los ejercicios de la sesi\u00f3n. La aplicaci\u00f3n solo tiene una pantalla con un listado de notas (no se pueden crear ni modificar). Hay dos operaciones costosas: exportar las notas y refrescar el listado con datos que vengan del servidor. En ambos casos el coste es simulado ya que ni se exportan de verdad ni se actualizan desde ning\u00fan servidor (ejem). El coste se simula \"durmiendo\" al hilo actual con la instrucci\u00f3n <code>usleep</code>.</p> <p>Cuando la aplicaci\u00f3n se carga, si no hay datos autom\u00e1ticamente inserta 500 objetos en la base de datos.</p> <p>Pulsa sobre el bot\u00f3n de \"exportar\". Ver\u00e1s que la operaci\u00f3n tarda 2-3 segundos. Si intentas hacer scroll de la pantalla durante este tiempo no podr\u00e1s, ya que se queda bloqueada. Hay que solucionar esto.</p> <p>Ver\u00e1s que en el m\u00e9todo <code>botonExportarPulsado</code> del view controller se llama a un m\u00e9todo que (de modo simulado) exporta las notas y que es el \"culpable\" del bloqueo. El m\u00e9todo admite como par\u00e1metro el contexto de persistencia. Cambia el c\u00f3digo para que esta operaci\u00f3n se haga en un nuevo contexto en background. Recuerda que las operaciones de interfaz (como mostrar el alert tras la exportaci\u00f3n) deben hacerse en el thread principal y que este se puede obtener con <code>OperationQueue.main</code>.</p>"},{"location":"cap9/intro/","title":"Intro","text":"<p>Hasta ahora siempre hemos usado el stack de Core Data que Xcode crea para nosotros al crear un nuevo proyecto. Este stack es muy simple, pero podemos personalizarlo totalmente seg\u00fan las necesidades de nuestra aplicaci\u00f3n. La personalizaci\u00f3n m\u00e1s t\u00edpica en aplicaciones iOS es usar varios contextos de persistencia en lugar de uno solo. En esta sesi\u00f3n veremos por qu\u00e9 es necesario usar varios contextos cuando hagamos programaci\u00f3n concurrente y c\u00f3mo conectar y comunicar los contextos entre s\u00ed y con el resto de \"piezas\" del stack. </p>"},{"location":"miniproyecto/restaurante/","title":"Miniproyecto: app restaurante (2,5 puntos en total)","text":"<p>El objetivo es desarrollar una peque\u00f1a aplicaci\u00f3n para gestionar pedidos online a un restaurante. Para ello almacenaremos los datos de la carta y de los pedidos realizados por el usuario en Core Data.</p> <p>Desc\u00e1rgate la plantilla de la aplicaci\u00f3n desde moodle, aqu\u00ed est\u00e1 ya implementada la mayor parte de la interfaz.</p> <p>Inicialmente nos ocuparemos del modelo de datos y de leer los datos de los platos, que est\u00e1n almacenados en un JSON, y pasarlos a Core Data. Una vez hecho esto nos pondremos a implementar las funcionalidades de la aplicaci\u00f3n.</p>"},{"location":"miniproyecto/restaurante/#el-modelo-de-datos-05-puntos","title":"El modelo de datos (0,5 puntos)","text":"<p>En el proyecto abre el fichero <code>Restaurante.xcdatamodeld</code> y crea el siguiente modelo de datos</p> <p>Nuestro modelo de datos debe tener tres entidades, <code>Plato</code>, <code>Pedido</code> y <code>LineaPedido</code>. Esta \u00faltima es la que relaciona los platos con los pedidos,  guardando cu\u00e1ntas unidades de un plato se han incluido en un pedido. </p> <p>En la figura, las flechas dobles representan relaciones \"a muchos\" y las flechas simples \"a uno\"</p> <p></p> <p>Consejos</p> <ul> <li>Crea primero todas las entidades y despu\u00e9s las relaciones, si no no podr\u00e1s especificar la entidad destino de cada relaci\u00f3n</li> <li>Las relaciones por defecto se crean \"de uno a uno\" y sin orden, recuerda modificar esto en el panel derecho de Xcode si es necesario</li> </ul> <p>Cada entidad debe tener las siguientes propiedades y relaciones</p> <ul> <li><code>Plato</code>:<ul> <li>Propiedades:<ul> <li><code>nombre</code> de tipo <code>String</code></li> <li><code>descripcion</code> de tipo <code>String</code></li> <li><code>precio</code> de tipo <code>Double</code></li> <li><code>tipo</code> de tipo <code>String</code></li> </ul> </li> <li>Relaciones:<ul> <li><code>lineasPedido</code>, relaci\u00f3n \"a muchos\" con destino <code>LineaPedido</code>. La inversa es la relaci\u00f3n <code>plato</code></li> </ul> </li> </ul> </li> <li><code>Pedido</code>:<ul> <li>Propiedades:<ul> <li><code>direccion</code> de tipo <code>String</code></li> <li><code>fecha</code> de tipo <code>Date</code></li> <li><code>telefono</code> de tipo <code>String</code></li> </ul> </li> <li>Relaciones:<ul> <li><code>lineasPedido</code>, relaci\u00f3n \"a muchos\" con destino <code>LineaPedido</code>. La relaci\u00f3n debe ser ordenada, para poder mostrar las lineas de un pedido siempre en el mismo orden. La inversa es la relaci\u00f3n <code>pedido</code>. En la regla de borrado (<code>delete rule</code>) pon <code>Cascade</code> para que al eliminar un pedido se eliminen autom\u00e1ticamente sus l\u00edneas.</li> </ul> </li> </ul> </li> <li><code>LineaPedido</code>:<ul> <li>Propiedades<ul> <li><code>cantidad</code> de tipo <code>Integer 16</code></li> </ul> </li> <li>Relaciones<ul> <li><code>pedido</code>, relaci\u00f3n \"a uno\" con destino <code>Pedido</code>. La inversa es la relaci\u00f3n <code>lineasPedido</code></li> <li><code>plato</code>, relaci\u00f3n \"a uno\" con destino <code>Plato</code>. La inversa es la relaci\u00f3n <code>lineasPedido</code></li> </ul> </li> </ul> </li> </ul> <p>Simplificaciones</p> <p>Deber\u00edamos usar tipos <code>Decimal</code> en los precios para evitar errores de redondeo, pero usaremos <code>Double</code> por simplicidad, ya que <code>Decimal</code> no se acepta directamente en Core Data y tendr\u00edamos que usar un transformable. Adem\u00e1s, el tipo del plato deber\u00eda ser un enumerado, pero estos tampoco se pueden almacenar directamente en Core Data.</p>"},{"location":"miniproyecto/restaurante/#inicializar-los-datos-025-puntos","title":"Inicializar los datos (0,25 puntos)","text":"<p>Un problema habitual en Core Data es c\u00f3mo rellenar inicialmente la base de datos. Un enfoque muy habitual es incluir en el proyecto un archivo con los datos en alg\u00fan formato est\u00e1ndar (JSON, CSV, YAML,..) y copiarlos a Core Data la primera vez que se ejeuta la app. Es lo que haremos aqu\u00ed.</p> <p>Los datos de los platos del restaurante est\u00e1n en un archivo <code>platos.json</code>.  En el <code>AppDelegate</code> hay una funci\u00f3n <code>importPlatos</code> que lee el JSON, lo almacena en un array de <code>structs</code> de tipo <code>DatosPlato</code> con los datos correspondientes, y pone una preferencia de usuario llamada <code>platosImportados</code> a <code>true</code>. El JSON solo se lee si la preferencia est\u00e1 a <code>false</code> (valor por defecto)</p> <p>A\u00f1ade c\u00f3digo Swift que copie los datos de los structs <code>DatosPlato</code> a entidades <code>Plato</code> y guarde el contexto de persistencia para hacer efectivos los cambios. Tendr\u00e1s que introducir el c\u00f3digo en el <code>AppDelegate</code>, l\u00ednea 34, donde est\u00e1 el comentario de <code>//TODO: copiar los datos</code>. El array de structs de tipo <code>DatosPlato</code> se llama <code>datos</code>. Rec\u00f3rrelo y copia todos sus datos a Core Data. Las propiedades de <code>DatosPlato</code> tienen los mismos nombres y tipos que en la entidad <code>Plato</code>.</p> <p>Tras esto, con la ayuda de la aplicaci\u00f3n <code>SimSim</code> puedes echarle un vistazo a la base de datos de SQLite creada por Core Data para ver si est\u00e1n los registros. En <code>SimSim</code> selecciona la app <code>Restaurante</code> y luego la opci\u00f3n <code>Terminal</code> para abrir una terminal en la carpeta de la app en el emulador. Para ver a base de datos SQLite puedes hacer en esta terminal:</p> <pre><code>cd \"Library/Application Support\"\nsqlite3 Restaurante.sqlite\n##Deber\u00eda aparecer el prompt de sqlite -&gt; \"sqlite&gt;\"\n##Con esta orden puedes ver la estructura de la BD\n.schema\n##Las tablas tendr\u00e1n el mismo nombre que las entidades de Core Data con una \"Z\" delante\n##Por tanto puedes ver los platos con\nselect * from ZPLATO;\n##Puedes salir de sqlite con Ctrl-Z, o cerrar la terminal, ya no te hace falta \n</code></pre> <p>Para forzar la recarga de los datos puedes usar tambi\u00e9n la aplicaci\u00f3n <code>SimSim</code> . Tendr\u00e1s que borrar las preferencias y la base de datos. Puedes borrarlo todo autom\u00e1ticamente con la opci\u00f3n <code>Reset Application Data</code>. Si quieres borrarlo a mano, las preferencias est\u00e1n en <code>Library/Preferences</code> y recuerda que la BD est\u00e1 en <code>Library/Application Support</code>.</p> <p>A partir de ahora implementaremos las funcionalidades de la app. La mayor parte de la interfaz ya est\u00e1 creada (salvo la \u00faltima pantalla), t\u00fa tienes que implementar las funcionalidades relacionadas con Core Data.</p>"},{"location":"miniproyecto/restaurante/#funcionalidad-la-carta-05-puntos","title":"Funcionalidad: La Carta (0,5 puntos)","text":"<p>Esta parte de la app es la que muestra los platos y nos permite a\u00f1adirlos al pedido.</p> <p>En la pantalla de \"Carta\" se deben mostrar los datos de los platos. Est\u00e1 controlada por el <code>PlatosViewController</code>. Iremos primero con que salgan los platos listados y luego con la funcionalidad del bot\u00f3n de \"A\u00f1adir\" al pedido.</p>"},{"location":"miniproyecto/restaurante/#listado-de-platos","title":"Listado de platos","text":"<p>Usa un <code>NSFetchedResultsController</code> para listar los platos en la tabla. Haz que los platos se agrupen en secciones seg\u00fan su tipo.</p> <ul> <li>Declara e inicializa el <code>NSFetchedResultsController</code> en el <code>PlatosViewController</code>.  Es como los de la sesi\u00f3n anterior con la diferencia de que no deber\u00eda usar una cache (pasar el par\u00e1metro <code>cacheName</code> a <code>nil</code>) , ya que al escribir en la barra de b\u00fasqueda cambiamos la fetch request y por tanto invalidamos la cache, por lo que en este caso no tiene utilidad.</li> </ul> <p>Ayuda</p> <p>Para lo anterior, puedes usar como gu\u00eda el c\u00f3digo de ejemplo del apartado \"inicializar el Fetched Results Controller\". Pero con diferencias, algunas evidentes:</p> <ul> <li>Recuerda poner el nombre de cache a <code>nil</code> </li> <li>La entidad es <code>Plato</code> en lugar de <code>Mensaje</code></li> <li>Hay que ordenar por \"tipo\" en vez de por \"fecha\"</li> <li>Hay que crear secciones autom\u00e1ticas bas\u00e1ndose en el tipo (mira el apartado \"secciones de tabla autom\u00e1ticas \")</li> </ul> <ul> <li>Rellena el c\u00f3digo de los m\u00e9todos que devuelven el n\u00famero de secciones, de filas en cada secci\u00f3n y que devuelven las celdas rellenadas de la tabla. Estas celdas son de la clase <code>PlatoTableViewCell</code>, si miras la clase ver\u00e1s que ya tiene definidos outlets para poder rellenar los datos (son tres labels: <code>nombreLabel</code>, <code>descripcionLabel</code> y <code>precioLabel</code>)</li> </ul> <p>Ayuda</p> <p>Para lo anterior, puedes usar como gu\u00eda el c\u00f3digo de ejemplo del apartado \"Mostrar los datos en la tabla\". Para saber c\u00f3mo obtener el t\u00edtulo de cada secci\u00f3n de la tabla consulta el apartado \"Secciones de tabla autom\u00e1ticas\" </p> <p>Al terminar este apartado deber\u00eda salir la lista de platos de la carta en la primera pantalla de la app. Todav\u00eda no funcionar\u00e1 el bot\u00f3n \"A\u00f1adir\" de cada plato ni se podr\u00e1n filtrar platos.</p>"},{"location":"miniproyecto/restaurante/#busquedafiltrado-de-platos","title":"B\u00fasqueda/Filtrado de platos","text":"<p>Implementa una b\u00fasqueda/filtrado de platos como hiciste en la aplicaci\u00f3n de notas, que busque texto en el nombre o en la descripci\u00f3n del plato. Para aplicar el \"filtro\":</p> <p>Declara un <code>UISearchController</code> en el <code>PlatosViewController</code> </p> <pre><code>var searchController : UISearchController!\n</code></pre> <p>e inicial\u00edzalo en el <code>viewDidLoad</code></p> <pre><code>self.searchController = UISearchController(searchResultsController: nil)\n</code></pre> <p>A\u00f1ade <code>UISearchResultsUpdating</code> a la cabecera del controller para que se ocupe de los resultados de la b\u00fasqueda, debe quedar como:</p> <pre><code>class PlatosViewController: UIViewController, UITableViewDataSource, PlatoTableViewCellDelegate, UISearchResultsUpdating  {\n    ...\n}\n</code></pre> <p>Xcode</p> <p>Al a\u00f1adir el <code>UISearchResultsUpdating</code> Xcode se \"quejar\u00e1\"\" de que falta implementar el m\u00e9todo <code>updateSearchResults</code>. Lo haremos en un momento. </p> <p>Configura el search controller y a\u00f1\u00e1delo a la tabla en el <code>viewDidLoad</code> <pre><code>self.searchController.searchResultsUpdater = self\n//Configuramos el search controller\nself.searchController.obscuresBackgroundDuringPresentation = false\nself.searchController.searchBar.placeholder = \"Buscar texto\"\n//Lo a\u00f1adimos a la tabla\nself.searchController.searchBar.sizeToFit()\nself.tabla.tableHeaderView = searchController.searchBar\n</code></pre></p> <p>Opcionalmente puedes usar un Throttler para que no busque en cada pulsaci\u00f3n de tecla, sino que espere una fracci\u00f3n de segundo. En caso de que quieras usarlo, b\u00e1jate el c\u00f3digo del enlace anterior, ponlo en un archivo en tu proyecto y define en el controller una variable de la clase <code>Throttler</code>:</p> <pre><code>let throttler = Throttler(minimumDelay: 0.5)\n</code></pre> <p>A\u00f1ade el m\u00e9todo <code>updateSearchResults</code> al <code>PlatosViewController</code>, aqu\u00ed es donde realmente tienes que implementar el filtrado (en un momento veremos c\u00f3mo)</p> <pre><code>func updateSearchResults(for searchController: UISearchController) {\n    //este throttler.throttle solo si quieres usar throttling\n    //en caso contrario solo el let textoBuscado=... etc\n    throttler.throttle {\n        let textoBuscado = searchController.searchBar.text!\n        //Aqu\u00ed ir\u00eda tu c\u00f3digo de b\u00fasqueda\n    }\n}\n</code></pre> <p>Borrar la cache</p> <p>Ya hemos comentado que el <code>NSFetchedResultsController</code> no necesita cache, pero si la tuviera, en este momento se deber\u00eda borrar con el m\u00e9todo <code>NSFetchedResultsController.deleteCache(withName:)</code> para evitar un error al cambiar la fetch request.</p> <p>Crea un predicado (<code>NSPredicate</code>) con la condici\u00f3n de b\u00fasqueda apropiada para buscar el <code>textoBuscado</code> en el nombre o la descripci\u00f3n (no debe distinguir may\u00fasculas/min\u00fasculas ni acentos) y as\u00edgnaselo a la propiedad <code>fetchRequest.predicate</code> del <code>NSFetchedResultsController</code>. </p> <p>Ayuda</p> <p>Para lo anterior, puedes usar como gu\u00eda el apartado \"Predicados como cadenas\" del tema de b\u00fasquedas en Core Data.</p> <p>Para que se actualicen los datos tendr\u00e1s que hacer:</p> <p><pre><code>try! self.frc.performFetch()\nself.tabla.reloadData()\n</code></pre> Tras hacer esto ya deber\u00eda funcionar el filtrado de platos, compru\u00e9balo.</p> <p>Problema con las b\u00fasquedas</p> <p>Si pruebas la b\u00fasqueda ver\u00e1s que con el cuadro de b\u00fasqueda inicialmente vac\u00edo se muestran todos los platos, cuando escribes algo se filtran pero cuando vuelves a borrar y lo dejas vac\u00edo no se ve ning\u00fan plato. Esto es porque aunque <code>textoBuscado</code>sea vac\u00edo sigue actuando el predicado de b\u00fasqueda. \u00bfSe te ocurre c\u00f3mo podr\u00edas arreglarlo? Int\u00e9ntalo.</p>"},{"location":"miniproyecto/restaurante/#anadir-al-pedido-actual","title":"A\u00f1adir al pedido actual","text":"<p>Las celdas de la tabla tienen un delegate al que  avisar\u00e1n de que se ha pulsado el bot\u00f3n \"A\u00f1adir\". Cada celda almacena su <code>IndexPath</code> (su n\u00famero de fila y de secci\u00f3n) y tiene como delegate al controller de la pantalla.</p> <p>Para avisar al controller de que se ha pulsado sobre \"A\u00f1adir\" se llama al m\u00e9todo <code>platoA\u00f1adido</code>. En este m\u00e9todo tienes que obtener la entidad <code>Plato</code> elegida (la que est\u00e1 en la fila y secci\u00f3n seleccionadas) para que el c\u00f3digo restante (ya implementado) se lo pase al controller de la pantalla siguiente.</p> <p>Warning</p> <p>Tendr\u00e1s que descomentar adem\u00e1s la l\u00ednea que pone <code>//TODO: descomentar esta l\u00ednea</code> del <code>PlatosViewController</code> y la 21 del <code>PedidoActualViewController</code>. Estaban comentadas para que el c\u00f3digo compilara en el estado inicial del proyecto, antes de que existiera la entidad \"Plato\"</p> <p>Para probar que est\u00e1 bien, en el <code>viewDidLoad</code> del <code>PedidoActualViewController</code> imprime en la consola con <code>print</code> alg\u00fan dato de la propiedad <code>platoElegido</code>, para comprobar que se corresponde con el seleccionado. De momento el plato no aparece todav\u00eda en la pantalla del m\u00f3vil, de eso nos ocuparemos en el siguiente apartado.</p>"},{"location":"miniproyecto/restaurante/#funcionalidad-el-pedido-actual-075-puntos","title":"Funcionalidad: El pedido actual (0,75 puntos)","text":"<p>Esta parte de la app muestra los datos del pedido actual, a\u00f1ade los platos seleccionados al pedido y permite hacer el pedido o cancelarlo. La pantalla est\u00e1 controlada por el <code>PedidoActualViewController</code>.</p> <p>Problemas con el Tab bar</p> <p>A esta pantalla se puede llegar de dos modos, al a\u00f1adir un plato al pedido o bien con el bot\u00f3n \"Tu pedido\" del tab bar en la parte inferior de la pantalla. Mientras est\u00e9s implementando esta pantalla es probable que el bot\u00f3n del tab bar cause un error fatal, al final veremos por qu\u00e9 y lo intentaremos arreglar.</p> <p>El pedido actual no se puede guardar en el propio controller ya que por la navegaci\u00f3n entre pantallas este se destruir\u00eda al salir de ella. Por eso se debe guardar aparte, en la variable <code>pedidoActual</code> del singleton <code>StateSingleton.shared</code>. Esta variable estaba comentada para que no diera error  ya que hasta que no creaste el modelo de datos no exist\u00eda la entidad <code>Pedido</code>, descom\u00e9ntala (l\u00ednea 5 de carpeta State/Archivo StateSingleton.swift). </p>"},{"location":"miniproyecto/restaurante/#anadir-el-plato-elegido-al-pedido","title":"A\u00f1adir el plato elegido al pedido","text":"<p>En el <code>viewDidLoad</code> de <code>PedidoActualViewController</code> nos tenemos que ocupar de a\u00f1adir el plato elegido al pedido actual</p> <ul> <li>Primero comprueba si no hay en memoria un <code>Pedido</code> actual (<code>StateSingleton.shared.pedidoActual==nil</code>), y si es as\u00ed cr\u00e9alo en Core Data, gu\u00e1rdalo en el <code>StateSingleton</code> y haz save() del contexto de persistencia</li> <li>Crea una nueva <code>LineaPedido</code><ul> <li>As\u00edgnale cantidad 1 (luego se podr\u00e1 cambiar con los botones de <code>+/-</code>)</li> <li>As\u00f3ciala con el plato elegido. Recuerda que el plato elegido deber\u00eda estar en la propiedad <code>platoElegido</code> del controller.</li> <li>As\u00f3ciala con el pedido</li> </ul> </li> </ul> <p>Asociar entidades en Core Data</p> <p>Recuerda que las relaciones en Core Data son como propiedades de los objetos. Por ejemplo para asociar una l\u00ednea de pedido con un plato har\u00edas simplemente <pre><code>//Suponiendo que \"linea\" es de tipo LineaPedido y \"elPlato\" de tipo \"Plato\"\nlinea.plato = elPlato\n</code></pre> Si la relaci\u00f3n es \"a muchos\" tendr\u00edas que usar un m\u00e9todo de los generados por xCode que empiezan por <code>addTo...</code>. El ejemplo anterior lo podr\u00edas hacer tambi\u00e9n como</p> <pre><code>elPlato.addToLineasPedido(linea)\n</code></pre> <p>Aunque es mucho menos intuitivo</p> <ul> <li>Guarda el contexto de persistencia con <code>save()</code> para que los cambios tengan efecto en la BD.</li> </ul>"},{"location":"miniproyecto/restaurante/#listar-los-platos-del-pedido","title":"Listar los platos del pedido","text":"<p>Como puedes ver en el c\u00f3digo del <code>PedidoActualViewController</code> \u00e9ste hace de <code>UITableViewDataSource</code>, es decir es el responsable de darle a iOS los datos para pintar la tabla que muestre el pedido actual.</p> <p>Tendr\u00e1s que completar el c\u00f3digo de los m\u00e9todos</p> <ul> <li><code>tableView(_ tableView: UITableView, numberOfRowsInSection section: Int)</code></li> <li><code>tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath)</code> </li> </ul> <p>para que la tabla se vea en pantalla. La celda es de la clase <code>LineaPedidoTableViewCell</code> y como podr\u00e1s ver en ella tiene un <code>nombreLabel</code> y un <code>cantidadLabel</code> que son los datos que tendr\u00e1s que rellenar con el nombre del plato y la cantidad de la l\u00ednea de pedido respectivamente.</p>"},{"location":"miniproyecto/restaurante/#cambiar-la-cantidad-de-un-plato","title":"Cambiar la cantidad de un plato","text":"<p>En esta pantalla tambi\u00e9n se puede cambiar el n\u00famero de unidades que queremos pedir de un plato. </p> <p>Para simplificar se supondr\u00e1 que solo podemos movernos entre 1 y 100, no podemos bajar las unidades a 0 y eliminar el plato</p> <p>Al igual que en la pantalla anterior se usa la idea de delegate para saber qu\u00e9 celda se est\u00e1 seleccionando. Las celdas son de la clase <code>LineaPedidoTableviewCell</code>, y cada vez que se pulsa en un <code>+</code> o un <code>-</code> se avisa al delegate (en este caso el controller), pas\u00e1ndole el n\u00famero de la fila.</p> <p>La interfaz ya est\u00e1 configurada para que el m\u00e9todo <code>cantidadCambiada</code> del controller se llame cada vez que el usuario cambia la cantidad de un plato. A\u00f1\u00e1dele c\u00f3digo que obtenga la l\u00ednea de pedido correspondiente, cambie la cantidad y guarde el contexto de persistencia</p>"},{"location":"miniproyecto/restaurante/#realizar-y-cancelar-pedido","title":"Realizar y cancelar pedido","text":"<p>En la pantalla tienes dos botones para realizar y cancelar el pedido. </p> <ul> <li>Si se pulsa a \"realizar\" bastar\u00e1 con que le asignes la fecha actual al pedido, crees un nuevo pedido en <code>StateSingleton.shared.pedidoActual</code> y muestres un mensaje al usuario indicando que \"su pedido est\u00e1 en camino\" o algo similar</li> <li>Si se pulsa a \"cancelar\" deber\u00edas borrar en Core Data el pedido actual. Si la regla de borrado en cascada est\u00e1 puesta correctamente, al borrar un pedido deber\u00edan borrarse  autom\u00e1ticamente todas sus l\u00edneas.</li> </ul>"},{"location":"miniproyecto/restaurante/#el-boton-tu-pedido-del-tab-bar","title":"El bot\u00f3n \"Tu pedido\" del tab bar","text":"<p>Como ya hemos comentado, a la pantalla de pedido actual tambi\u00e9n se puede llegar pulsando el bot\u00f3n de \"Tu pedido\" en el tab bar inferior. No obstante, como al ir por este camino no hay un <code>platoElegido</code> es bastante probable que tu c\u00f3digo falle al asumir que s\u00ed lo hay. Si falla, cambia el c\u00f3digo para que si  hay <code>platoElegido</code> (<code>!=nil</code>)  cree la nueva l\u00ednea de pedido pero no lo haga si es <code>nil</code>.</p>"},{"location":"miniproyecto/restaurante/#funcionalidad-tu-historial-hasta-05-puntos","title":"Funcionalidad: Tu historial (hasta 0,5 puntos)","text":"<p>En esta pantalla se deber\u00edan mostrar todos los pedidos realizados por el usuario actual. La pantalla est\u00e1 controlada por el (<code>PedidosViewController</code>). Est\u00e1 en blanco y puedes crear la interfaz del modo que desees.</p> <ul> <li>(0,25 puntos) Si en el <code>viewWillAppear</code> muestras los datos de todos los pedidos en la consola con <code>print</code>, solo para ver que efectivamente se han almacenado correctamente</li> <li>(0,5 puntos) Si en lugar de lo anterior muestras en una tabla una l\u00ednea con el resumen de cada pedido (fecha, total y n\u00famero de platos pedidos)</li> </ul>"},{"location":"miniproyecto/restaurante/#apendice-diagrama-uml-de-las-clases-del-proyecto","title":"Ap\u00e9ndice: diagrama UML de las clases del proyecto","text":""}]}